"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/chat-stream";
exports.ids = ["pages/api/chat-stream"];
exports.modules = {

/***/ "dotenv/config":
/*!********************************!*\
  !*** external "dotenv/config" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("dotenv/config");

/***/ }),

/***/ "google-auth-library":
/*!**************************************!*\
  !*** external "google-auth-library" ***!
  \**************************************/
/***/ ((module) => {

module.exports = require("google-auth-library");

/***/ }),

/***/ "googleapis":
/*!*****************************!*\
  !*** external "googleapis" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("googleapis");

/***/ }),

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "next-auth":
/*!****************************!*\
  !*** external "next-auth" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("next-auth");

/***/ }),

/***/ "next-auth/next":
/*!*********************************!*\
  !*** external "next-auth/next" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("next-auth/next");

/***/ }),

/***/ "next-auth/providers/google":
/*!*********************************************!*\
  !*** external "next-auth/providers/google" ***!
  \*********************************************/
/***/ ((module) => {

module.exports = require("next-auth/providers/google");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "node-cache":
/*!*****************************!*\
  !*** external "node-cache" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-cache");

/***/ }),

/***/ "luxon":
/*!************************!*\
  !*** external "luxon" ***!
  \************************/
/***/ ((module) => {

module.exports = import("luxon");;

/***/ }),

/***/ "openai":
/*!*************************!*\
  !*** external "openai" ***!
  \*************************/
/***/ ((module) => {

module.exports = import("openai");;

/***/ }),

/***/ "sequelize":
/*!****************************!*\
  !*** external "sequelize" ***!
  \****************************/
/***/ ((module) => {

module.exports = import("sequelize");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/chat-stream.js */ \"(api)/./pages/api/chat-stream.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/chat-stream\",\n        pathname: \"/api/chat-stream\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmNoYXQtc3RyZWFtJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZhcGklMkZjaGF0LXN0cmVhbS5qcyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUN1RDtBQUN2RDtBQUNBLGlFQUFlLHdFQUFLLENBQUMsc0RBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLHNEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCxxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8/NzRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvYXBpL2NoYXQtc3RyZWFtLmpzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvY2hhdC1zdHJlYW1cIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jaGF0LXN0cmVhbVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./googleCalendar.js":
/*!***************************!*\
  !*** ./googleCalendar.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { google } = __webpack_require__(/*! googleapis */ \"googleapis\");\nconst { OAuth2Client } = __webpack_require__(/*! google-auth-library */ \"google-auth-library\");\n/**\n * Creates and configures an OAuth2Client with the provided tokens\n * @param {Object} tokens - The tokens object containing access_token and optionally refresh_token\n * @returns {OAuth2Client} - Configured OAuth2Client instance\n */ function createOAuth2Client(tokens) {\n    try {\n        const credentials = __webpack_require__(/*! ./credentials.json */ \"(api)/./credentials.json\");\n        const { client_secret, client_id, redirect_uris } = credentials.web;\n        const oauth2Client = new OAuth2Client(client_id, client_secret, redirect_uris[0]);\n        // Handle both full tokens object and just access_token\n        if (typeof tokens === \"object\" && tokens !== null) {\n            if (tokens.access_token) {\n                // If it's just the access_token from NextAuth session\n                oauth2Client.setCredentials({\n                    access_token: tokens.access_token,\n                    refresh_token: tokens.refresh_token,\n                    token_type: \"Bearer\"\n                });\n            } else {\n                // If it's a full tokens object\n                oauth2Client.setCredentials(tokens);\n            }\n        } else {\n            console.error(\"Invalid tokens format:\", tokens);\n            throw new Error(\"Invalid tokens format\");\n        }\n        return oauth2Client;\n    } catch (error) {\n        console.error(\"Error creating OAuth2Client:\", error);\n        throw error;\n    }\n}\n/**\n * Get calendar events for a specific date range\n * @param {Object} tokens - User's OAuth tokens\n * @param {Date} start_date - Start date for events\n * @param {Date} end_date - End date for events\n * @returns {Array} - List of calendar events\n */ async function getCalendarEvents(tokens, start_date, end_date) {\n    try {\n        const oauth2Client = createOAuth2Client(tokens);\n        const calendar = google.calendar({\n            version: \"v3\",\n            auth: oauth2Client\n        });\n        const res = await calendar.events.list({\n            calendarId: \"primary\",\n            timeMin: start_date.toISOString(),\n            timeMax: end_date.toISOString(),\n            singleEvents: true,\n            orderBy: \"startTime\"\n        });\n        return res.data.items || [];\n    } catch (error) {\n        console.error(\"Error fetching events:\", error);\n        return [];\n    }\n}\n/**\n * Add a new calendar event\n * @param {Object} tokens - User's OAuth tokens\n * @param {string} summary - Event title\n * @param {string} start - Event start time\n * @param {string} end - Event end time\n * @param {string} description - Event description\n * @param {string} location - Event location\n * @param {Array} reminders - Optional reminders in minutes\n * @returns {Object} - Created event data\n */ async function addCalendarEvent(tokens, summary, start, end, description, location, reminders) {\n    const oauth2Client = createOAuth2Client(tokens);\n    const calendar = google.calendar({\n        version: \"v3\",\n        auth: oauth2Client\n    });\n    const event = {\n        summary,\n        description,\n        location,\n        start: {\n            dateTime: start\n        },\n        end: {\n            dateTime: end\n        }\n    };\n    // Add reminders if provided\n    if (reminders && Array.isArray(reminders) && reminders.length > 0) {\n        event.reminders = {\n            useDefault: false,\n            overrides: reminders.map((minutes)=>({\n                    method: \"popup\",\n                    minutes: minutes\n                }))\n        };\n    }\n    try {\n        const res = await calendar.events.insert({\n            calendarId: \"primary\",\n            resource: event\n        });\n        return res.data;\n    } catch (error) {\n        console.error(\"Error adding event:\", error);\n        throw error;\n    }\n}\n/**\n * Delete a calendar event\n * @param {Object} tokens - User's OAuth tokens\n * @param {string} eventId - ID of the event to delete \n * @param {string} calendarId - Calendar ID (defaults to 'primary')\n * @returns {Object} - Deleted event summary\n */ async function deleteCalendarEvent(tokens, eventId, calendarId = \"primary\") {\n    // Validate inputs\n    if (!tokens) {\n        throw new Error(\"OAuth tokens are required\");\n    }\n    if (!eventId) {\n        throw new Error(\"Event ID is required\");\n    }\n    const oauth2Client = createOAuth2Client(tokens);\n    const calendar = google.calendar({\n        version: \"v3\",\n        auth: oauth2Client\n    });\n    try {\n        // First get the event to return its summary after deletion\n        let eventSummary = null;\n        try {\n            const event = await calendar.events.get({\n                calendarId: calendarId,\n                eventId: eventId\n            });\n            eventSummary = event.data.summary;\n        } catch (getError) {\n            console.warn(`Could not retrieve event details before deletion: ${getError.message}`);\n        }\n        await calendar.events.delete({\n            calendarId: calendarId,\n            eventId: eventId\n        });\n        return {\n            success: true,\n            summary: eventSummary,\n            eventId: eventId\n        };\n    } catch (error) {\n        console.error(`Error deleting event ${eventId}:`, error.message);\n        return {\n            success: false,\n            error: error.message,\n            eventId: eventId\n        };\n    }\n}\n/**\n * Update a calendar event\n * @param {Object} tokens - User's OAuth tokens\n * @param {string} eventId - ID of the event to update\n * @param {Object} updates - Object containing fields to update\n * @returns {Object} - Updated event data\n */ async function updateCalendarEvent(tokens, eventId, updates) {\n    const oauth2Client = createOAuth2Client(tokens);\n    const calendar = google.calendar({\n        version: \"v3\",\n        auth: oauth2Client\n    });\n    try {\n        // First get the current event\n        const currentEvent = await calendar.events.get({\n            calendarId: \"primary\",\n            eventId: eventId\n        });\n        // Prepare the update payload\n        const updatedEvent = {\n            ...currentEvent.data\n        };\n        if (updates.summary) updatedEvent.summary = updates.summary;\n        if (updates.description) updatedEvent.description = updates.description;\n        if (updates.location) updatedEvent.location = updates.location;\n        if (updates.start) {\n            updatedEvent.start = {\n                dateTime: updates.start,\n                timeZone: currentEvent.data.start.timeZone\n            };\n        }\n        if (updates.end) {\n            updatedEvent.end = {\n                dateTime: updates.end,\n                timeZone: currentEvent.data.end.timeZone\n            };\n        }\n        // Update the event\n        const res = await calendar.events.update({\n            calendarId: \"primary\",\n            eventId: eventId,\n            resource: updatedEvent\n        });\n        return res.data;\n    } catch (error) {\n        console.error(\"Error updating event:\", error);\n        throw error;\n    }\n}\nmodule.exports = {\n    createOAuth2Client,\n    getCalendarEvents,\n    addCalendarEvent,\n    deleteCalendarEvent,\n    updateCalendarEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9nb29nbGVDYWxlbmRhci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFakM7Ozs7Q0FJQyxHQUNELFNBQVNFLG1CQUFtQkMsTUFBTTtJQUNoQyxJQUFJO1FBQ0YsTUFBTUMsY0FBY0osbUJBQU9BLENBQUM7UUFDNUIsTUFBTSxFQUFFSyxhQUFhLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFLEdBQUdILFlBQVlJLEdBQUc7UUFDbkUsTUFBTUMsZUFBZSxJQUFJUixhQUFhSyxXQUFXRCxlQUFlRSxhQUFhLENBQUMsRUFBRTtRQUVoRix1REFBdUQ7UUFDdkQsSUFBSSxPQUFPSixXQUFXLFlBQVlBLFdBQVcsTUFBTTtZQUNqRCxJQUFJQSxPQUFPTyxZQUFZLEVBQUU7Z0JBQ3ZCLHNEQUFzRDtnQkFDdERELGFBQWFFLGNBQWMsQ0FBQztvQkFDMUJELGNBQWNQLE9BQU9PLFlBQVk7b0JBQ2pDRSxlQUFlVCxPQUFPUyxhQUFhO29CQUNuQ0MsWUFBWTtnQkFDZDtZQUNGLE9BQU87Z0JBQ0wsK0JBQStCO2dCQUMvQkosYUFBYUUsY0FBYyxDQUFDUjtZQUM5QjtRQUNGLE9BQU87WUFDTFcsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQlo7WUFDeEMsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO1FBRUEsT0FBT1A7SUFDVCxFQUFFLE9BQU9NLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ0E7UUFDOUMsTUFBTUE7SUFDUjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsZUFBZUUsa0JBQWtCZCxNQUFNLEVBQUVlLFVBQVUsRUFBRUMsUUFBUTtJQUMzRCxJQUFJO1FBQ0YsTUFBTVYsZUFBZVAsbUJBQW1CQztRQUN4QyxNQUFNaUIsV0FBV3JCLE9BQU9xQixRQUFRLENBQUM7WUFBRUMsU0FBUztZQUFNQyxNQUFNYjtRQUFhO1FBQ3JFLE1BQU1jLE1BQU0sTUFBTUgsU0FBU0ksTUFBTSxDQUFDQyxJQUFJLENBQUM7WUFDckNDLFlBQVk7WUFDWkMsU0FBU1QsV0FBV1UsV0FBVztZQUMvQkMsU0FBU1YsU0FBU1MsV0FBVztZQUM3QkUsY0FBYztZQUNkQyxTQUFTO1FBQ1g7UUFDQSxPQUFPUixJQUFJUyxJQUFJLENBQUNDLEtBQUssSUFBSSxFQUFFO0lBQzdCLEVBQUUsT0FBT2xCLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxlQUFlbUIsaUJBQWlCL0IsTUFBTSxFQUFFZ0MsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLFNBQVM7SUFDM0YsTUFBTS9CLGVBQWVQLG1CQUFtQkM7SUFDeEMsTUFBTWlCLFdBQVdyQixPQUFPcUIsUUFBUSxDQUFDO1FBQUVDLFNBQVM7UUFBTUMsTUFBTWI7SUFBYTtJQUVyRSxNQUFNZ0MsUUFBUTtRQUNaTjtRQUNBRztRQUNBQztRQUNBSCxPQUFPO1lBQUVNLFVBQVVOO1FBQU07UUFDekJDLEtBQUs7WUFBRUssVUFBVUw7UUFBSTtJQUN2QjtJQUVBLDRCQUE0QjtJQUM1QixJQUFJRyxhQUFhRyxNQUFNQyxPQUFPLENBQUNKLGNBQWNBLFVBQVVLLE1BQU0sR0FBRyxHQUFHO1FBQ2pFSixNQUFNRCxTQUFTLEdBQUc7WUFDaEJNLFlBQVk7WUFDWkMsV0FBV1AsVUFBVVEsR0FBRyxDQUFDQyxDQUFBQSxVQUFZO29CQUNuQ0MsUUFBUTtvQkFDUkQsU0FBU0E7Z0JBQ1g7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU0xQixNQUFNLE1BQU1ILFNBQVNJLE1BQU0sQ0FBQzJCLE1BQU0sQ0FBQztZQUN2Q3pCLFlBQVk7WUFDWjBCLFVBQVVYO1FBQ1o7UUFDQSxPQUFPbEIsSUFBSVMsSUFBSTtJQUNqQixFQUFFLE9BQU9qQixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyx1QkFBdUJBO1FBQ3JDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELGVBQWVzQyxvQkFBb0JsRCxNQUFNLEVBQUVtRCxPQUFPLEVBQUU1QixhQUFhLFNBQVM7SUFDeEUsa0JBQWtCO0lBQ2xCLElBQUksQ0FBQ3ZCLFFBQVE7UUFDWCxNQUFNLElBQUlhLE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNzQyxTQUFTO1FBQ1osTUFBTSxJQUFJdEMsTUFBTTtJQUNsQjtJQUVBLE1BQU1QLGVBQWVQLG1CQUFtQkM7SUFDeEMsTUFBTWlCLFdBQVdyQixPQUFPcUIsUUFBUSxDQUFDO1FBQUVDLFNBQVM7UUFBTUMsTUFBTWI7SUFBYTtJQUVyRSxJQUFJO1FBQ0YsMkRBQTJEO1FBQzNELElBQUk4QyxlQUFlO1FBQ25CLElBQUk7WUFDRixNQUFNZCxRQUFRLE1BQU1yQixTQUFTSSxNQUFNLENBQUNnQyxHQUFHLENBQUM7Z0JBQ3RDOUIsWUFBWUE7Z0JBQ1o0QixTQUFTQTtZQUNYO1lBQ0FDLGVBQWVkLE1BQU1ULElBQUksQ0FBQ0csT0FBTztRQUNuQyxFQUFFLE9BQU9zQixVQUFVO1lBQ2pCM0MsUUFBUTRDLElBQUksQ0FBQyxDQUFDLGtEQUFrRCxFQUFFRCxTQUFTRSxPQUFPLENBQUMsQ0FBQztRQUN0RjtRQUVBLE1BQU12QyxTQUFTSSxNQUFNLENBQUNvQyxNQUFNLENBQUM7WUFDM0JsQyxZQUFZQTtZQUNaNEIsU0FBU0E7UUFDWDtRQUNBLE9BQU87WUFBRU8sU0FBUztZQUFNMUIsU0FBU29CO1lBQWNELFNBQVNBO1FBQVE7SUFDbEUsRUFBRSxPQUFPdkMsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsRUFBRXVDLFFBQVEsQ0FBQyxDQUFDLEVBQUV2QyxNQUFNNEMsT0FBTztRQUMvRCxPQUFPO1lBQUVFLFNBQVM7WUFBTzlDLE9BQU9BLE1BQU00QyxPQUFPO1lBQUVMLFNBQVNBO1FBQVE7SUFDbEU7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELGVBQWVRLG9CQUFvQjNELE1BQU0sRUFBRW1ELE9BQU8sRUFBRVMsT0FBTztJQUN6RCxNQUFNdEQsZUFBZVAsbUJBQW1CQztJQUN4QyxNQUFNaUIsV0FBV3JCLE9BQU9xQixRQUFRLENBQUM7UUFBRUMsU0FBUztRQUFNQyxNQUFNYjtJQUFhO0lBRXJFLElBQUk7UUFDRiw4QkFBOEI7UUFDOUIsTUFBTXVELGVBQWUsTUFBTTVDLFNBQVNJLE1BQU0sQ0FBQ2dDLEdBQUcsQ0FBQztZQUM3QzlCLFlBQVk7WUFDWjRCLFNBQVNBO1FBQ1g7UUFFQSw2QkFBNkI7UUFDN0IsTUFBTVcsZUFBZTtZQUFFLEdBQUdELGFBQWFoQyxJQUFJO1FBQUM7UUFFNUMsSUFBSStCLFFBQVE1QixPQUFPLEVBQUU4QixhQUFhOUIsT0FBTyxHQUFHNEIsUUFBUTVCLE9BQU87UUFDM0QsSUFBSTRCLFFBQVF6QixXQUFXLEVBQUUyQixhQUFhM0IsV0FBVyxHQUFHeUIsUUFBUXpCLFdBQVc7UUFDdkUsSUFBSXlCLFFBQVF4QixRQUFRLEVBQUUwQixhQUFhMUIsUUFBUSxHQUFHd0IsUUFBUXhCLFFBQVE7UUFFOUQsSUFBSXdCLFFBQVEzQixLQUFLLEVBQUU7WUFDakI2QixhQUFhN0IsS0FBSyxHQUFHO2dCQUNuQk0sVUFBVXFCLFFBQVEzQixLQUFLO2dCQUN2QjhCLFVBQVVGLGFBQWFoQyxJQUFJLENBQUNJLEtBQUssQ0FBQzhCLFFBQVE7WUFDNUM7UUFDRjtRQUVBLElBQUlILFFBQVExQixHQUFHLEVBQUU7WUFDZjRCLGFBQWE1QixHQUFHLEdBQUc7Z0JBQ2pCSyxVQUFVcUIsUUFBUTFCLEdBQUc7Z0JBQ3JCNkIsVUFBVUYsYUFBYWhDLElBQUksQ0FBQ0ssR0FBRyxDQUFDNkIsUUFBUTtZQUMxQztRQUNGO1FBRUEsbUJBQW1CO1FBQ25CLE1BQU0zQyxNQUFNLE1BQU1ILFNBQVNJLE1BQU0sQ0FBQzJDLE1BQU0sQ0FBQztZQUN2Q3pDLFlBQVk7WUFDWjRCLFNBQVNBO1lBQ1RGLFVBQVVhO1FBQ1o7UUFFQSxPQUFPMUMsSUFBSVMsSUFBSTtJQUNqQixFQUFFLE9BQU9qQixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3ZDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBcUQsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZuRTtJQUNBZTtJQUNBaUI7SUFDQW1CO0lBQ0FTO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nY2FsZW5kYXJhcHAvLi9nb29nbGVDYWxlbmRhci5qcz8xMGYxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgZ29vZ2xlIH0gPSByZXF1aXJlKCdnb29nbGVhcGlzJyk7XG5jb25zdCB7IE9BdXRoMkNsaWVudCB9ID0gcmVxdWlyZSgnZ29vZ2xlLWF1dGgtbGlicmFyeScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGNvbmZpZ3VyZXMgYW4gT0F1dGgyQ2xpZW50IHdpdGggdGhlIHByb3ZpZGVkIHRva2Vuc1xuICogQHBhcmFtIHtPYmplY3R9IHRva2VucyAtIFRoZSB0b2tlbnMgb2JqZWN0IGNvbnRhaW5pbmcgYWNjZXNzX3Rva2VuIGFuZCBvcHRpb25hbGx5IHJlZnJlc2hfdG9rZW5cbiAqIEByZXR1cm5zIHtPQXV0aDJDbGllbnR9IC0gQ29uZmlndXJlZCBPQXV0aDJDbGllbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucykge1xuICB0cnkge1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi9jcmVkZW50aWFscy5qc29uJyk7XG4gICAgY29uc3QgeyBjbGllbnRfc2VjcmV0LCBjbGllbnRfaWQsIHJlZGlyZWN0X3VyaXMgfSA9IGNyZWRlbnRpYWxzLndlYjtcbiAgICBjb25zdCBvYXV0aDJDbGllbnQgPSBuZXcgT0F1dGgyQ2xpZW50KGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCwgcmVkaXJlY3RfdXJpc1swXSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIGJvdGggZnVsbCB0b2tlbnMgb2JqZWN0IGFuZCBqdXN0IGFjY2Vzc190b2tlblxuICAgIGlmICh0eXBlb2YgdG9rZW5zID09PSAnb2JqZWN0JyAmJiB0b2tlbnMgIT09IG51bGwpIHtcbiAgICAgIGlmICh0b2tlbnMuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIC8vIElmIGl0J3MganVzdCB0aGUgYWNjZXNzX3Rva2VuIGZyb20gTmV4dEF1dGggc2Vzc2lvblxuICAgICAgICBvYXV0aDJDbGllbnQuc2V0Q3JlZGVudGlhbHMoe1xuICAgICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW5zLmFjY2Vzc190b2tlbixcbiAgICAgICAgICByZWZyZXNoX3Rva2VuOiB0b2tlbnMucmVmcmVzaF90b2tlbixcbiAgICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSBmdWxsIHRva2VucyBvYmplY3RcbiAgICAgICAgb2F1dGgyQ2xpZW50LnNldENyZWRlbnRpYWxzKHRva2Vucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdG9rZW5zIGZvcm1hdDonLCB0b2tlbnMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VucyBmb3JtYXQnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG9hdXRoMkNsaWVudDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBPQXV0aDJDbGllbnQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNhbGVuZGFyIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBkYXRlIHJhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtEYXRlfSBzdGFydF9kYXRlIC0gU3RhcnQgZGF0ZSBmb3IgZXZlbnRzXG4gKiBAcGFyYW0ge0RhdGV9IGVuZF9kYXRlIC0gRW5kIGRhdGUgZm9yIGV2ZW50c1xuICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgY2FsZW5kYXIgZXZlbnRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENhbGVuZGFyRXZlbnRzKHRva2Vucywgc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBvYXV0aDJDbGllbnQgPSBjcmVhdGVPQXV0aDJDbGllbnQodG9rZW5zKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IGdvb2dsZS5jYWxlbmRhcih7IHZlcnNpb246ICd2MycsIGF1dGg6IG9hdXRoMkNsaWVudCB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxlbmRhci5ldmVudHMubGlzdCh7XG4gICAgICBjYWxlbmRhcklkOiAncHJpbWFyeScsXG4gICAgICB0aW1lTWluOiBzdGFydF9kYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICB0aW1lTWF4OiBlbmRfZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgc2luZ2xlRXZlbnRzOiB0cnVlLFxuICAgICAgb3JkZXJCeTogJ3N0YXJ0VGltZScsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcy5kYXRhLml0ZW1zIHx8IFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV2ZW50czonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGNhbGVuZGFyIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IHN1bW1hcnkgLSBFdmVudCB0aXRsZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0IC0gRXZlbnQgc3RhcnQgdGltZVxuICogQHBhcmFtIHtzdHJpbmd9IGVuZCAtIEV2ZW50IGVuZCB0aW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzY3JpcHRpb24gLSBFdmVudCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gRXZlbnQgbG9jYXRpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHJlbWluZGVycyAtIE9wdGlvbmFsIHJlbWluZGVycyBpbiBtaW51dGVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIENyZWF0ZWQgZXZlbnQgZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBhZGRDYWxlbmRhckV2ZW50KHRva2Vucywgc3VtbWFyeSwgc3RhcnQsIGVuZCwgZGVzY3JpcHRpb24sIGxvY2F0aW9uLCByZW1pbmRlcnMpIHtcbiAgY29uc3Qgb2F1dGgyQ2xpZW50ID0gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucyk7XG4gIGNvbnN0IGNhbGVuZGFyID0gZ29vZ2xlLmNhbGVuZGFyKHsgdmVyc2lvbjogJ3YzJywgYXV0aDogb2F1dGgyQ2xpZW50IH0pO1xuICBcbiAgY29uc3QgZXZlbnQgPSB7XG4gICAgc3VtbWFyeSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBsb2NhdGlvbixcbiAgICBzdGFydDogeyBkYXRlVGltZTogc3RhcnQgfSxcbiAgICBlbmQ6IHsgZGF0ZVRpbWU6IGVuZCB9LFxuICB9O1xuICBcbiAgLy8gQWRkIHJlbWluZGVycyBpZiBwcm92aWRlZFxuICBpZiAocmVtaW5kZXJzICYmIEFycmF5LmlzQXJyYXkocmVtaW5kZXJzKSAmJiByZW1pbmRlcnMubGVuZ3RoID4gMCkge1xuICAgIGV2ZW50LnJlbWluZGVycyA9IHtcbiAgICAgIHVzZURlZmF1bHQ6IGZhbHNlLFxuICAgICAgb3ZlcnJpZGVzOiByZW1pbmRlcnMubWFwKG1pbnV0ZXMgPT4gKHtcbiAgICAgICAgbWV0aG9kOiAncG9wdXAnLFxuICAgICAgICBtaW51dGVzOiBtaW51dGVzXG4gICAgICB9KSlcbiAgICB9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxlbmRhci5ldmVudHMuaW5zZXJ0KHtcbiAgICAgIGNhbGVuZGFySWQ6ICdwcmltYXJ5JyxcbiAgICAgIHJlc291cmNlOiBldmVudCxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGV2ZW50OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBhIGNhbGVuZGFyIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50SWQgLSBJRCBvZiB0aGUgZXZlbnQgdG8gZGVsZXRlIFxuICogQHBhcmFtIHtzdHJpbmd9IGNhbGVuZGFySWQgLSBDYWxlbmRhciBJRCAoZGVmYXVsdHMgdG8gJ3ByaW1hcnknKVxuICogQHJldHVybnMge09iamVjdH0gLSBEZWxldGVkIGV2ZW50IHN1bW1hcnlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ2FsZW5kYXJFdmVudCh0b2tlbnMsIGV2ZW50SWQsIGNhbGVuZGFySWQgPSAncHJpbWFyeScpIHtcbiAgLy8gVmFsaWRhdGUgaW5wdXRzXG4gIGlmICghdG9rZW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPQXV0aCB0b2tlbnMgYXJlIHJlcXVpcmVkJyk7XG4gIH1cbiAgXG4gIGlmICghZXZlbnRJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgSUQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBcbiAgY29uc3Qgb2F1dGgyQ2xpZW50ID0gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucyk7XG4gIGNvbnN0IGNhbGVuZGFyID0gZ29vZ2xlLmNhbGVuZGFyKHsgdmVyc2lvbjogJ3YzJywgYXV0aDogb2F1dGgyQ2xpZW50IH0pO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBGaXJzdCBnZXQgdGhlIGV2ZW50IHRvIHJldHVybiBpdHMgc3VtbWFyeSBhZnRlciBkZWxldGlvblxuICAgIGxldCBldmVudFN1bW1hcnkgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGF3YWl0IGNhbGVuZGFyLmV2ZW50cy5nZXQoe1xuICAgICAgICBjYWxlbmRhcklkOiBjYWxlbmRhcklkLFxuICAgICAgICBldmVudElkOiBldmVudElkLFxuICAgICAgfSk7XG4gICAgICBldmVudFN1bW1hcnkgPSBldmVudC5kYXRhLnN1bW1hcnk7XG4gICAgfSBjYXRjaCAoZ2V0RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHJldHJpZXZlIGV2ZW50IGRldGFpbHMgYmVmb3JlIGRlbGV0aW9uOiAke2dldEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIGF3YWl0IGNhbGVuZGFyLmV2ZW50cy5kZWxldGUoe1xuICAgICAgY2FsZW5kYXJJZDogY2FsZW5kYXJJZCxcbiAgICAgIGV2ZW50SWQ6IGV2ZW50SWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgc3VtbWFyeTogZXZlbnRTdW1tYXJ5LCBldmVudElkOiBldmVudElkIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgZXZlbnQgJHtldmVudElkfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UsIGV2ZW50SWQ6IGV2ZW50SWQgfTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIGNhbGVuZGFyIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50SWQgLSBJRCBvZiB0aGUgZXZlbnQgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcyAtIE9iamVjdCBjb250YWluaW5nIGZpZWxkcyB0byB1cGRhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gVXBkYXRlZCBldmVudCBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUNhbGVuZGFyRXZlbnQodG9rZW5zLCBldmVudElkLCB1cGRhdGVzKSB7XG4gIGNvbnN0IG9hdXRoMkNsaWVudCA9IGNyZWF0ZU9BdXRoMkNsaWVudCh0b2tlbnMpO1xuICBjb25zdCBjYWxlbmRhciA9IGdvb2dsZS5jYWxlbmRhcih7IHZlcnNpb246ICd2MycsIGF1dGg6IG9hdXRoMkNsaWVudCB9KTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gRmlyc3QgZ2V0IHRoZSBjdXJyZW50IGV2ZW50XG4gICAgY29uc3QgY3VycmVudEV2ZW50ID0gYXdhaXQgY2FsZW5kYXIuZXZlbnRzLmdldCh7XG4gICAgICBjYWxlbmRhcklkOiAncHJpbWFyeScsXG4gICAgICBldmVudElkOiBldmVudElkLFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFByZXBhcmUgdGhlIHVwZGF0ZSBwYXlsb2FkXG4gICAgY29uc3QgdXBkYXRlZEV2ZW50ID0geyAuLi5jdXJyZW50RXZlbnQuZGF0YSB9O1xuICAgIFxuICAgIGlmICh1cGRhdGVzLnN1bW1hcnkpIHVwZGF0ZWRFdmVudC5zdW1tYXJ5ID0gdXBkYXRlcy5zdW1tYXJ5O1xuICAgIGlmICh1cGRhdGVzLmRlc2NyaXB0aW9uKSB1cGRhdGVkRXZlbnQuZGVzY3JpcHRpb24gPSB1cGRhdGVzLmRlc2NyaXB0aW9uO1xuICAgIGlmICh1cGRhdGVzLmxvY2F0aW9uKSB1cGRhdGVkRXZlbnQubG9jYXRpb24gPSB1cGRhdGVzLmxvY2F0aW9uO1xuICAgIFxuICAgIGlmICh1cGRhdGVzLnN0YXJ0KSB7XG4gICAgICB1cGRhdGVkRXZlbnQuc3RhcnQgPSB7XG4gICAgICAgIGRhdGVUaW1lOiB1cGRhdGVzLnN0YXJ0LFxuICAgICAgICB0aW1lWm9uZTogY3VycmVudEV2ZW50LmRhdGEuc3RhcnQudGltZVpvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGlmICh1cGRhdGVzLmVuZCkge1xuICAgICAgdXBkYXRlZEV2ZW50LmVuZCA9IHtcbiAgICAgICAgZGF0ZVRpbWU6IHVwZGF0ZXMuZW5kLFxuICAgICAgICB0aW1lWm9uZTogY3VycmVudEV2ZW50LmRhdGEuZW5kLnRpbWVab25lXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdGhlIGV2ZW50XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2FsZW5kYXIuZXZlbnRzLnVwZGF0ZSh7XG4gICAgICBjYWxlbmRhcklkOiAncHJpbWFyeScsXG4gICAgICBldmVudElkOiBldmVudElkLFxuICAgICAgcmVzb3VyY2U6IHVwZGF0ZWRFdmVudCxcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcmVzLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZXZlbnQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVPQXV0aDJDbGllbnQsXG4gIGdldENhbGVuZGFyRXZlbnRzLFxuICBhZGRDYWxlbmRhckV2ZW50LFxuICBkZWxldGVDYWxlbmRhckV2ZW50LFxuICB1cGRhdGVDYWxlbmRhckV2ZW50XG59O1xuIl0sIm5hbWVzIjpbImdvb2dsZSIsInJlcXVpcmUiLCJPQXV0aDJDbGllbnQiLCJjcmVhdGVPQXV0aDJDbGllbnQiLCJ0b2tlbnMiLCJjcmVkZW50aWFscyIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRfaWQiLCJyZWRpcmVjdF91cmlzIiwid2ViIiwib2F1dGgyQ2xpZW50IiwiYWNjZXNzX3Rva2VuIiwic2V0Q3JlZGVudGlhbHMiLCJyZWZyZXNoX3Rva2VuIiwidG9rZW5fdHlwZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwiZ2V0Q2FsZW5kYXJFdmVudHMiLCJzdGFydF9kYXRlIiwiZW5kX2RhdGUiLCJjYWxlbmRhciIsInZlcnNpb24iLCJhdXRoIiwicmVzIiwiZXZlbnRzIiwibGlzdCIsImNhbGVuZGFySWQiLCJ0aW1lTWluIiwidG9JU09TdHJpbmciLCJ0aW1lTWF4Iiwic2luZ2xlRXZlbnRzIiwib3JkZXJCeSIsImRhdGEiLCJpdGVtcyIsImFkZENhbGVuZGFyRXZlbnQiLCJzdW1tYXJ5Iiwic3RhcnQiLCJlbmQiLCJkZXNjcmlwdGlvbiIsImxvY2F0aW9uIiwicmVtaW5kZXJzIiwiZXZlbnQiLCJkYXRlVGltZSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInVzZURlZmF1bHQiLCJvdmVycmlkZXMiLCJtYXAiLCJtaW51dGVzIiwibWV0aG9kIiwiaW5zZXJ0IiwicmVzb3VyY2UiLCJkZWxldGVDYWxlbmRhckV2ZW50IiwiZXZlbnRJZCIsImV2ZW50U3VtbWFyeSIsImdldCIsImdldEVycm9yIiwid2FybiIsIm1lc3NhZ2UiLCJkZWxldGUiLCJzdWNjZXNzIiwidXBkYXRlQ2FsZW5kYXJFdmVudCIsInVwZGF0ZXMiLCJjdXJyZW50RXZlbnQiLCJ1cGRhdGVkRXZlbnQiLCJ0aW1lWm9uZSIsInVwZGF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./googleCalendar.js\n");

/***/ }),

/***/ "(api)/./lib/chatbot.js":
/*!************************!*\
  !*** ./lib/chatbot.js ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ chat),\n/* harmony export */   getConversationsByUserId: () => (/* reexport safe */ _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getConversationsByUserId),\n/* harmony export */   listTodaysEvents: () => (/* reexport safe */ _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__.listTodaysEvents),\n/* harmony export */   suggestEventTime: () => (/* reexport safe */ _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__.suggestEventTime)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai */ \"openai\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-cache */ \"node-cache\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dotenv/config */ \"dotenv/config\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dotenv_config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _data_prompts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/prompts.js */ \"(api)/./lib/data/prompts.js\");\n/* harmony import */ var _tools_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools/schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\n/* harmony import */ var _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tools/eventHelpers.js */ \"(api)/./lib/tools/eventHelpers.js\");\n/* harmony import */ var _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tools/toolIndex.js */ \"(api)/./lib/tools/toolIndex.js\");\n/* harmony import */ var _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./postgresClient.js */ \"(api)/./lib/postgresClient.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([openai__WEBPACK_IMPORTED_MODULE_0__, luxon__WEBPACK_IMPORTED_MODULE_1__, _tools_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__, _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__]);\n([openai__WEBPACK_IMPORTED_MODULE_0__, luxon__WEBPACK_IMPORTED_MODULE_1__, _tools_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__, _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// lib/chatbot.js\n// --- IMPORTS ---\n\n\n\n\n// Local Modules\n// Import system prompt\n\n\n\n\n\n// Weather client function (if used)\n// import { getWeatherData } from './weatherClient.js'; // Example path\n// Google APIs library (needed for direct calls in tool functions like delete/update)\n// **FIX:** Use import instead of require for consistency if possible (depends on project setup)\n// If using ES modules: import { google } from 'googleapis';\n// If require is necessary:\nconst { google } = __webpack_require__(/*! googleapis */ \"googleapis\"); // Keep require if necessary for googleapis\n// --- Database Initialization ---\n// (Keep the getDatabaseInitPromise function as is)\nlet dbInitPromise = null;\n// Initialize OpenAI client\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    apiKey: process.env.OPENAI_API_KEY\n});\n// --- Helper Functions (Formatting & Time) ---\nfunction formatEventTime(eventTime) {\n    try {\n        const dt = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(eventTime);\n        if (dt.isValid) {\n            return dt.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATETIME_FULL);\n        }\n        const dateOnly = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(eventTime, {\n            zone: \"utc\"\n        });\n        if (dateOnly.isValid) {\n            return dateOnly.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATE_FULL) + \" (All day)\";\n        }\n        return eventTime;\n    } catch (e) {\n        console.warn(\"Error formatting event time:\", eventTime, e);\n        return String(eventTime); // Ensure returns string\n    }\n}\nfunction formatCalendarEvents(events) {\n    if (!events) return \"No events found or an error occurred.\";\n    if (!Array.isArray(events)) return \"An error occurred processing events.\";\n    if (events.length === 0) return \"No events found for the specified time period.\";\n    return events.map((event)=>{\n        try {\n            const start = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n            const end = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n            if (!start.isValid || !end.isValid) return `❓ Invalid date found for event: ${event.summary || event.id}`;\n            const isAllDay = !event.start?.dateTime;\n            // Include the event ID in the formatted output (hidden with a zero-width space for reference)\n            let formattedEvent = `📅 ${event.summary || \"(No Title)\"} [ID:​${event.id}]\\n`;\n            formattedEvent += `   📆 ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATE_FULL)}\\n`;\n            if (!isAllDay) {\n                formattedEvent += `   🕒 ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.TIME_SIMPLE)} - ${end.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.TIME_SIMPLE)}\\n`;\n            } else {\n                formattedEvent += `   🕒 All Day\\n`;\n            }\n            if (event.description) formattedEvent += `   📝 ${event.description}\\n`;\n            if (event.location) formattedEvent += `   📍 ${event.location}\\n`;\n            if (event.reminders?.useDefault === false && Array.isArray(event.reminders.overrides)) {\n                formattedEvent += `   🔔 Reminders: ${event.reminders.overrides.map((r)=>`${r.minutes} min`).join(\", \")}\\n`;\n            }\n            return formattedEvent.trim(); // Trim each event string\n        } catch (mapError) {\n            console.error(\"Error mapping event:\", event, mapError);\n            return `❓ Error processing event: ${event.summary || event.id}`;\n        }\n    }).join(\"\\n\\n\"); // Add space between events\n}\n// --- Formatting Tool Responses for the LLM ---\nfunction formatToolResponse(functionName, result) {\n    try {\n        // Explicitly handle null/undefined results first\n        if (result == null) {\n            console.warn(`Tool ${functionName} returned null or undefined.`);\n            return `Tool ${functionName} did not return a result. (Status: FAILED)`;\n        }\n        // Handle known error shapes returned by tool functions\n        if (typeof result === \"string\" && result.toLowerCase().startsWith(\"error:\")) return `${result} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.error) return `Error executing ${functionName}: ${result.error} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.success === false) return `Tool ${functionName} failed: ${result.message || \"No details.\"} (Status: FAILED)`;\n        // --- Format successful results ---\n        switch(functionName){\n            case \"saveUserPreference\":\n                return result.success ? `✅ Pref saved: ${result.message} (Status: SUCCESS)` : `❌ Pref fail: ${result.message} (Status: FAILED)`;\n            case \"addCalendarEvents\":\n                if (!Array.isArray(result)) return \"Error: Invalid response format from addCalendarEvents. (Status: FAILED)\";\n                if (result.length === 0) return \"No events were processed. (Status: NEUTRAL)\";\n                return result.map((item)=>{\n                    if (!item) return \"❓ Invalid item in result array. (Status: FAILED)\";\n                    if (item.error) {\n                        const summary = item.summary || \"?\";\n                        if (item.conflict) {\n                            // Include suggestions if available\n                            const suggestionText = item.suggestions && item.suggestions.length > 0 ? ` Suggested slots: ${item.suggestions.map((s)=>`${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(s.start).toFormat(\"h:mma\")} - ${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(s.end).toFormat(\"h:mma\")}`).join(\", \")}` : \"\";\n                            return `⚠️ Conflict detected for event \"${summary}\".${suggestionText} (Status: CONFLICT)`;\n                        } else {\n                            return `❌ Failed to add event \"${summary}\": ${item.error} (Status: FAILED)`;\n                        }\n                    } else if (item.id && item.summary && (item.start?.dateTime || item.start?.date)) {\n                        try {\n                            const startStr = formatEventTime(item.start.dateTime || item.start.date); // Use existing helper\n                            return `✅ Event added: \"${item.summary}\" starting ${startStr}. (ID: ${item.id}) (Status: SUCCESS)`;\n                        } catch (e) {\n                            console.error(\"Error formatting success message for added event:\", item, e);\n                            return `✅ Event added: \"${item.summary}\" (details unavailable). (ID: ${item.id}) (Status: SUCCESS)`;\n                        }\n                    } else {\n                        console.warn(\"Unexpected item shape in addCalendarEvents result:\", item);\n                        return `❓ Unknown outcome for an event attempt. (Status: UNKNOWN)`;\n                    }\n                }).join(\"\\n\");\n            case \"getCalendarEvents\":\n                if (typeof result === \"string\") return `🗓️ Events: ${result} (Status: ${result.toLowerCase().startsWith(\"error\") ? \"FAILED\" : \"SUCCESS\"})`;\n                if (!Array.isArray(result)) return \"Error: Invalid getCalendarEvents response. (Status: FAILED)\";\n                return result.length === 0 ? \"\\uD83D\\uDDD3️ No events found. (Status: SUCCESS)\" : `🗓️ Found ${result.length} event(s):\\n\\n${formatCalendarEvents(result)} (Status: SUCCESS)`;\n            case \"deleteCalendarEvent\":\n                return result.success ? `🗑️ Event \"${result.summary || result.eventId}\" deleted. (Status: SUCCESS)` // Use eventId if summary wasn't fetched/returned\n                 : `❌ Failed to delete event ${result.eventId || \"?\"}: ${result.error || result.message || \"?\"} (Status: FAILED)`;\n            case \"updateCalendarEvent\":\n                // Check if result has an ID, indicating success from googleCalendar update function\n                if (result && result.id) {\n                    return `✏️ Event \"${result.summary || eventId}\" updated. (ID: ${result.id}) (Status: SUCCESS)`;\n                } else {\n                    // Handle potential error objects passed back\n                    const errorMsg = result?.error || result?.message || JSON.stringify(result);\n                    return `❌ Failed to update event: ${errorMsg} (Status: FAILED)`;\n                }\n            case \"findAvailableSlots\":\n                if (!Array.isArray(result)) return \"Error: Invalid findAvailableSlots response. (Status: FAILED)\";\n                if (result.length === 0) return `🕒 No available slots found matching criteria. (Status: SUCCESS)`;\n                // Format slots with success status\n                const formattedSlots = result.map((slot)=>`${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(slot.start).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATETIME_SHORT)} - ${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(slot.end).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.TIME_SIMPLE)}`).join(\"\\n\");\n                return `🕒 Found ${result.length} available slot(s):\\n\\n${formattedSlots}\\n\\n(Status: SUCCESS)`;\n            case \"getWeatherForecast\":\n                return `🌤️ Weather for ${result.location} on ${result.date}: ${result.forecast || \"N/A\"} (Status: ${result.forecast && !result.forecast.includes(\"unavailable\") ? \"SUCCESS\" : \"PARTIAL\"})`;\n            case \"deleteCalendarEventsByQuery\":\n                return result.success ? `🗑️ ${result.message} (Deleted Count: ${result.deletedCount}) (Status: SUCCESS)` : `❌ Failed bulk delete: ${result.message || result.error || \"?\"} (Status: FAILED)`;\n            default:\n                // Safely stringify other results with status indicators\n                if (typeof result === \"object\" && result !== null) {\n                    const status = result.success === true ? \"SUCCESS\" : result.success === false ? \"FAILED\" : \"UNKNOWN\";\n                    return `${JSON.stringify(result)} (Status: ${status})`;\n                } else {\n                    return `${String(result)} (Status: UNKNOWN)`;\n                }\n        }\n    } catch (formatError) {\n        console.error(`CRITICAL: Error *within* formatToolResponse for ${functionName}:`, formatError, \"Raw result:\", result);\n        // Return a guaranteed string error message\n        return `Internal Error: Failed to format the result for ${functionName}. (Status: ERROR)`;\n    }\n}\n// Helper function to process tool calls\nasync function processToolCalls(toolCalls, messages, conversationId, userId, accessToken) {\n    try {\n        console.log(`Processing ${toolCalls.length} tool calls`);\n        // Use Promise.allSettled for robustness\n        const toolPromises = toolCalls.map(async (toolCall)=>{\n            const toolCallId = toolCall.id;\n            const functionName = toolCall.function?.name;\n            let toolResponseContent = \"\";\n            try {\n                // 1. Basic Validation\n                if (!toolCallId || toolCall.type !== \"function\" || !functionName) {\n                    throw new Error(`Invalid tool call structure received: ${JSON.stringify(toolCall)}`);\n                }\n                if (!_tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__.toolFunctions[functionName]) {\n                    throw new Error(`Tool function \"${functionName}\" is not available.`);\n                }\n                // 2. Parse Arguments\n                let parsedArgs = {};\n                try {\n                    parsedArgs = JSON.parse(toolCall.function.arguments || \"{}\");\n                } catch (parseError) {\n                    throw new Error(`Invalid JSON arguments for ${functionName}. Args: ${toolCall.function.arguments}. Error: ${parseError.message}`);\n                }\n                // 3. Execute Tool Function\n                console.log(`Executing tool: ${functionName} (ID: ${toolCallId}) with args:`, parsedArgs);\n                const result = await _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__.toolFunctions[functionName](parsedArgs, userId, accessToken);\n                console.log(`Tool ${functionName} (ID: ${toolCallId}) raw result:`, result);\n                // 4. Format Result\n                toolResponseContent = formatToolResponse(functionName, result);\n                console.log(`Tool ${functionName} (ID: ${toolCallId}) formatted response:`, toolResponseContent);\n                // Add a success indicator to the tool response for context tracking\n                let successIndicator = \"\";\n                if (functionName === \"deleteCalendarEvent\" && result.success) {\n                    successIndicator = \"\\n\\n[✅ Event successfully deleted]\";\n                } else if (functionName === \"addCalendarEvent\" && result.id) {\n                    successIndicator = \"\\n\\n[✅ Event successfully added]\";\n                } else if (functionName === \"updateCalendarEvent\" && result.id) {\n                    successIndicator = \"\\n\\n[✅ Event successfully updated]\";\n                }\n                // Add success indicator to the response if applicable\n                return {\n                    status: \"fulfilled\",\n                    value: {\n                        role: \"tool\",\n                        content: toolResponseContent + successIndicator,\n                        tool_call_id: toolCallId\n                    }\n                };\n            } catch (error) {\n                console.error(`ERROR processing tool call ${toolCallId} (${functionName || \"?\"}):`, error);\n                toolResponseContent = `Error processing tool ${functionName || \"?\"}: ${error.message || error}`;\n                return {\n                    status: \"rejected\",\n                    reason: error,\n                    value: {\n                        role: \"tool\",\n                        content: toolResponseContent,\n                        tool_call_id: toolCallId\n                    }\n                };\n            }\n        });\n        const settledToolResults = await Promise.allSettled(toolPromises);\n        const toolResponses = settledToolResults.map((settledResult)=>{\n            if (settledResult.status === \"fulfilled\") {\n                return settledResult.value.value;\n            } else {\n                return settledResult.reason.value;\n            }\n        }).filter(Boolean);\n        // Add tool responses to history\n        messages.push(...toolResponses);\n        // Store tool responses in DB (best effort, loop through results)\n        if (conversationId) {\n            try {\n                // Use Promise.all to store all tool responses in parallel\n                await Promise.all(toolResponses.map((toolMsg)=>(0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversationId, \"tool\", toolMsg.content, {\n                        tool_call_id: toolMsg.tool_call_id\n                    }).catch((dbError)=>{\n                        console.error(`DB Error storing tool response ${toolMsg.tool_call_id}:`, dbError);\n                        // Don't throw, allow other messages to be stored\n                        return null;\n                    })));\n                console.log(`Stored ${toolResponses.length} tool responses in database`);\n            } catch (batchError) {\n                console.error(`Error in batch storing tool responses:`, batchError);\n            // Individual errors are already caught in the map function\n            // This catch is for errors outside the individual promises\n            }\n        }\n        return toolResponses;\n    } catch (error) {\n        console.error(\"FATAL Error in runConversation pipeline:\", error);\n        // Log history specifically for 400 errors to help debug sequence issues\n        if (error.status === 400) {\n            console.error(\"Message history at time of 400 error:\", JSON.stringify(messages, null, 2));\n        }\n        responseCallback?.({\n            type: \"error\",\n            content: `An error occurred: ${error.message || \"Check server logs.\"}`\n        });\n        throw error; // Re-throw\n    }\n}\nasync function runConversation(messages, userInput, conversationId = null, userId = \"default\", accessToken = null, responseCallback1 = null) {\n    console.log(`Running conversation ${conversationId} for user ${userId}. AccessToken: ${!!accessToken}`);\n    const model = \"gpt-4o\"; // Use a capable model for reasoning\n    const maxToolIterations = 5; // Limit sequential tool calls to prevent infinite loops\n    try {\n        let currentMessages = [\n            ...messages\n        ]; // Use a mutable copy for this turn\n        let iteration = 0;\n        let finalContent = null; // Stores the final text response for the user\n        // Helper to filter messages (Keep existing filterMessagesForAPI)\n        const filterMessagesForAPI = (msgs)=>{\n            // ... (keep existing implementation) ...\n            if (!msgs || !Array.isArray(msgs)) {\n                console.error(\"Invalid messages array passed to filter:\", msgs);\n                return []; // Return empty array to prevent further errors\n            }\n            // Create a copy to avoid modifying the original\n            const filteredMsgs = [\n                ...msgs\n            ];\n            // Track tool call IDs from assistant messages\n            const validToolCallIds = new Set();\n            // First pass: collect all valid tool call IDs from assistant messages\n            filteredMsgs.forEach((msg)=>{\n                if (msg.role === \"assistant\" && msg.tool_calls && Array.isArray(msg.tool_calls)) {\n                    msg.tool_calls.forEach((toolCall)=>{\n                        if (toolCall.id) {\n                            validToolCallIds.add(toolCall.id);\n                        }\n                    });\n                }\n            });\n            // Second pass: filter out invalid tool messages\n            const result = filteredMsgs.filter((msg, index)=>{\n                // Keep all non-tool messages\n                if (msg.role !== \"tool\") return true;\n                // For tool messages, check if they have a valid tool_call_id\n                if (!msg.tool_call_id) {\n                    console.warn(`Filtering TOOL message with missing tool_call_id at index ${index}`);\n                    return false;\n                }\n                // Check if this tool message has a corresponding tool call from an assistant\n                if (!validToolCallIds.has(msg.tool_call_id)) {\n                    console.warn(`Filtering TOOL message not correctly preceded by assistant tool_call. Index=${index}, ToolCallID=${msg.tool_call_id}`);\n                    return false;\n                }\n                // Also ensure content exists for tool messages\n                if (msg.content == null || msg.content === \"\") {\n                    console.warn(`Filtering TOOL message with missing/empty content. Index=${index}, ToolCallID=${msg.tool_call_id}`);\n                    return false;\n                }\n                return true;\n            });\n            // Final sanity check: Ensure alternating user/assistant/tool sequence where appropriate\n            // Remove consecutive messages of the same role (except 'tool' which follows 'assistant')\n            const finalFiltered = [];\n            for(let i = 0; i < result.length; i++){\n                const currentMsg = result[i];\n                const prevMsg = finalFiltered[finalFiltered.length - 1];\n                if (prevMsg && currentMsg.role === prevMsg.role && currentMsg.role !== \"tool\") {\n                    console.warn(`Filtering consecutive message of role ${currentMsg.role} at index ${i}`);\n                    continue; // Skip adding the consecutive message\n                }\n                // Ensure tool message follows an assistant message (loosely, filter handles specific ID matching)\n                // if (currentMsg.role === 'tool' && (!prevMsg || prevMsg.role !== 'assistant')) {\n                //     console.warn(`Filtering TOOL message not following an assistant message at index ${i}`);\n                //     continue; // Skip adding the out-of-place tool message\n                // }\n                finalFiltered.push(currentMsg);\n            }\n            console.log(`Filtered ${msgs.length - finalFiltered.length} invalid/malformed messages`);\n            return finalFiltered;\n        };\n        // --- Main Reasoning Loop ---\n        while(iteration < maxToolIterations){\n            iteration++;\n            console.log(`\\n--- Conversation Turn ${iteration}/${maxToolIterations} ---`);\n            const messagesForAPI = filterMessagesForAPI(currentMessages);\n            if (messagesForAPI.length === 0) {\n                console.error(\"Message history became empty during filtering.\");\n                throw new Error(\"Internal error: Cannot proceed with empty message history.\");\n            }\n            // ***** DEBUG LOG *****\n            console.log(`Making API call #${iteration} with model: ${model}`);\n            console.log(`Message History (Length: ${messagesForAPI.length}):`);\n            messagesForAPI.forEach((msg, index)=>{\n                console.log(`  [${index}] Role: ${msg.role}`);\n                if (msg.content) console.log(`      Content: ${String(msg.content).substring(0, 100)}...`); // Truncate, ensure string\n                if (msg.tool_calls) console.log(`      Tool Calls: ${JSON.stringify(msg.tool_calls.map((tc)=>tc.id + \":\" + tc.function?.name))}`);\n                if (msg.tool_call_id) console.log(`      Tool Call ID: ${msg.tool_call_id}`);\n            });\n            console.log(`--- End API Call #${iteration} History --- \\n`);\n            // ***** END DEBUG LOG *****\n            // --- Call OpenAI ---\n            const response = await openai.chat.completions.create({\n                model: model,\n                messages: messagesForAPI,\n                tools: _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__.tools,\n                tool_choice: \"auto\"\n            });\n            const responseMessage = response.choices[0].message;\n            // --- Add Assistant Message to History (Local & DB) ---\n            currentMessages.push(responseMessage);\n            if (conversationId) {\n                try {\n                    await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversationId, \"assistant\", responseMessage.content || null, {\n                        tool_calls: responseMessage.tool_calls || null\n                    } // Always pass an object, even if tool_calls is null\n                    );\n                } catch (dbError) {\n                    console.error(`DB Error storing assistant message (iteration ${iteration}):`, dbError);\n                // Continue even if DB store fails for this message\n                }\n            }\n            // --- Check for Tool Calls ---\n            const assistantToolCalls = responseMessage.tool_calls;\n            if (assistantToolCalls && assistantToolCalls.length > 0) {\n                console.log(`Assistant requested ${assistantToolCalls.length} tool call(s) in iteration ${iteration}:`, JSON.stringify(assistantToolCalls.map((tc)=>({\n                        id: tc.id,\n                        name: tc.function?.name\n                    }))));\n                // Inform client we're processing (if streaming)\n                responseCallback1?.({\n                    type: \"processing\",\n                    content: `Thinking (step ${iteration})...`\n                });\n                await new Promise((resolve)=>setTimeout(resolve, 200)); // Small delay for UI update\n                // --- Process the requested tools ---\n                // processToolCalls adds the tool responses to currentMessages and stores them in DB\n                const toolResponses = await processToolCalls(assistantToolCalls, currentMessages, conversationId, userId, accessToken);\n                // Check if any tool call failed critically, maybe stop early? (Optional enhancement)\n                const hasCriticalFailure = toolResponses.some((tr)=>tr.content?.includes(\"(Status: FAILED)\"));\n                if (hasCriticalFailure) {\n                    console.warn(`Critical tool failure detected in iteration ${iteration}. LLM will be informed.`);\n                // Let the loop continue, LLM should see the failure message\n                }\n            // --- Loop continues: Send tool results back to LLM ---\n            } else {\n                // --- No Tool Calls: This is the final response ---\n                console.log(`No tool calls requested in iteration ${iteration}. Final response generated.`);\n                finalContent = responseMessage.content ?? \"\"; // Use nullish coalescing for safety\n                break; // Exit the loop\n            }\n        } // End of while loop\n        // --- Handle loop exit ---\n        if (iteration >= maxToolIterations) {\n            console.warn(`Maximum tool iterations (${maxToolIterations}) reached. Returning last generated content or error.`);\n            // Attempt to return the last content generated, even if it wasn't intended as final\n            const lastAssistantMsg = currentMessages[currentMessages.length - 1];\n            if (lastAssistantMsg?.role === \"assistant\" && lastAssistantMsg.content) {\n                finalContent = lastAssistantMsg.content;\n            } else {\n                finalContent = \"I seem to be stuck in a loop trying to process that request. Could you try rephrasing it?\";\n                responseCallback1?.({\n                    type: \"error\",\n                    content: finalContent\n                });\n            }\n        }\n        if (finalContent === null) {\n            console.error(\"Loop finished without generating final content.\");\n            finalContent = \"Sorry, I wasn't able to generate a final response after processing your request.\";\n            responseCallback1?.({\n                type: \"error\",\n                content: finalContent\n            });\n        }\n        // --- Stream the FINAL response ---\n        if (responseCallback1 && finalContent) {\n            // Send the final content chunk by chunk if desired, or as one piece\n            // Simplified: Send as one piece after the loop\n            responseCallback1({\n                type: \"content\",\n                content: finalContent\n            });\n            await new Promise((resolve)=>setTimeout(resolve, 50)); // Short delay before end\n            responseCallback1({\n                type: \"end\"\n            });\n        } else if (!responseCallback1 && finalContent) {\n            // Non-streaming mode: return the final content\n            return finalContent;\n        } else if (!finalContent) {\n            // Ensure something is returned/sent even if content is empty/null\n            if (responseCallback1) {\n                responseCallback1({\n                    type: \"content\",\n                    content: \"\"\n                }); // Send empty content\n                responseCallback1({\n                    type: \"end\"\n                });\n            }\n            return \"\";\n        }\n        console.log(\"Final response content:\", finalContent);\n        // The function implicitly returns finalContent if not streaming, or handles streaming via callback\n        return finalContent; // Return for non-streaming case\n    } catch (error) {\n        console.error(\"FATAL Error in runConversation pipeline:\", error);\n        if (error.status === 400) {\n            console.error(\"Message history at time of 400 error:\", JSON.stringify(messages, null, 2)); // Log initial history state\n        }\n        // Ensure error is propagated to the client\n        const errorMessage = `An error occurred: ${error.message || \"Check server logs.\"}`;\n        responseCallback1?.({\n            type: \"error\",\n            content: errorMessage\n        });\n        // Throw or return error string based on expected caller behavior\n        // throw error; // Re-throwing might be better for chat() function to catch\n        return errorMessage; // Or return error string for non-streaming\n    }\n}\n// --- Main Chat Entry Point ---\nasync function chat(userInput, userId = \"default\", accessToken = null, streamCallback = null, startNewConversation = false) {\n    console.log(`Chat request: User=${userId}, Input=\"${userInput}\", StartNew=${startNewConversation}`); // Log the flag\n    if (!userId || userId === \"default\") {\n        streamCallback?.({\n            type: \"error\",\n            content: \"User ID missing.\"\n        });\n        return \"Error: User ID required.\";\n    }\n    if (!userInput?.trim()) {\n        streamCallback?.({\n            type: \"info\",\n            content: \"Enter a message.\"\n        });\n        return \"\";\n    }\n    // Send 'start' signal immediately for streaming\n    streamCallback?.({\n        type: \"start\"\n    });\n    try {\n        const tokens = accessToken ? {\n            access_token: accessToken\n        } : null;\n        let user;\n        let conversation;\n        let historyMessages = []; // Formatted history for OpenAI API\n        // --- Load User & Conversation History ---\n        if (!startNewConversation) {\n            try {\n                // **FIX:** Use the optimized query\n                user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getUserWithLatestConversation)(userId);\n                if (user?.Conversations?.length > 0) {\n                    conversation = user.Conversations[0];\n                    console.log(`Found active conversation ${conversation.conversation_id}`);\n                    if (conversation.ConversationMessages?.length > 0) {\n                        // Sort ASCENDING for API\n                        conversation.ConversationMessages.sort((a, b)=>a.sequence_number - b.sequence_number);\n                        // **CRITICAL FIX: Robust History Mapping**\n                        historyMessages = conversation.ConversationMessages.map((msg, index, allMsgs)=>{\n                            const messageObject = {\n                                role: msg.role\n                            };\n                            // Content: Mandatory unless assistant w/ tool calls\n                            if (msg.content != null) {\n                                messageObject.content = msg.content;\n                            } else if (msg.role === \"assistant\" && msg.tool_calls) {\n                                // Check if tool_calls field actually contains valid calls\n                                let validToolCallsExist = false;\n                                if (msg.tool_calls.tool_calls && Array.isArray(msg.tool_calls.tool_calls) && msg.tool_calls.tool_calls.length > 0) {\n                                    validToolCallsExist = msg.tool_calls.tool_calls.some((tc)=>tc.id && tc.function?.name);\n                                } else if (Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {\n                                    validToolCallsExist = msg.tool_calls.some((tc)=>tc.id && tc.function?.name);\n                                }\n                                if (validToolCallsExist) {\n                                    messageObject.content = null; // API expects null/\"\" if only tool_calls\n                                } else {\n                                    messageObject.content = \"\"; // Treat as empty content if tool_calls invalid/empty\n                                }\n                            } else {\n                                messageObject.content = \"\"; // Default empty string\n                            }\n                            // Tool Calls (Assistant): Extract the array\n                            if (msg.role === \"assistant\" && msg.tool_calls) {\n                                let toolCallsArray = null;\n                                // Case 1: Stored as { tool_calls: [...] }\n                                if (msg.tool_calls.tool_calls && Array.isArray(msg.tool_calls.tool_calls)) {\n                                    toolCallsArray = msg.tool_calls.tool_calls;\n                                // Case 2: Stored as [...] (fallback)\n                                } else if (Array.isArray(msg.tool_calls)) {\n                                    toolCallsArray = msg.tool_calls;\n                                }\n                                // Add ONLY if valid and non-empty\n                                if (toolCallsArray && toolCallsArray.length > 0) {\n                                    const validToolCalls = toolCallsArray.filter((tc)=>tc.id && tc.type === \"function\" && tc.function?.name);\n                                    if (validToolCalls.length > 0) {\n                                        messageObject.tool_calls = validToolCalls;\n                                        // Re-ensure content is null if ONLY tool calls\n                                        if (messageObject.content === \"\" && validToolCalls.length === toolCallsArray.length) {\n                                            messageObject.content = null;\n                                        }\n                                    } else {\n                                        console.warn(`DB message ${msg.message_id} had tool_calls object but no valid calls.`);\n                                    // Don't add empty/invalid tool_calls array to API message\n                                    }\n                                }\n                            }\n                            // Tool Call ID (Tool): Extract the ID string\n                            if (msg.role === \"tool\") {\n                                let toolId = null;\n                                // Case 1: Stored as { tool_call_id: \"...\" }\n                                if (typeof msg.tool_call_id === \"object\" && msg.tool_call_id !== null && msg.tool_call_id.tool_call_id) {\n                                    toolId = msg.tool_call_id.tool_call_id;\n                                // Case 2: Stored as \"...\" (fallback)\n                                } else if (typeof msg.tool_call_id === \"string\") {\n                                    toolId = msg.tool_call_id;\n                                }\n                                // Tool message MUST have ID and content to be valid for API\n                                if (toolId && messageObject.content != null) {\n                                    messageObject.tool_call_id = toolId;\n                                } else {\n                                    console.warn(`Filtering invalid TOOL message (missing ID or content): DB_ID=${msg.message_id}`);\n                                    return null; // Filter out invalid tool message\n                                }\n                            }\n                            // API Validation Check: tool role must follow assistant role with tool_calls\n                            // **REMOVED STRICT PRECEDING CHECK** - Relying on filterMessagesForAPI inside runConversation\n                            // if (messageObject.role === 'tool') {\n                            //     const prevMappedMessage = index > 0 ? historyMessages[index - 1] : null; // Check the *mapped* previous message\n                            //     if (!prevMappedMessage || prevMappedMessage.role !== 'assistant' || !prevMappedMessage.tool_calls || !prevMappedMessage.tool_calls.some(tc => tc.id === messageObject.tool_call_id)) {\n                            //          console.warn(`Filtering TOOL message not correctly preceded by assistant tool_call. DB_ID=${msg.message_id}, ToolCallID=${messageObject.tool_call_id}`);\n                            //          return null; // Filter out orphaned/mismatched tool message\n                            //     }\n                            // }\n                            // Filter out assistant messages that end up empty (no content, no valid tool calls)\n                            if (messageObject.role === \"assistant\" && messageObject.content == null && !messageObject.tool_calls) {\n                                console.warn(`Filtering empty ASSISTANT message. DB_ID=${msg.message_id}`);\n                                return null;\n                            }\n                            return messageObject;\n                        }).filter(Boolean); // Remove nulls from filtering\n                        console.log(`Loaded and mapped ${historyMessages.length} valid messages from history.`);\n                    // DEBUG: Log the final history being sent, ONLY FOR DEBUGGING SENSITIVE DATA\n                    // console.log(\"Final history for API:\", JSON.stringify(historyMessages, null, 2));\n                    } else {\n                        console.log(`Conversation ${conversation.conversation_id} has no messages.`);\n                    }\n                } else {\n                    console.log(`No existing user/conversation found for ${userId}. Creating.`);\n                    if (!user) {\n                        const isEmail = userId.includes(\"@\");\n                        const email = isEmail ? userId : `${userId}@example.com`;\n                        const provider = isEmail ? \"email\" : \"system\"; // Adjust as needed\n                        user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getOrCreateUser)(email, provider, userId, userId);\n                    }\n                }\n            } catch (error) {\n                console.error(\"CRITICAL: Error loading user/history:\", error);\n                try {\n                    const isEmail = userId.includes(\"@\");\n                    const email = isEmail ? userId : `${userId}@example.com`;\n                    user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getOrCreateUser)(email, isEmail ? \"email\" : \"system\", userId, userId);\n                } catch (userError) {\n                    console.error(\"CRITICAL: Failed user recovery:\", userError);\n                    streamCallback?.({\n                        type: \"error\",\n                        content: \"Failed to load user profile.\"\n                    });\n                    return \"Error: Could not load user profile.\";\n                }\n                conversation = null;\n                historyMessages = []; // Reset state\n            }\n        } else {\n            console.log(\"Starting a new conversation as requested.\");\n            // Ensure user object is loaded, even if history loading was skipped\n            if (!user) {\n                try {\n                    const isEmail = userId.includes(\"@\");\n                    const email = isEmail ? userId : `${userId}@example.com`;\n                    user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getOrCreateUser)(email, isEmail ? \"email\" : \"system\", userId, userId);\n                } catch (userError) {\n                    console.error(\"CRITICAL: Failed user creation/retrieval when starting new conversation:\", userError);\n                    streamCallback?.({\n                        type: \"error\",\n                        content: \"Failed to load user profile for new chat.\"\n                    });\n                    return \"Error: Could not load user profile.\";\n                }\n            }\n            // Explicitly clear conversation and history\n            conversation = null;\n            historyMessages = [];\n        }\n        // --- Create Conversation if needed & Add System Prompt ---\n        if (!conversation) {\n            try {\n                conversation = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.createConversation)(user.user_id);\n                console.log(`Created new conversation ${conversation.conversation_id}. Preparing system prompt.`);\n                // Prepare system prompt (will be added later after checking for prefs)\n                let systemPromptContent = (0,_data_prompts_js__WEBPACK_IMPORTED_MODULE_4__.getAthenaSystemPrompt)();\n                // Store the base system prompt in DB first\n                await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversation.conversation_id, \"system\", systemPromptContent);\n                // Check for user preferences immediately after getting the base prompt\n                if (user.UserPreference?.preferences_data && Object.keys(user.UserPreference.preferences_data).length > 0) {\n                    try {\n                        const prefsData = user.UserPreference.preferences_data;\n                        let prefsString = \"\\n\\nUser Preferences Context (Consider when relevant):\\n\";\n                        prefsString += JSON.stringify(prefsData, null, 2);\n                        systemPromptContent += prefsString; // Append preferences to the main prompt\n                        console.log(\"Appended user preferences context to system prompt.\");\n                    } catch (prefsError) {\n                        console.error(\"Error adding preferences context:\", prefsError);\n                    }\n                }\n                // Add the potentially combined system prompt to the START of the local history array\n                historyMessages.unshift({\n                    role: \"system\",\n                    content: systemPromptContent\n                });\n            } catch (createError) {\n                console.error(\"CRITICAL: Failed to create conversation:\", createError);\n                streamCallback?.({\n                    type: \"error\",\n                    content: \"Failed to start chat session.\"\n                });\n                return \"Error: Could not start chat session.\";\n            }\n        }\n        // --- Prepare messages for API ---\n        const currentMessages = [\n            ...historyMessages\n        ]; // Start with history (incl sys prompt if new)\n        // Add current user input\n        const userMessageForAPI = {\n            role: \"user\",\n            content: userInput\n        };\n        currentMessages.push(userMessageForAPI);\n        // Store user message in DB reliably\n        try {\n            await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversation.conversation_id, \"user\", userInput);\n        } catch (dbError) {\n            console.error(\"Error storing user message:\", dbError);\n        // Non-critical? Log and continue.\n        }\n        // --- Run the conversation logic ---\n        const response = await runConversation(currentMessages, userInput, conversation.conversation_id, user.user_id, accessToken, streamCallback);\n        // If not streaming, return the response.\n        // If streaming, runConversation handles sending via callback, so we might just return void or true/false\n        if (!streamCallback) {\n            return response; // Final text response for non-streaming\n        } else {\n            // Streaming handled by runConversation's callbacks\n            // Ensure 'end' was sent if an error occurred within runConversation before completion\n            // (runConversation should ideally handle sending 'end' or 'error' in most cases)\n            return; // Indicate success or simply complete for streaming\n        }\n    } catch (error) {\n        console.error(\"Error in main chat function:\", error);\n        const errorMessage = `An unexpected error occurred: ${error.message || \"Please try again.\"}`;\n        // Ensure 'end' or 'error' is sent in case of top-level failure\n        streamCallback?.({\n            type: \"error\",\n            content: errorMessage\n        });\n        streamCallback?.({\n            type: \"end\"\n        }); // Send end signal after error in streaming mode\n        return errorMessage; // Return error string for non-streaming\n    }\n}\n// --- Exports ---\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWlCO1lBQUVsRSxNQUFNO1lBQVNTLFNBQVN3RDtRQUFhO1FBQ3hEQyxpQkFBaUI7WUFBRWxFLE1BQU07UUFBTSxJQUFJLGdEQUFnRDtRQUNuRixPQUFPaUUsY0FBYyx3Q0FBd0M7SUFDL0Q7QUFDRjtBQUdBLGtCQUFrQjtBQU1oQiIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi9jaGF0Ym90LmpzPzY3MDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2NoYXRib3QuanNcbi8vIC0tLSBJTVBPUlRTIC0tLVxuaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgTm9kZUNhY2hlIGZyb20gJ25vZGUtY2FjaGUnO1xuaW1wb3J0ICdkb3RlbnYvY29uZmlnJztcblxuLy8gTG9jYWwgTW9kdWxlc1xuLy8gSW1wb3J0IHN5c3RlbSBwcm9tcHRcbmltcG9ydCB7IGdldEF0aGVuYVN5c3RlbVByb21wdCB9IGZyb20gJy4vZGF0YS9wcm9tcHRzLmpzJztcbmltcG9ydCB7IGZpbmRBdmFpbGFibGVTbG90cyBhcyBmaW5kQXZhaWxhYmxlU2xvdHNVdGlsLCBmb3JtYXRBdmFpbGFibGVTbG90cyB9IGZyb20gJy4vdG9vbHMvc2NoZWR1bGluZ1V0aWxzLmpzJztcbmltcG9ydCB7IGxpc3RUb2RheXNFdmVudHMsIHN1Z2dlc3RFdmVudFRpbWUgfSBmcm9tICcuL3Rvb2xzL2V2ZW50SGVscGVycy5qcyc7XG5pbXBvcnQgeyB0b29scywgdG9vbEZ1bmN0aW9ucyB9IGZyb20gJy4vdG9vbHMvdG9vbEluZGV4LmpzJztcbmltcG9ydCB7XG4gIGdldE9yQ3JlYXRlVXNlcixcbiAgY3JlYXRlQ29udmVyc2F0aW9uLFxuICAvLyBnZXRDb252ZXJzYXRpb24sIC8vIExlc3MgbGlrZWx5IG5lZWRlZCBkaXJlY3RseSBpZiB1c2luZyBnZXRVc2VyV2l0aExhdGVzdENvbnZlcnNhdGlvblxuICAvLyBnZXRDb252ZXJzYXRpb25NZXNzYWdlcywgLy8gTGVzcyBsaWtlbHkgbmVlZGVkIGRpcmVjdGx5XG4gIENvbnZlcnNhdGlvbk1lc3NhZ2UsIC8vIE5lZWRlZCBmb3IgdHlwZSBoaW50cy9jaGVja3MgaWYgYW55XG4gIGFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbixcbiAgaW5pdGlhbGl6ZURhdGFiYXNlLFxuICBnZXRDb252ZXJzYXRpb25zQnlVc2VySWQsXG4gIGdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uLFxuICBVc2VyUHJlZmVyZW5jZSAvLyBJbXBvcnQgVXNlclByZWZlcmVuY2UgbW9kZWwgZm9yIHRvb2wgZnVuY3Rpb24gdXNhZ2Vcbn0gZnJvbSAnLi9wb3N0Z3Jlc0NsaWVudC5qcyc7XG5cbi8vIFdlYXRoZXIgY2xpZW50IGZ1bmN0aW9uIChpZiB1c2VkKVxuLy8gaW1wb3J0IHsgZ2V0V2VhdGhlckRhdGEgfSBmcm9tICcuL3dlYXRoZXJDbGllbnQuanMnOyAvLyBFeGFtcGxlIHBhdGhcblxuLy8gR29vZ2xlIEFQSXMgbGlicmFyeSAobmVlZGVkIGZvciBkaXJlY3QgY2FsbHMgaW4gdG9vbCBmdW5jdGlvbnMgbGlrZSBkZWxldGUvdXBkYXRlKVxuLy8gKipGSVg6KiogVXNlIGltcG9ydCBpbnN0ZWFkIG9mIHJlcXVpcmUgZm9yIGNvbnNpc3RlbmN5IGlmIHBvc3NpYmxlIChkZXBlbmRzIG9uIHByb2plY3Qgc2V0dXApXG4vLyBJZiB1c2luZyBFUyBtb2R1bGVzOiBpbXBvcnQgeyBnb29nbGUgfSBmcm9tICdnb29nbGVhcGlzJztcbi8vIElmIHJlcXVpcmUgaXMgbmVjZXNzYXJ5OlxuY29uc3QgeyBnb29nbGUgfSA9IHJlcXVpcmUoJ2dvb2dsZWFwaXMnKTsgLy8gS2VlcCByZXF1aXJlIGlmIG5lY2Vzc2FyeSBmb3IgZ29vZ2xlYXBpc1xuXG4vLyAtLS0gRGF0YWJhc2UgSW5pdGlhbGl6YXRpb24gLS0tXG4vLyAoS2VlcCB0aGUgZ2V0RGF0YWJhc2VJbml0UHJvbWlzZSBmdW5jdGlvbiBhcyBpcylcbmxldCBkYkluaXRQcm9taXNlID0gbnVsbDtcblxuLy8gSW5pdGlhbGl6ZSBPcGVuQUkgY2xpZW50XG5jb25zdCBvcGVuYWkgPSBuZXcgT3BlbkFJKHsgYXBpS2V5OiBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSB9KTtcblxuXG5cbi8vIC0tLSBIZWxwZXIgRnVuY3Rpb25zIChGb3JtYXR0aW5nICYgVGltZSkgLS0tXG5mdW5jdGlvbiBmb3JtYXRFdmVudFRpbWUoZXZlbnRUaW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZHQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50VGltZSk7XG4gICAgICAgIGlmIChkdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZHQudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfRlVMTCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZU9ubHkgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50VGltZSwgeyB6b25lOiAndXRjJyB9KTtcbiAgICAgICAgaWYgKGRhdGVPbmx5LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlT25seS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpICsgXCIgKEFsbCBkYXkpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50VGltZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZvcm1hdHRpbmcgZXZlbnQgdGltZTpcIiwgZXZlbnRUaW1lLCBlKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhldmVudFRpbWUpOyAvLyBFbnN1cmUgcmV0dXJucyBzdHJpbmdcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENhbGVuZGFyRXZlbnRzKGV2ZW50cykge1xuICAgIGlmICghZXZlbnRzKSByZXR1cm4gXCJObyBldmVudHMgZm91bmQgb3IgYW4gZXJyb3Igb2NjdXJyZWQuXCI7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHJldHVybiBcIkFuIGVycm9yIG9jY3VycmVkIHByb2Nlc3NpbmcgZXZlbnRzLlwiO1xuICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJObyBldmVudHMgZm91bmQgZm9yIHRoZSBzcGVjaWZpZWQgdGltZSBwZXJpb2QuXCI7XG5cbiAgICByZXR1cm4gZXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kPy5kYXRlVGltZSB8fCBldmVudC5lbmQ/LmRhdGUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydC5pc1ZhbGlkIHx8ICFlbmQuaXNWYWxpZCkgcmV0dXJuIGDinZMgSW52YWxpZCBkYXRlIGZvdW5kIGZvciBldmVudDogJHtldmVudC5zdW1tYXJ5IHx8IGV2ZW50LmlkfWA7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzQWxsRGF5ID0gIWV2ZW50LnN0YXJ0Py5kYXRlVGltZTtcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGV2ZW50IElEIGluIHRoZSBmb3JtYXR0ZWQgb3V0cHV0IChoaWRkZW4gd2l0aCBhIHplcm8td2lkdGggc3BhY2UgZm9yIHJlZmVyZW5jZSlcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZWRFdmVudCA9IGDwn5OFICR7ZXZlbnQuc3VtbWFyeSB8fCAnKE5vIFRpdGxlKSd9IFtJRDrigIske2V2ZW50LmlkfV1cXG5gO1xuICAgICAgICAgICAgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCfk4YgJHtzdGFydC50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpfVxcbmA7XG4gICAgICAgICAgICBpZiAoIWlzQWxsRGF5KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCflZIgJHtzdGFydC50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSl9IC0gJHtlbmQudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpfVxcbmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5WSIEFsbCBEYXlcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmRlc2NyaXB0aW9uKSBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+TnSAke2V2ZW50LmRlc2NyaXB0aW9ufVxcbmA7XG4gICAgICAgICAgICBpZiAoZXZlbnQubG9jYXRpb24pIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5ONICR7ZXZlbnQubG9jYXRpb259XFxuYDtcbiAgICAgICAgICAgIGlmIChldmVudC5yZW1pbmRlcnM/LnVzZURlZmF1bHQgPT09IGZhbHNlICYmIEFycmF5LmlzQXJyYXkoZXZlbnQucmVtaW5kZXJzLm92ZXJyaWRlcykpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+UlCBSZW1pbmRlcnM6ICR7ZXZlbnQucmVtaW5kZXJzLm92ZXJyaWRlcy5tYXAociA9PiBgJHtyLm1pbnV0ZXN9IG1pbmApLmpvaW4oJywgJyl9XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRFdmVudC50cmltKCk7IC8vIFRyaW0gZWFjaCBldmVudCBzdHJpbmdcbiAgICAgICAgfSBjYXRjaCAobWFwRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBtYXBwaW5nIGV2ZW50OlwiLCBldmVudCwgbWFwRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGDinZMgRXJyb3IgcHJvY2Vzc2luZyBldmVudDogJHtldmVudC5zdW1tYXJ5IHx8IGV2ZW50LmlkfWA7XG4gICAgICAgIH1cbiAgICB9KS5qb2luKCdcXG5cXG4nKTsgLy8gQWRkIHNwYWNlIGJldHdlZW4gZXZlbnRzXG59XG5cbi8vIC0tLSBGb3JtYXR0aW5nIFRvb2wgUmVzcG9uc2VzIGZvciB0aGUgTExNIC0tLVxuZnVuY3Rpb24gZm9ybWF0VG9vbFJlc3BvbnNlKGZ1bmN0aW9uTmFtZSwgcmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRXhwbGljaXRseSBoYW5kbGUgbnVsbC91bmRlZmluZWQgcmVzdWx0cyBmaXJzdFxuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVG9vbCAke2Z1bmN0aW9uTmFtZX0gcmV0dXJuZWQgbnVsbCBvciB1bmRlZmluZWQuYCk7XG4gICAgICAgICAgICByZXR1cm4gYFRvb2wgJHtmdW5jdGlvbk5hbWV9IGRpZCBub3QgcmV0dXJuIGEgcmVzdWx0LiAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBrbm93biBlcnJvciBzaGFwZXMgcmV0dXJuZWQgYnkgdG9vbCBmdW5jdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnICYmIHJlc3VsdC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Vycm9yOicpKVxuICAgICAgICAgICAgcmV0dXJuIGAke3Jlc3VsdH0gKFN0YXR1czogRkFJTEVEKWA7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQuZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGV4ZWN1dGluZyAke2Z1bmN0aW9uTmFtZX06ICR7cmVzdWx0LmVycm9yfSAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBgVG9vbCAke2Z1bmN0aW9uTmFtZX0gZmFpbGVkOiAke3Jlc3VsdC5tZXNzYWdlIHx8ICdObyBkZXRhaWxzLid9IChTdGF0dXM6IEZBSUxFRClgO1xuXG4gICAgICAgIC8vIC0tLSBGb3JtYXQgc3VjY2Vzc2Z1bCByZXN1bHRzIC0tLVxuICAgICAgICBzd2l0Y2ggKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnc2F2ZVVzZXJQcmVmZXJlbmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyBg4pyFIFByZWYgc2F2ZWQ6ICR7cmVzdWx0Lm1lc3NhZ2V9IChTdGF0dXM6IFNVQ0NFU1MpYCA6IGDinYwgUHJlZiBmYWlsOiAke3Jlc3VsdC5tZXNzYWdlfSAoU3RhdHVzOiBGQUlMRUQpYDtcblxuICAgICAgICAgICAgY2FzZSAnYWRkQ2FsZW5kYXJFdmVudHMnOlxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpKSByZXR1cm4gXCJFcnJvcjogSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBhZGRDYWxlbmRhckV2ZW50cy4gKFN0YXR1czogRkFJTEVEKVwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gXCJObyBldmVudHMgd2VyZSBwcm9jZXNzZWQuIChTdGF0dXM6IE5FVVRSQUwpXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuICfinZMgSW52YWxpZCBpdGVtIGluIHJlc3VsdCBhcnJheS4gKFN0YXR1czogRkFJTEVEKSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmVycm9yKSB7IC8vIEhhbmRsZSBleHBsaWNpdCBlcnJvcnMgZmlyc3QgKGNvbmZsaWN0LCB2YWxpZGF0aW9uLCBBUEkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gaXRlbS5zdW1tYXJ5IHx8ICc/JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbmZsaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSBzdWdnZXN0aW9ucyBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWdnZXN0aW9uVGV4dCA9IGl0ZW0uc3VnZ2VzdGlvbnMgJiYgaXRlbS5zdWdnZXN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCBTdWdnZXN0ZWQgc2xvdHM6ICR7aXRlbS5zdWdnZXN0aW9ucy5tYXAocyA9PiBgJHtEYXRlVGltZS5mcm9tSVNPKHMuc3RhcnQpLnRvRm9ybWF0KCdoOm1tYScpfSAtICR7RGF0ZVRpbWUuZnJvbUlTTyhzLmVuZCkudG9Gb3JtYXQoJ2g6bW1hJyl9YCkuam9pbignLCAnKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDimqDvuI8gQ29uZmxpY3QgZGV0ZWN0ZWQgZm9yIGV2ZW50IFwiJHtzdW1tYXJ5fVwiLiR7c3VnZ2VzdGlvblRleHR9IChTdGF0dXM6IENPTkZMSUNUKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBg4p2MIEZhaWxlZCB0byBhZGQgZXZlbnQgXCIke3N1bW1hcnl9XCI6ICR7aXRlbS5lcnJvcn0gKFN0YXR1czogRkFJTEVEKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pZCAmJiBpdGVtLnN1bW1hcnkgJiYgKGl0ZW0uc3RhcnQ/LmRhdGVUaW1lIHx8IGl0ZW0uc3RhcnQ/LmRhdGUpKSB7IC8vIEFzc3VtZSBzdWNjZXNzIGlmIGtleSBmaWVsZHMgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRTdHIgPSBmb3JtYXRFdmVudFRpbWUoaXRlbS5zdGFydC5kYXRlVGltZSB8fCBpdGVtLnN0YXJ0LmRhdGUpOyAvLyBVc2UgZXhpc3RpbmcgaGVscGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinIUgRXZlbnQgYWRkZWQ6IFwiJHtpdGVtLnN1bW1hcnl9XCIgc3RhcnRpbmcgJHtzdGFydFN0cn0uIChJRDogJHtpdGVtLmlkfSkgKFN0YXR1czogU1VDQ0VTUylgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmb3JtYXR0aW5nIHN1Y2Nlc3MgbWVzc2FnZSBmb3IgYWRkZWQgZXZlbnQ6XCIsIGl0ZW0sIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBg4pyFIEV2ZW50IGFkZGVkOiBcIiR7aXRlbS5zdW1tYXJ5fVwiIChkZXRhaWxzIHVuYXZhaWxhYmxlKS4gKElEOiAke2l0ZW0uaWR9KSAoU3RhdHVzOiBTVUNDRVNTKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIEZhbGxiYWNrIGZvciB1bmV4cGVjdGVkIHNoYXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBpdGVtIHNoYXBlIGluIGFkZENhbGVuZGFyRXZlbnRzIHJlc3VsdDpcIiwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKdkyBVbmtub3duIG91dGNvbWUgZm9yIGFuIGV2ZW50IGF0dGVtcHQuIChTdGF0dXM6IFVOS05PV04pYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgICBjYXNlICdnZXRDYWxlbmRhckV2ZW50cyc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYPCfl5PvuI8gRXZlbnRzOiAke3Jlc3VsdH0gKFN0YXR1czogJHtyZXN1bHQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdlcnJvcicpID8gJ0ZBSUxFRCcgOiAnU1VDQ0VTUyd9KWA7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBJbnZhbGlkIGdldENhbGVuZGFyRXZlbnRzIHJlc3BvbnNlLiAoU3RhdHVzOiBGQUlMRUQpXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBcIvCfl5PvuI8gTm8gZXZlbnRzIGZvdW5kLiAoU3RhdHVzOiBTVUNDRVNTKVwiXG4gICAgICAgICAgICAgICAgICAgIDogYPCfl5PvuI8gRm91bmQgJHtyZXN1bHQubGVuZ3RofSBldmVudChzKTpcXG5cXG4ke2Zvcm1hdENhbGVuZGFyRXZlbnRzKHJlc3VsdCl9IChTdGF0dXM6IFNVQ0NFU1MpYDtcblxuICAgICAgICAgICAgY2FzZSAnZGVsZXRlQ2FsZW5kYXJFdmVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgID8gYPCfl5HvuI8gRXZlbnQgXCIke3Jlc3VsdC5zdW1tYXJ5IHx8IHJlc3VsdC5ldmVudElkfVwiIGRlbGV0ZWQuIChTdGF0dXM6IFNVQ0NFU1MpYCAvLyBVc2UgZXZlbnRJZCBpZiBzdW1tYXJ5IHdhc24ndCBmZXRjaGVkL3JldHVybmVkXG4gICAgICAgICAgICAgICAgICAgIDogYOKdjCBGYWlsZWQgdG8gZGVsZXRlIGV2ZW50ICR7cmVzdWx0LmV2ZW50SWQgfHwgJz8nfTogJHtyZXN1bHQuZXJyb3IgfHwgcmVzdWx0Lm1lc3NhZ2UgfHwgJz8nfSAoU3RhdHVzOiBGQUlMRUQpYDtcblxuICAgICAgICAgICAgY2FzZSAndXBkYXRlQ2FsZW5kYXJFdmVudCc6XG4gICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHJlc3VsdCBoYXMgYW4gSUQsIGluZGljYXRpbmcgc3VjY2VzcyBmcm9tIGdvb2dsZUNhbGVuZGFyIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBg4pyP77iPIEV2ZW50IFwiJHtyZXN1bHQuc3VtbWFyeSB8fCBldmVudElkfVwiIHVwZGF0ZWQuIChJRDogJHtyZXN1bHQuaWR9KSAoU3RhdHVzOiBTVUNDRVNTKWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHBvdGVudGlhbCBlcnJvciBvYmplY3RzIHBhc3NlZCBiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gcmVzdWx0Py5lcnJvciB8fCByZXN1bHQ/Lm1lc3NhZ2UgfHwgSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinYwgRmFpbGVkIHRvIHVwZGF0ZSBldmVudDogJHtlcnJvck1zZ30gKFN0YXR1czogRkFJTEVEKWA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdmaW5kQXZhaWxhYmxlU2xvdHMnOlxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogSW52YWxpZCBmaW5kQXZhaWxhYmxlU2xvdHMgcmVzcG9uc2UuIChTdGF0dXM6IEZBSUxFRClcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDwn5WSIE5vIGF2YWlsYWJsZSBzbG90cyBmb3VuZCBtYXRjaGluZyBjcml0ZXJpYS4gKFN0YXR1czogU1VDQ0VTUylgO1xuICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBzbG90cyB3aXRoIHN1Y2Nlc3Mgc3RhdHVzXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkU2xvdHMgPSByZXN1bHQubWFwKHNsb3QgPT5cbiAgICAgICAgICAgICAgICAgICAgYCR7RGF0ZVRpbWUuZnJvbUlTTyhzbG90LnN0YXJ0KS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFVElNRV9TSE9SVCl9IC0gJHtEYXRlVGltZS5mcm9tSVNPKHNsb3QuZW5kKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSl9YFxuICAgICAgICAgICAgICAgICkuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGDwn5WSIEZvdW5kICR7cmVzdWx0Lmxlbmd0aH0gYXZhaWxhYmxlIHNsb3Qocyk6XFxuXFxuJHtmb3JtYXR0ZWRTbG90c31cXG5cXG4oU3RhdHVzOiBTVUNDRVNTKWA7XG5cbiAgICAgICAgICAgIGNhc2UgJ2dldFdlYXRoZXJGb3JlY2FzdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGDwn4yk77iPIFdlYXRoZXIgZm9yICR7cmVzdWx0LmxvY2F0aW9ufSBvbiAke3Jlc3VsdC5kYXRlfTogJHtyZXN1bHQuZm9yZWNhc3QgfHwgJ04vQSd9IChTdGF0dXM6ICR7cmVzdWx0LmZvcmVjYXN0ICYmICFyZXN1bHQuZm9yZWNhc3QuaW5jbHVkZXMoJ3VuYXZhaWxhYmxlJykgPyAnU1VDQ0VTUycgOiAnUEFSVElBTCd9KWA7XG5cbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZUNhbGVuZGFyRXZlbnRzQnlRdWVyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgID8gYPCfl5HvuI8gJHtyZXN1bHQubWVzc2FnZX0gKERlbGV0ZWQgQ291bnQ6ICR7cmVzdWx0LmRlbGV0ZWRDb3VudH0pIChTdGF0dXM6IFNVQ0NFU1MpYFxuICAgICAgICAgICAgICAgICAgICA6IGDinYwgRmFpbGVkIGJ1bGsgZGVsZXRlOiAke3Jlc3VsdC5tZXNzYWdlIHx8IHJlc3VsdC5lcnJvciB8fCAnPyd9IChTdGF0dXM6IEZBSUxFRClgO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFNhZmVseSBzdHJpbmdpZnkgb3RoZXIgcmVzdWx0cyB3aXRoIHN0YXR1cyBpbmRpY2F0b3JzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXN1bHQuc3VjY2VzcyA9PT0gdHJ1ZSA/ICdTVUNDRVNTJyA6IChyZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UgPyAnRkFJTEVEJyA6ICdVTktOT1dOJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfSAoU3RhdHVzOiAke3N0YXR1c30pYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7U3RyaW5nKHJlc3VsdCl9IChTdGF0dXM6IFVOS05PV04pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChmb3JtYXRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBDUklUSUNBTDogRXJyb3IgKndpdGhpbiogZm9ybWF0VG9vbFJlc3BvbnNlIGZvciAke2Z1bmN0aW9uTmFtZX06YCwgZm9ybWF0RXJyb3IsIFwiUmF3IHJlc3VsdDpcIiwgcmVzdWx0KTtcbiAgICAgICAgLy8gUmV0dXJuIGEgZ3VhcmFudGVlZCBzdHJpbmcgZXJyb3IgbWVzc2FnZVxuICAgICAgICByZXR1cm4gYEludGVybmFsIEVycm9yOiBGYWlsZWQgdG8gZm9ybWF0IHRoZSByZXN1bHQgZm9yICR7ZnVuY3Rpb25OYW1lfS4gKFN0YXR1czogRVJST1IpYDtcbiAgICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwcm9jZXNzIHRvb2wgY2FsbHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUb29sQ2FsbHModG9vbENhbGxzLCBtZXNzYWdlcywgY29udmVyc2F0aW9uSWQsIHVzZXJJZCwgYWNjZXNzVG9rZW4pIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyAke3Rvb2xDYWxscy5sZW5ndGh9IHRvb2wgY2FsbHNgKTtcbiAgICBcbiAgICAvLyBVc2UgUHJvbWlzZS5hbGxTZXR0bGVkIGZvciByb2J1c3RuZXNzXG4gICAgY29uc3QgdG9vbFByb21pc2VzID0gdG9vbENhbGxzLm1hcChhc3luYyAodG9vbENhbGwpID0+IHtcbiAgICAgICAgY29uc3QgdG9vbENhbGxJZCA9IHRvb2xDYWxsLmlkO1xuICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSB0b29sQ2FsbC5mdW5jdGlvbj8ubmFtZTtcbiAgICAgICAgbGV0IHRvb2xSZXNwb25zZUNvbnRlbnQgPSAnJztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gMS4gQmFzaWMgVmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCF0b29sQ2FsbElkIHx8IHRvb2xDYWxsLnR5cGUgIT09ICdmdW5jdGlvbicgfHwgIWZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGwgc3RydWN0dXJlIHJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHRvb2xDYWxsKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdG9vbEZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sIGZ1bmN0aW9uIFwiJHtmdW5jdGlvbk5hbWV9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMi4gUGFyc2UgQXJndW1lbnRzXG4gICAgICAgICAgICBsZXQgcGFyc2VkQXJncyA9IHt9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcmdzID0gSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgfHwgJ3t9Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04gYXJndW1lbnRzIGZvciAke2Z1bmN0aW9uTmFtZX0uIEFyZ3M6ICR7dG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzfS4gRXJyb3I6ICR7cGFyc2VFcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAzLiBFeGVjdXRlIFRvb2wgRnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeGVjdXRpbmcgdG9vbDogJHtmdW5jdGlvbk5hbWV9IChJRDogJHt0b29sQ2FsbElkfSkgd2l0aCBhcmdzOmAsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9vbEZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdKHBhcnNlZEFyZ3MsIHVzZXJJZCwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFRvb2wgJHtmdW5jdGlvbk5hbWV9IChJRDogJHt0b29sQ2FsbElkfSkgcmF3IHJlc3VsdDpgLCByZXN1bHQpO1xuXG4gICAgICAgICAgICAvLyA0LiBGb3JtYXQgUmVzdWx0XG4gICAgICAgICAgICB0b29sUmVzcG9uc2VDb250ZW50ID0gZm9ybWF0VG9vbFJlc3BvbnNlKGZ1bmN0aW9uTmFtZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUb29sICR7ZnVuY3Rpb25OYW1lfSAoSUQ6ICR7dG9vbENhbGxJZH0pIGZvcm1hdHRlZCByZXNwb25zZTpgLCB0b29sUmVzcG9uc2VDb250ZW50KTtcblxuICAgICAgICAgICAgLy8gQWRkIGEgc3VjY2VzcyBpbmRpY2F0b3IgdG8gdGhlIHRvb2wgcmVzcG9uc2UgZm9yIGNvbnRleHQgdHJhY2tpbmdcbiAgICAgICAgICAgIGxldCBzdWNjZXNzSW5kaWNhdG9yID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT09ICdkZWxldGVDYWxlbmRhckV2ZW50JyAmJiByZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NJbmRpY2F0b3IgPSBcIlxcblxcblvinIUgRXZlbnQgc3VjY2Vzc2Z1bGx5IGRlbGV0ZWRdXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2FkZENhbGVuZGFyRXZlbnQnICYmIHJlc3VsdC5pZCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NJbmRpY2F0b3IgPSBcIlxcblxcblvinIUgRXZlbnQgc3VjY2Vzc2Z1bGx5IGFkZGVkXVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUgPT09ICd1cGRhdGVDYWxlbmRhckV2ZW50JyAmJiByZXN1bHQuaWQpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzSW5kaWNhdG9yID0gXCJcXG5cXG5b4pyFIEV2ZW50IHN1Y2Nlc3NmdWxseSB1cGRhdGVkXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgc3VjY2VzcyBpbmRpY2F0b3IgdG8gdGhlIHJlc3BvbnNlIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZnVsZmlsbGVkJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyByb2xlOiBcInRvb2xcIiwgY29udGVudDogdG9vbFJlc3BvbnNlQ29udGVudCArIHN1Y2Nlc3NJbmRpY2F0b3IsIHRvb2xfY2FsbF9pZDogdG9vbENhbGxJZCB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFUlJPUiBwcm9jZXNzaW5nIHRvb2wgY2FsbCAke3Rvb2xDYWxsSWR9ICgke2Z1bmN0aW9uTmFtZSB8fCAnPyd9KTpgLCBlcnJvcik7XG4gICAgICAgICAgICB0b29sUmVzcG9uc2VDb250ZW50ID0gYEVycm9yIHByb2Nlc3NpbmcgdG9vbCAke2Z1bmN0aW9uTmFtZSB8fCAnPyd9OiAke2Vycm9yLm1lc3NhZ2UgfHwgZXJyb3J9YDtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdyZWplY3RlZCcsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBlcnJvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyByb2xlOiBcInRvb2xcIiwgY29udGVudDogdG9vbFJlc3BvbnNlQ29udGVudCwgdG9vbF9jYWxsX2lkOiB0b29sQ2FsbElkIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHNldHRsZWRUb29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZCh0b29sUHJvbWlzZXMpO1xuICAgIFxuICAgIGNvbnN0IHRvb2xSZXNwb25zZXMgPSBzZXR0bGVkVG9vbFJlc3VsdHMubWFwKHNldHRsZWRSZXN1bHQgPT4ge1xuICAgICAgICBpZiAoc2V0dGxlZFJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGxlZFJlc3VsdC52YWx1ZS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0bGVkUmVzdWx0LnJlYXNvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICAgIC8vIEFkZCB0b29sIHJlc3BvbnNlcyB0byBoaXN0b3J5XG4gICAgbWVzc2FnZXMucHVzaCguLi50b29sUmVzcG9uc2VzKTtcblxuICAgIC8vIFN0b3JlIHRvb2wgcmVzcG9uc2VzIGluIERCIChiZXN0IGVmZm9ydCwgbG9vcCB0aHJvdWdoIHJlc3VsdHMpXG4gICAgaWYgKGNvbnZlcnNhdGlvbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgUHJvbWlzZS5hbGwgdG8gc3RvcmUgYWxsIHRvb2wgcmVzcG9uc2VzIGluIHBhcmFsbGVsXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0b29sUmVzcG9uc2VzLm1hcCh0b29sTXNnID0+IFxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbihjb252ZXJzYXRpb25JZCwgXCJ0b29sXCIsIHRvb2xNc2cuY29udGVudCwgeyB0b29sX2NhbGxfaWQ6IHRvb2xNc2cudG9vbF9jYWxsX2lkIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGRiRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBEQiBFcnJvciBzdG9yaW5nIHRvb2wgcmVzcG9uc2UgJHt0b29sTXNnLnRvb2xfY2FsbF9pZH06YCwgZGJFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHRocm93LCBhbGxvdyBvdGhlciBtZXNzYWdlcyB0byBiZSBzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFN0b3JlZCAke3Rvb2xSZXNwb25zZXMubGVuZ3RofSB0b29sIHJlc3BvbnNlcyBpbiBkYXRhYmFzZWApO1xuICAgICAgICB9IGNhdGNoIChiYXRjaEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBiYXRjaCBzdG9yaW5nIHRvb2wgcmVzcG9uc2VzOmAsIGJhdGNoRXJyb3IpO1xuICAgICAgICAgICAgLy8gSW5kaXZpZHVhbCBlcnJvcnMgYXJlIGFscmVhZHkgY2F1Z2h0IGluIHRoZSBtYXAgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2ggaXMgZm9yIGVycm9ycyBvdXRzaWRlIHRoZSBpbmRpdmlkdWFsIHByb21pc2VzXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvb2xSZXNwb25zZXM7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHsgLy8gQ2F0Y2ggZXJyb3JzIGZyb20gdGhlIGVudGlyZSBydW5Db252ZXJzYXRpb24gZmxvd1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGQVRBTCBFcnJvciBpbiBydW5Db252ZXJzYXRpb24gcGlwZWxpbmU6XCIsIGVycm9yKTtcbiAgICAvLyBMb2cgaGlzdG9yeSBzcGVjaWZpY2FsbHkgZm9yIDQwMCBlcnJvcnMgdG8gaGVscCBkZWJ1ZyBzZXF1ZW5jZSBpc3N1ZXNcbiAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1lc3NhZ2UgaGlzdG9yeSBhdCB0aW1lIG9mIDQwMCBlcnJvcjpcIiwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMsIG51bGwsIDIpKTtcbiAgICB9XG4gICAgcmVzcG9uc2VDYWxsYmFjaz8uKHsgdHlwZTogJ2Vycm9yJywgY29udGVudDogYEFuIGVycm9yIG9jY3VycmVkOiAke2Vycm9yLm1lc3NhZ2UgfHwgXCJDaGVjayBzZXJ2ZXIgbG9ncy5cIn1gIH0pO1xuICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvd1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkNvbnZlcnNhdGlvbihtZXNzYWdlcywgdXNlcklucHV0LCBjb252ZXJzYXRpb25JZCA9IG51bGwsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsLCByZXNwb25zZUNhbGxiYWNrID0gbnVsbCkge1xuICBjb25zb2xlLmxvZyhgUnVubmluZyBjb252ZXJzYXRpb24gJHtjb252ZXJzYXRpb25JZH0gZm9yIHVzZXIgJHt1c2VySWR9LiBBY2Nlc3NUb2tlbjogJHshIWFjY2Vzc1Rva2VufWApO1xuICBjb25zdCBtb2RlbCA9IFwiZ3B0LTRvXCI7IC8vIFVzZSBhIGNhcGFibGUgbW9kZWwgZm9yIHJlYXNvbmluZ1xuICBjb25zdCBtYXhUb29sSXRlcmF0aW9ucyA9IDU7IC8vIExpbWl0IHNlcXVlbnRpYWwgdG9vbCBjYWxscyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cbiAgdHJ5IHtcbiAgICAgIGxldCBjdXJyZW50TWVzc2FnZXMgPSBbLi4ubWVzc2FnZXNdOyAvLyBVc2UgYSBtdXRhYmxlIGNvcHkgZm9yIHRoaXMgdHVyblxuICAgICAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gICAgICBsZXQgZmluYWxDb250ZW50ID0gbnVsbDsgLy8gU3RvcmVzIHRoZSBmaW5hbCB0ZXh0IHJlc3BvbnNlIGZvciB0aGUgdXNlclxuXG4gICAgICAvLyBIZWxwZXIgdG8gZmlsdGVyIG1lc3NhZ2VzIChLZWVwIGV4aXN0aW5nIGZpbHRlck1lc3NhZ2VzRm9yQVBJKVxuICAgICAgY29uc3QgZmlsdGVyTWVzc2FnZXNGb3JBUEkgPSAobXNncykgPT4ge1xuICAgICAgICAgIC8vIC4uLiAoa2VlcCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbikgLi4uXG4gICAgICAgICAgIGlmICghbXNncyB8fCAhQXJyYXkuaXNBcnJheShtc2dzKSkge1xuICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG1lc3NhZ2VzIGFycmF5IHBhc3NlZCB0byBmaWx0ZXI6XCIsIG1zZ3MpO1xuICAgICAgICAgICAgIHJldHVybiBbXTsgLy8gUmV0dXJuIGVtcHR5IGFycmF5IHRvIHByZXZlbnQgZnVydGhlciBlcnJvcnNcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1zZ3MgPSBbLi4ubXNnc107XG5cbiAgICAgICAgICAgLy8gVHJhY2sgdG9vbCBjYWxsIElEcyBmcm9tIGFzc2lzdGFudCBtZXNzYWdlc1xuICAgICAgICAgICBjb25zdCB2YWxpZFRvb2xDYWxsSWRzID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgIC8vIEZpcnN0IHBhc3M6IGNvbGxlY3QgYWxsIHZhbGlkIHRvb2wgY2FsbCBJRHMgZnJvbSBhc3Npc3RhbnQgbWVzc2FnZXNcbiAgICAgICAgICAgZmlsdGVyZWRNc2dzLmZvckVhY2gobXNnID0+IHtcbiAgICAgICAgICAgICBpZiAobXNnLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmIG1zZy50b29sX2NhbGxzICYmIEFycmF5LmlzQXJyYXkobXNnLnRvb2xfY2FsbHMpKSB7XG4gICAgICAgICAgICAgICBtc2cudG9vbF9jYWxscy5mb3JFYWNoKHRvb2xDYWxsID0+IHtcbiAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgdmFsaWRUb29sQ2FsbElkcy5hZGQodG9vbENhbGwuaWQpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgIC8vIFNlY29uZCBwYXNzOiBmaWx0ZXIgb3V0IGludmFsaWQgdG9vbCBtZXNzYWdlc1xuICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaWx0ZXJlZE1zZ3MuZmlsdGVyKChtc2csIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgLy8gS2VlcCBhbGwgbm9uLXRvb2wgbWVzc2FnZXNcbiAgICAgICAgICAgICBpZiAobXNnLnJvbGUgIT09ICd0b29sJykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAvLyBGb3IgdG9vbCBtZXNzYWdlcywgY2hlY2sgaWYgdGhleSBoYXZlIGEgdmFsaWQgdG9vbF9jYWxsX2lkXG4gICAgICAgICAgICAgaWYgKCFtc2cudG9vbF9jYWxsX2lkKSB7XG4gICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZpbHRlcmluZyBUT09MIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIHRvb2xfY2FsbF9pZCBhdCBpbmRleCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdG9vbCBtZXNzYWdlIGhhcyBhIGNvcnJlc3BvbmRpbmcgdG9vbCBjYWxsIGZyb20gYW4gYXNzaXN0YW50XG4gICAgICAgICAgICAgaWYgKCF2YWxpZFRvb2xDYWxsSWRzLmhhcyhtc2cudG9vbF9jYWxsX2lkKSkge1xuICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGaWx0ZXJpbmcgVE9PTCBtZXNzYWdlIG5vdCBjb3JyZWN0bHkgcHJlY2VkZWQgYnkgYXNzaXN0YW50IHRvb2xfY2FsbC4gSW5kZXg9JHtpbmRleH0sIFRvb2xDYWxsSUQ9JHttc2cudG9vbF9jYWxsX2lkfWApO1xuICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAvLyBBbHNvIGVuc3VyZSBjb250ZW50IGV4aXN0cyBmb3IgdG9vbCBtZXNzYWdlc1xuICAgICAgICAgICAgIGlmIChtc2cuY29udGVudCA9PSBudWxsIHx8IG1zZy5jb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGaWx0ZXJpbmcgVE9PTCBtZXNzYWdlIHdpdGggbWlzc2luZy9lbXB0eSBjb250ZW50LiBJbmRleD0ke2luZGV4fSwgVG9vbENhbGxJRD0ke21zZy50b29sX2NhbGxfaWR9YCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGaW5hbCBzYW5pdHkgY2hlY2s6IEVuc3VyZSBhbHRlcm5hdGluZyB1c2VyL2Fzc2lzdGFudC90b29sIHNlcXVlbmNlIHdoZXJlIGFwcHJvcHJpYXRlXG4gICAgICAgICAgIC8vIFJlbW92ZSBjb25zZWN1dGl2ZSBtZXNzYWdlcyBvZiB0aGUgc2FtZSByb2xlIChleGNlcHQgJ3Rvb2wnIHdoaWNoIGZvbGxvd3MgJ2Fzc2lzdGFudCcpXG4gICAgICAgICAgIGNvbnN0IGZpbmFsRmlsdGVyZWQgPSBbXTtcbiAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1zZyA9IHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgY29uc3QgcHJldk1zZyA9IGZpbmFsRmlsdGVyZWRbZmluYWxGaWx0ZXJlZC5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICBpZiAocHJldk1zZyAmJiBjdXJyZW50TXNnLnJvbGUgPT09IHByZXZNc2cucm9sZSAmJiBjdXJyZW50TXNnLnJvbGUgIT09ICd0b29sJykge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGaWx0ZXJpbmcgY29uc2VjdXRpdmUgbWVzc2FnZSBvZiByb2xlICR7Y3VycmVudE1zZy5yb2xlfSBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCBhZGRpbmcgdGhlIGNvbnNlY3V0aXZlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBFbnN1cmUgdG9vbCBtZXNzYWdlIGZvbGxvd3MgYW4gYXNzaXN0YW50IG1lc3NhZ2UgKGxvb3NlbHksIGZpbHRlciBoYW5kbGVzIHNwZWNpZmljIElEIG1hdGNoaW5nKVxuICAgICAgICAgICAgICAvLyBpZiAoY3VycmVudE1zZy5yb2xlID09PSAndG9vbCcgJiYgKCFwcmV2TXNnIHx8IHByZXZNc2cucm9sZSAhPT0gJ2Fzc2lzdGFudCcpKSB7XG4gICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLndhcm4oYEZpbHRlcmluZyBUT09MIG1lc3NhZ2Ugbm90IGZvbGxvd2luZyBhbiBhc3Npc3RhbnQgbWVzc2FnZSBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgICAgICAgIC8vICAgICBjb250aW51ZTsgLy8gU2tpcCBhZGRpbmcgdGhlIG91dC1vZi1wbGFjZSB0b29sIG1lc3NhZ2VcbiAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgIGZpbmFsRmlsdGVyZWQucHVzaChjdXJyZW50TXNnKTtcbiAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgY29uc29sZS5sb2coYEZpbHRlcmVkICR7bXNncy5sZW5ndGggLSBmaW5hbEZpbHRlcmVkLmxlbmd0aH0gaW52YWxpZC9tYWxmb3JtZWQgbWVzc2FnZXNgKTtcbiAgICAgICAgICAgcmV0dXJuIGZpbmFsRmlsdGVyZWQ7XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIC0tLSBNYWluIFJlYXNvbmluZyBMb29wIC0tLVxuICAgICAgd2hpbGUgKGl0ZXJhdGlvbiA8IG1heFRvb2xJdGVyYXRpb25zKSB7XG4gICAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICAgICAgY29uc29sZS5sb2coYFxcbi0tLSBDb252ZXJzYXRpb24gVHVybiAke2l0ZXJhdGlvbn0vJHttYXhUb29sSXRlcmF0aW9uc30gLS0tYCk7XG5cbiAgICAgICAgICBjb25zdCBtZXNzYWdlc0ZvckFQSSA9IGZpbHRlck1lc3NhZ2VzRm9yQVBJKGN1cnJlbnRNZXNzYWdlcyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2VzRm9yQVBJLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTWVzc2FnZSBoaXN0b3J5IGJlY2FtZSBlbXB0eSBkdXJpbmcgZmlsdGVyaW5nLlwiKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IENhbm5vdCBwcm9jZWVkIHdpdGggZW1wdHkgbWVzc2FnZSBoaXN0b3J5LlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKioqKiBERUJVRyBMT0cgKioqKipcbiAgICAgICAgICBjb25zb2xlLmxvZyhgTWFraW5nIEFQSSBjYWxsICMke2l0ZXJhdGlvbn0gd2l0aCBtb2RlbDogJHttb2RlbH1gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgTWVzc2FnZSBIaXN0b3J5IChMZW5ndGg6ICR7bWVzc2FnZXNGb3JBUEkubGVuZ3RofSk6YCk7XG4gICAgICAgICAgbWVzc2FnZXNGb3JBUEkuZm9yRWFjaCgobXNnLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBbJHtpbmRleH1dIFJvbGU6ICR7bXNnLnJvbGV9YCk7XG4gICAgICAgICAgICAgIGlmIChtc2cuY29udGVudCkgY29uc29sZS5sb2coYCAgICAgIENvbnRlbnQ6ICR7U3RyaW5nKG1zZy5jb250ZW50KS5zdWJzdHJpbmcoMCwgMTAwKX0uLi5gKTsgLy8gVHJ1bmNhdGUsIGVuc3VyZSBzdHJpbmdcbiAgICAgICAgICAgICAgaWYgKG1zZy50b29sX2NhbGxzKSBjb25zb2xlLmxvZyhgICAgICAgVG9vbCBDYWxsczogJHtKU09OLnN0cmluZ2lmeShtc2cudG9vbF9jYWxscy5tYXAodGMgPT4gdGMuaWQgKyBcIjpcIiArIHRjLmZ1bmN0aW9uPy5uYW1lKSl9YCk7XG4gICAgICAgICAgICAgIGlmIChtc2cudG9vbF9jYWxsX2lkKSBjb25zb2xlLmxvZyhgICAgICAgVG9vbCBDYWxsIElEOiAke21zZy50b29sX2NhbGxfaWR9YCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYC0tLSBFbmQgQVBJIENhbGwgIyR7aXRlcmF0aW9ufSBIaXN0b3J5IC0tLSBcXG5gKTtcbiAgICAgICAgICAvLyAqKioqKiBFTkQgREVCVUcgTE9HICoqKioqXG5cbiAgICAgICAgICAvLyAtLS0gQ2FsbCBPcGVuQUkgLS0tXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc0ZvckFQSSxcbiAgICAgICAgICAgICAgdG9vbHM6IHRvb2xzLCAvLyBNYWtlIHRvb2xzIGF2YWlsYWJsZSBvbiBldmVyeSB0dXJuXG4gICAgICAgICAgICAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gTGV0IHRoZSBtb2RlbCBkZWNpZGUgaWYgaXQgbmVlZHMgdG9vbHNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZTtcblxuICAgICAgICAgIC8vIC0tLSBBZGQgQXNzaXN0YW50IE1lc3NhZ2UgdG8gSGlzdG9yeSAoTG9jYWwgJiBEQikgLS0tXG4gICAgICAgICAgY3VycmVudE1lc3NhZ2VzLnB1c2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICBpZiAoY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZS5jb250ZW50IHx8IG51bGwsIC8vIFN0b3JlIG51bGwgaWYgbm8gY29udGVudCBcbiAgICAgICAgICAgICAgICAgICAgICB7IHRvb2xfY2FsbHM6IHJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzIHx8IG51bGwgfSAvLyBBbHdheXMgcGFzcyBhbiBvYmplY3QsIGV2ZW4gaWYgdG9vbF9jYWxscyBpcyBudWxsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChkYkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBEQiBFcnJvciBzdG9yaW5nIGFzc2lzdGFudCBtZXNzYWdlIChpdGVyYXRpb24gJHtpdGVyYXRpb259KTpgLCBkYkVycm9yKTtcbiAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgREIgc3RvcmUgZmFpbHMgZm9yIHRoaXMgbWVzc2FnZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gLS0tIENoZWNrIGZvciBUb29sIENhbGxzIC0tLVxuICAgICAgICAgIGNvbnN0IGFzc2lzdGFudFRvb2xDYWxscyA9IHJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzO1xuXG4gICAgICAgICAgaWYgKGFzc2lzdGFudFRvb2xDYWxscyAmJiBhc3Npc3RhbnRUb29sQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQXNzaXN0YW50IHJlcXVlc3RlZCAke2Fzc2lzdGFudFRvb2xDYWxscy5sZW5ndGh9IHRvb2wgY2FsbChzKSBpbiBpdGVyYXRpb24gJHtpdGVyYXRpb259OmAsIEpTT04uc3RyaW5naWZ5KGFzc2lzdGFudFRvb2xDYWxscy5tYXAodGMgPT4gKHsgaWQ6IHRjLmlkLCBuYW1lOiB0Yy5mdW5jdGlvbj8ubmFtZSB9KSkpKTtcblxuICAgICAgICAgICAgICAvLyBJbmZvcm0gY2xpZW50IHdlJ3JlIHByb2Nlc3NpbmcgKGlmIHN0cmVhbWluZylcbiAgICAgICAgICAgICAgcmVzcG9uc2VDYWxsYmFjaz8uKHsgdHlwZTogJ3Byb2Nlc3NpbmcnLCBjb250ZW50OiBgVGhpbmtpbmcgKHN0ZXAgJHtpdGVyYXRpb259KS4uLmAgfSk7XG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTsgLy8gU21hbGwgZGVsYXkgZm9yIFVJIHVwZGF0ZVxuXG4gICAgICAgICAgICAgIC8vIC0tLSBQcm9jZXNzIHRoZSByZXF1ZXN0ZWQgdG9vbHMgLS0tXG4gICAgICAgICAgICAgIC8vIHByb2Nlc3NUb29sQ2FsbHMgYWRkcyB0aGUgdG9vbCByZXNwb25zZXMgdG8gY3VycmVudE1lc3NhZ2VzIGFuZCBzdG9yZXMgdGhlbSBpbiBEQlxuICAgICAgICAgICAgICBjb25zdCB0b29sUmVzcG9uc2VzID0gYXdhaXQgcHJvY2Vzc1Rvb2xDYWxscyhhc3Npc3RhbnRUb29sQ2FsbHMsIGN1cnJlbnRNZXNzYWdlcywgY29udmVyc2F0aW9uSWQsIHVzZXJJZCwgYWNjZXNzVG9rZW4pO1xuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSB0b29sIGNhbGwgZmFpbGVkIGNyaXRpY2FsbHksIG1heWJlIHN0b3AgZWFybHk/IChPcHRpb25hbCBlbmhhbmNlbWVudClcbiAgICAgICAgICAgICAgY29uc3QgaGFzQ3JpdGljYWxGYWlsdXJlID0gdG9vbFJlc3BvbnNlcy5zb21lKHRyID0+IHRyLmNvbnRlbnQ/LmluY2x1ZGVzKCcoU3RhdHVzOiBGQUlMRUQpJykpO1xuICAgICAgICAgICAgICBpZiAoaGFzQ3JpdGljYWxGYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDcml0aWNhbCB0b29sIGZhaWx1cmUgZGV0ZWN0ZWQgaW4gaXRlcmF0aW9uICR7aXRlcmF0aW9ufS4gTExNIHdpbGwgYmUgaW5mb3JtZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgLy8gTGV0IHRoZSBsb29wIGNvbnRpbnVlLCBMTE0gc2hvdWxkIHNlZSB0aGUgZmFpbHVyZSBtZXNzYWdlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyAtLS0gTG9vcCBjb250aW51ZXM6IFNlbmQgdG9vbCByZXN1bHRzIGJhY2sgdG8gTExNIC0tLVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gLS0tIE5vIFRvb2wgQ2FsbHM6IFRoaXMgaXMgdGhlIGZpbmFsIHJlc3BvbnNlIC0tLVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gdG9vbCBjYWxscyByZXF1ZXN0ZWQgaW4gaXRlcmF0aW9uICR7aXRlcmF0aW9ufS4gRmluYWwgcmVzcG9uc2UgZ2VuZXJhdGVkLmApO1xuICAgICAgICAgICAgICBmaW5hbENvbnRlbnQgPSByZXNwb25zZU1lc3NhZ2UuY29udGVudCA/PyBcIlwiOyAvLyBVc2UgbnVsbGlzaCBjb2FsZXNjaW5nIGZvciBzYWZldHlcbiAgICAgICAgICAgICAgYnJlYWs7IC8vIEV4aXQgdGhlIGxvb3BcbiAgICAgICAgICB9XG4gICAgICB9IC8vIEVuZCBvZiB3aGlsZSBsb29wXG5cbiAgICAgIC8vIC0tLSBIYW5kbGUgbG9vcCBleGl0IC0tLVxuICAgICAgaWYgKGl0ZXJhdGlvbiA+PSBtYXhUb29sSXRlcmF0aW9ucykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgTWF4aW11bSB0b29sIGl0ZXJhdGlvbnMgKCR7bWF4VG9vbEl0ZXJhdGlvbnN9KSByZWFjaGVkLiBSZXR1cm5pbmcgbGFzdCBnZW5lcmF0ZWQgY29udGVudCBvciBlcnJvci5gKTtcbiAgICAgICAgICAvLyBBdHRlbXB0IHRvIHJldHVybiB0aGUgbGFzdCBjb250ZW50IGdlbmVyYXRlZCwgZXZlbiBpZiBpdCB3YXNuJ3QgaW50ZW5kZWQgYXMgZmluYWxcbiAgICAgICAgICBjb25zdCBsYXN0QXNzaXN0YW50TXNnID0gY3VycmVudE1lc3NhZ2VzW2N1cnJlbnRNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdEFzc2lzdGFudE1zZz8ucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgbGFzdEFzc2lzdGFudE1zZy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICBmaW5hbENvbnRlbnQgPSBsYXN0QXNzaXN0YW50TXNnLmNvbnRlbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmluYWxDb250ZW50ID0gXCJJIHNlZW0gdG8gYmUgc3R1Y2sgaW4gYSBsb29wIHRyeWluZyB0byBwcm9jZXNzIHRoYXQgcmVxdWVzdC4gQ291bGQgeW91IHRyeSByZXBocmFzaW5nIGl0P1wiO1xuICAgICAgICAgICAgICByZXNwb25zZUNhbGxiYWNrPy4oeyB0eXBlOiAnZXJyb3InLCBjb250ZW50OiBmaW5hbENvbnRlbnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkxvb3AgZmluaXNoZWQgd2l0aG91dCBnZW5lcmF0aW5nIGZpbmFsIGNvbnRlbnQuXCIpO1xuICAgICAgICAgIGZpbmFsQ29udGVudCA9IFwiU29ycnksIEkgd2Fzbid0IGFibGUgdG8gZ2VuZXJhdGUgYSBmaW5hbCByZXNwb25zZSBhZnRlciBwcm9jZXNzaW5nIHlvdXIgcmVxdWVzdC5cIjtcbiAgICAgICAgICByZXNwb25zZUNhbGxiYWNrPy4oeyB0eXBlOiAnZXJyb3InLCBjb250ZW50OiBmaW5hbENvbnRlbnQgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLSBTdHJlYW0gdGhlIEZJTkFMIHJlc3BvbnNlIC0tLVxuICAgICAgaWYgKHJlc3BvbnNlQ2FsbGJhY2sgJiYgZmluYWxDb250ZW50KSB7XG4gICAgICAgICAgLy8gU2VuZCB0aGUgZmluYWwgY29udGVudCBjaHVuayBieSBjaHVuayBpZiBkZXNpcmVkLCBvciBhcyBvbmUgcGllY2VcbiAgICAgICAgICAvLyBTaW1wbGlmaWVkOiBTZW5kIGFzIG9uZSBwaWVjZSBhZnRlciB0aGUgbG9vcFxuICAgICAgICAgICByZXNwb25zZUNhbGxiYWNrKHsgdHlwZTogJ2NvbnRlbnQnLCBjb250ZW50OiBmaW5hbENvbnRlbnQgfSk7XG4gICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpOyAvLyBTaG9ydCBkZWxheSBiZWZvcmUgZW5kXG4gICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2soeyB0eXBlOiAnZW5kJyB9KTtcblxuICAgICAgfSBlbHNlIGlmICghcmVzcG9uc2VDYWxsYmFjayAmJiBmaW5hbENvbnRlbnQpIHtcbiAgICAgICAgICAvLyBOb24tc3RyZWFtaW5nIG1vZGU6IHJldHVybiB0aGUgZmluYWwgY29udGVudFxuICAgICAgICAgIHJldHVybiBmaW5hbENvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKCFmaW5hbENvbnRlbnQpIHtcbiAgICAgICAgICAgLy8gRW5zdXJlIHNvbWV0aGluZyBpcyByZXR1cm5lZC9zZW50IGV2ZW4gaWYgY29udGVudCBpcyBlbXB0eS9udWxsXG4gICAgICAgICAgIGlmIChyZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDYWxsYmFjayh7IHR5cGU6ICdjb250ZW50JywgY29udGVudDogJycgfSk7IC8vIFNlbmQgZW1wdHkgY29udGVudFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2soeyB0eXBlOiAnZW5kJyB9KTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCJGaW5hbCByZXNwb25zZSBjb250ZW50OlwiLCBmaW5hbENvbnRlbnQpO1xuICAgICAgLy8gVGhlIGZ1bmN0aW9uIGltcGxpY2l0bHkgcmV0dXJucyBmaW5hbENvbnRlbnQgaWYgbm90IHN0cmVhbWluZywgb3IgaGFuZGxlcyBzdHJlYW1pbmcgdmlhIGNhbGxiYWNrXG4gICAgICByZXR1cm4gZmluYWxDb250ZW50OyAvLyBSZXR1cm4gZm9yIG5vbi1zdHJlYW1pbmcgY2FzZVxuXG5cbiAgfSBjYXRjaCAoZXJyb3IpIHsgLy8gQ2F0Y2ggZXJyb3JzIGZyb20gdGhlIGVudGlyZSBydW5Db252ZXJzYXRpb24gZmxvd1xuICAgICAgY29uc29sZS5lcnJvcihcIkZBVEFMIEVycm9yIGluIHJ1bkNvbnZlcnNhdGlvbiBwaXBlbGluZTpcIiwgZXJyb3IpO1xuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIk1lc3NhZ2UgaGlzdG9yeSBhdCB0aW1lIG9mIDQwMCBlcnJvcjpcIiwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMsIG51bGwsIDIpKTsgLy8gTG9nIGluaXRpYWwgaGlzdG9yeSBzdGF0ZVxuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIGVycm9yIGlzIHByb3BhZ2F0ZWQgdG8gdGhlIGNsaWVudFxuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYEFuIGVycm9yIG9jY3VycmVkOiAke2Vycm9yLm1lc3NhZ2UgfHwgXCJDaGVjayBzZXJ2ZXIgbG9ncy5cIn1gO1xuICAgICAgcmVzcG9uc2VDYWxsYmFjaz8uKHsgdHlwZTogJ2Vycm9yJywgY29udGVudDogZXJyb3JNZXNzYWdlIH0pO1xuICAgICAgLy8gVGhyb3cgb3IgcmV0dXJuIGVycm9yIHN0cmluZyBiYXNlZCBvbiBleHBlY3RlZCBjYWxsZXIgYmVoYXZpb3JcbiAgICAgIC8vIHRocm93IGVycm9yOyAvLyBSZS10aHJvd2luZyBtaWdodCBiZSBiZXR0ZXIgZm9yIGNoYXQoKSBmdW5jdGlvbiB0byBjYXRjaFxuICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTsgLy8gT3IgcmV0dXJuIGVycm9yIHN0cmluZyBmb3Igbm9uLXN0cmVhbWluZ1xuICB9XG59XG5cblxuXG4vLyAtLS0gTWFpbiBDaGF0IEVudHJ5IFBvaW50IC0tLVxuYXN5bmMgZnVuY3Rpb24gY2hhdCh1c2VySW5wdXQsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsLCBzdHJlYW1DYWxsYmFjayA9IG51bGwsIHN0YXJ0TmV3Q29udmVyc2F0aW9uID0gZmFsc2UpIHsgLy8gQWRkZWQgc3RhcnROZXdDb252ZXJzYXRpb24gZmxhZ1xuICBjb25zb2xlLmxvZyhgQ2hhdCByZXF1ZXN0OiBVc2VyPSR7dXNlcklkfSwgSW5wdXQ9XCIke3VzZXJJbnB1dH1cIiwgU3RhcnROZXc9JHtzdGFydE5ld0NvbnZlcnNhdGlvbn1gKTsgLy8gTG9nIHRoZSBmbGFnXG4gIGlmICghdXNlcklkIHx8IHVzZXJJZCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgc3RyZWFtQ2FsbGJhY2s/Lih7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IFwiVXNlciBJRCBtaXNzaW5nLlwiIH0pO1xuICAgIHJldHVybiBcIkVycm9yOiBVc2VyIElEIHJlcXVpcmVkLlwiO1xuICB9XG4gICBpZiAoIXVzZXJJbnB1dD8udHJpbSgpKSB7XG4gICAgICAgc3RyZWFtQ2FsbGJhY2s/Lih7IHR5cGU6ICdpbmZvJywgY29udGVudDogXCJFbnRlciBhIG1lc3NhZ2UuXCIgfSk7IHJldHVybiBcIlwiO1xuICAgfVxuXG4gICAvLyBTZW5kICdzdGFydCcgc2lnbmFsIGltbWVkaWF0ZWx5IGZvciBzdHJlYW1pbmdcbiAgIHN0cmVhbUNhbGxiYWNrPy4oeyB0eXBlOiAnc3RhcnQnIH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW5zID0gYWNjZXNzVG9rZW4gPyB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfSA6IG51bGw7XG4gICAgbGV0IHVzZXI7XG4gICAgbGV0IGNvbnZlcnNhdGlvbjtcbiAgICBsZXQgaGlzdG9yeU1lc3NhZ2VzID0gW107IC8vIEZvcm1hdHRlZCBoaXN0b3J5IGZvciBPcGVuQUkgQVBJXG5cbiAgICAvLyAtLS0gTG9hZCBVc2VyICYgQ29udmVyc2F0aW9uIEhpc3RvcnkgLS0tXG4gICAgaWYgKCFzdGFydE5ld0NvbnZlcnNhdGlvbikge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gKipGSVg6KiogVXNlIHRoZSBvcHRpbWl6ZWQgcXVlcnlcbiAgICAgICAgdXNlciA9IGF3YWl0IGdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uKHVzZXJJZCk7XG5cbiAgICAgICAgaWYgKHVzZXI/LkNvbnZlcnNhdGlvbnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbiA9IHVzZXIuQ29udmVyc2F0aW9uc1swXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBhY3RpdmUgY29udmVyc2F0aW9uICR7Y29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZH1gKTtcbiAgICAgICAgICAgIGlmIChjb252ZXJzYXRpb24uQ29udmVyc2F0aW9uTWVzc2FnZXM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IEFTQ0VORElORyBmb3IgQVBJXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uLkNvbnZlcnNhdGlvbk1lc3NhZ2VzLnNvcnQoKGEsIGIpID0+IGEuc2VxdWVuY2VfbnVtYmVyIC0gYi5zZXF1ZW5jZV9udW1iZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gKipDUklUSUNBTCBGSVg6IFJvYnVzdCBIaXN0b3J5IE1hcHBpbmcqKlxuICAgICAgICAgICAgICAgIGhpc3RvcnlNZXNzYWdlcyA9IGNvbnZlcnNhdGlvbi5Db252ZXJzYXRpb25NZXNzYWdlcy5tYXAoKG1zZywgaW5kZXgsIGFsbE1zZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZU9iamVjdCA9IHsgcm9sZTogbXNnLnJvbGUgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50OiBNYW5kYXRvcnkgdW5sZXNzIGFzc2lzdGFudCB3LyB0b29sIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2cuY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBtc2cuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgbXNnLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0b29sX2NhbGxzIGZpZWxkIGFjdHVhbGx5IGNvbnRhaW5zIHZhbGlkIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbGlkVG9vbENhbGxzRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnLnRvb2xfY2FsbHMudG9vbF9jYWxscyAmJiBBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMpICYmIG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRUb29sQ2FsbHNFeGlzdCA9IG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMuc29tZSh0YyA9PiB0Yy5pZCAmJiB0Yy5mdW5jdGlvbj8ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzKSAmJiBtc2cudG9vbF9jYWxscy5sZW5ndGggPiAwKSB7IC8vIEhhbmRsZSBkaXJlY3QgYXJyYXkgc3RvcmFnZSBwb3NzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRUb29sQ2FsbHNFeGlzdCA9IG1zZy50b29sX2NhbGxzLnNvbWUodGMgPT4gdGMuaWQgJiYgdGMuZnVuY3Rpb24/Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRUb29sQ2FsbHNFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBudWxsOyAvLyBBUEkgZXhwZWN0cyBudWxsL1wiXCIgaWYgb25seSB0b29sX2NhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZU9iamVjdC5jb250ZW50ID0gXCJcIjsgLy8gVHJlYXQgYXMgZW1wdHkgY29udGVudCBpZiB0b29sX2NhbGxzIGludmFsaWQvZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBcIlwiOyAvLyBEZWZhdWx0IGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBUb29sIENhbGxzIChBc3Npc3RhbnQpOiBFeHRyYWN0IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAobXNnLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmIG1zZy50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9vbENhbGxzQXJyYXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAxOiBTdG9yZWQgYXMgeyB0b29sX2NhbGxzOiBbLi4uXSB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnLnRvb2xfY2FsbHMudG9vbF9jYWxscyAmJiBBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzQXJyYXkgPSBtc2cudG9vbF9jYWxscy50b29sX2NhbGxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAyOiBTdG9yZWQgYXMgWy4uLl0gKGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsc0FycmF5ID0gbXNnLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBPTkxZIGlmIHZhbGlkIGFuZCBub24tZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbHNBcnJheSAmJiB0b29sQ2FsbHNBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkVG9vbENhbGxzID0gdG9vbENhbGxzQXJyYXkuZmlsdGVyKHRjID0+IHRjLmlkICYmIHRjLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgdGMuZnVuY3Rpb24/Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRUb29sQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZU9iamVjdC50b29sX2NhbGxzID0gdmFsaWRUb29sQ2FsbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1lbnN1cmUgY29udGVudCBpcyBudWxsIGlmIE9OTFkgdG9vbCBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VPYmplY3QuY29udGVudCA9PT0gXCJcIiAmJiB2YWxpZFRvb2xDYWxscy5sZW5ndGggPT09IHRvb2xDYWxsc0FycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERCIG1lc3NhZ2UgJHttc2cubWVzc2FnZV9pZH0gaGFkIHRvb2xfY2FsbHMgb2JqZWN0IGJ1dCBubyB2YWxpZCBjYWxscy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGVtcHR5L2ludmFsaWQgdG9vbF9jYWxscyBhcnJheSB0byBBUEkgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUb29sIENhbGwgSUQgKFRvb2wpOiBFeHRyYWN0IHRoZSBJRCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5yb2xlID09PSAndG9vbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b29sSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMTogU3RvcmVkIGFzIHsgdG9vbF9jYWxsX2lkOiBcIi4uLlwiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNnLnRvb2xfY2FsbF9pZCA9PT0gJ29iamVjdCcgJiYgbXNnLnRvb2xfY2FsbF9pZCAhPT0gbnVsbCAmJiBtc2cudG9vbF9jYWxsX2lkLnRvb2xfY2FsbF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJZCA9IG1zZy50b29sX2NhbGxfaWQudG9vbF9jYWxsX2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMjogU3RvcmVkIGFzIFwiLi4uXCIgKGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnLnRvb2xfY2FsbF9pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sSWQgPSBtc2cudG9vbF9jYWxsX2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb29sIG1lc3NhZ2UgTVVTVCBoYXZlIElEIGFuZCBjb250ZW50IHRvIGJlIHZhbGlkIGZvciBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b29sSWQgJiYgbWVzc2FnZU9iamVjdC5jb250ZW50ICE9IG51bGwpIHsgLy8gQ29udGVudCBjb21lcyBmcm9tIGZvcm1hdFRvb2xSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VPYmplY3QudG9vbF9jYWxsX2lkID0gdG9vbElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZpbHRlcmluZyBpbnZhbGlkIFRPT0wgbWVzc2FnZSAobWlzc2luZyBJRCBvciBjb250ZW50KTogREJfSUQ9JHttc2cubWVzc2FnZV9pZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gRmlsdGVyIG91dCBpbnZhbGlkIHRvb2wgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQVBJIFZhbGlkYXRpb24gQ2hlY2s6IHRvb2wgcm9sZSBtdXN0IGZvbGxvdyBhc3Npc3RhbnQgcm9sZSB3aXRoIHRvb2xfY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgLy8gKipSRU1PVkVEIFNUUklDVCBQUkVDRURJTkcgQ0hFQ0sqKiAtIFJlbHlpbmcgb24gZmlsdGVyTWVzc2FnZXNGb3JBUEkgaW5zaWRlIHJ1bkNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAobWVzc2FnZU9iamVjdC5yb2xlID09PSAndG9vbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IHByZXZNYXBwZWRNZXNzYWdlID0gaW5kZXggPiAwID8gaGlzdG9yeU1lc3NhZ2VzW2luZGV4IC0gMV0gOiBudWxsOyAvLyBDaGVjayB0aGUgKm1hcHBlZCogcHJldmlvdXMgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFwcmV2TWFwcGVkTWVzc2FnZSB8fCBwcmV2TWFwcGVkTWVzc2FnZS5yb2xlICE9PSAnYXNzaXN0YW50JyB8fCAhcHJldk1hcHBlZE1lc3NhZ2UudG9vbF9jYWxscyB8fCAhcHJldk1hcHBlZE1lc3NhZ2UudG9vbF9jYWxscy5zb21lKHRjID0+IHRjLmlkID09PSBtZXNzYWdlT2JqZWN0LnRvb2xfY2FsbF9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgY29uc29sZS53YXJuKGBGaWx0ZXJpbmcgVE9PTCBtZXNzYWdlIG5vdCBjb3JyZWN0bHkgcHJlY2VkZWQgYnkgYXNzaXN0YW50IHRvb2xfY2FsbC4gREJfSUQ9JHttc2cubWVzc2FnZV9pZH0sIFRvb2xDYWxsSUQ9JHttZXNzYWdlT2JqZWN0LnRvb2xfY2FsbF9pZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgcmV0dXJuIG51bGw7IC8vIEZpbHRlciBvdXQgb3JwaGFuZWQvbWlzbWF0Y2hlZCB0b29sIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFzc2lzdGFudCBtZXNzYWdlcyB0aGF0IGVuZCB1cCBlbXB0eSAobm8gY29udGVudCwgbm8gdmFsaWQgdG9vbCBjYWxscylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VPYmplY3Qucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgbWVzc2FnZU9iamVjdC5jb250ZW50ID09IG51bGwgJiYgIW1lc3NhZ2VPYmplY3QudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmlsdGVyaW5nIGVtcHR5IEFTU0lTVEFOVCBtZXNzYWdlLiBEQl9JRD0ke21zZy5tZXNzYWdlX2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZU9iamVjdDtcblxuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTsgLy8gUmVtb3ZlIG51bGxzIGZyb20gZmlsdGVyaW5nXG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGVkIGFuZCBtYXBwZWQgJHtoaXN0b3J5TWVzc2FnZXMubGVuZ3RofSB2YWxpZCBtZXNzYWdlcyBmcm9tIGhpc3RvcnkuYCk7XG4gICAgICAgICAgICAgICAgLy8gREVCVUc6IExvZyB0aGUgZmluYWwgaGlzdG9yeSBiZWluZyBzZW50LCBPTkxZIEZPUiBERUJVR0dJTkcgU0VOU0lUSVZFIERBVEFcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkZpbmFsIGhpc3RvcnkgZm9yIEFQSTpcIiwgSlNPTi5zdHJpbmdpZnkoaGlzdG9yeU1lc3NhZ2VzLCBudWxsLCAyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ29udmVyc2F0aW9uICR7Y29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZH0gaGFzIG5vIG1lc3NhZ2VzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBleGlzdGluZyB1c2VyL2NvbnZlcnNhdGlvbiBmb3VuZCBmb3IgJHt1c2VySWR9LiBDcmVhdGluZy5gKTtcbiAgICAgICAgICAgICBpZiAoIXVzZXIpIHsgLy8gRW5zdXJlIHVzZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgIGNvbnN0IGlzRW1haWwgPSB1c2VySWQuaW5jbHVkZXMoJ0AnKTtcbiAgICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBpc0VtYWlsID8gdXNlcklkIDogYCR7dXNlcklkfUBleGFtcGxlLmNvbWA7XG4gICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gaXNFbWFpbCA/ICdlbWFpbCcgOiAnc3lzdGVtJzsgLy8gQWRqdXN0IGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgICB1c2VyID0gYXdhaXQgZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBwcm92aWRlciwgdXNlcklkLCB1c2VySWQpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDUklUSUNBTDogRXJyb3IgbG9hZGluZyB1c2VyL2hpc3Rvcnk6XCIsIGVycm9yKTtcbiAgICAgICAgdHJ5IHsgLy8gQXR0ZW1wdCByZWNvdmVyeVxuICAgICAgICAgICAgY29uc3QgaXNFbWFpbCA9IHVzZXJJZC5pbmNsdWRlcygnQCcpO1xuICAgICAgICAgICAgY29uc3QgZW1haWwgPSBpc0VtYWlsID8gdXNlcklkIDogYCR7dXNlcklkfUBleGFtcGxlLmNvbWA7XG4gICAgICAgICAgICB1c2VyID0gYXdhaXQgZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBpc0VtYWlsID8gJ2VtYWlsJyA6ICdzeXN0ZW0nLCB1c2VySWQsIHVzZXJJZCk7XG4gICAgICAgIH0gY2F0Y2ggKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNSSVRJQ0FMOiBGYWlsZWQgdXNlciByZWNvdmVyeTpcIiwgdXNlckVycm9yKTtcbiAgICAgICAgICAgIHN0cmVhbUNhbGxiYWNrPy4oeyB0eXBlOiAnZXJyb3InLCBjb250ZW50OiBcIkZhaWxlZCB0byBsb2FkIHVzZXIgcHJvZmlsZS5cIiB9KTtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBDb3VsZCBub3QgbG9hZCB1c2VyIHByb2ZpbGUuXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29udmVyc2F0aW9uID0gbnVsbDsgaGlzdG9yeU1lc3NhZ2VzID0gW107IC8vIFJlc2V0IHN0YXRlXG4gICAgfVxuICAgIH0gZWxzZSB7IC8vIEhhbmRsZSBzdGFydE5ld0NvbnZlcnNhdGlvbiA9IHRydWVcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydGluZyBhIG5ldyBjb252ZXJzYXRpb24gYXMgcmVxdWVzdGVkLlwiKTtcbiAgICAgICAgLy8gRW5zdXJlIHVzZXIgb2JqZWN0IGlzIGxvYWRlZCwgZXZlbiBpZiBoaXN0b3J5IGxvYWRpbmcgd2FzIHNraXBwZWRcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRW1haWwgPSB1c2VySWQuaW5jbHVkZXMoJ0AnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbCA9IGlzRW1haWwgPyB1c2VySWQgOiBgJHt1c2VySWR9QGV4YW1wbGUuY29tYDtcbiAgICAgICAgICAgICAgICB1c2VyID0gYXdhaXQgZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBpc0VtYWlsID8gJ2VtYWlsJyA6ICdzeXN0ZW0nLCB1c2VySWQsIHVzZXJJZCk7XG4gICAgICAgICAgICB9IGNhdGNoICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ1JJVElDQUw6IEZhaWxlZCB1c2VyIGNyZWF0aW9uL3JldHJpZXZhbCB3aGVuIHN0YXJ0aW5nIG5ldyBjb252ZXJzYXRpb246XCIsIHVzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgc3RyZWFtQ2FsbGJhY2s/Lih7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IFwiRmFpbGVkIHRvIGxvYWQgdXNlciBwcm9maWxlIGZvciBuZXcgY2hhdC5cIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogQ291bGQgbm90IGxvYWQgdXNlciBwcm9maWxlLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgY2xlYXIgY29udmVyc2F0aW9uIGFuZCBoaXN0b3J5XG4gICAgICAgIGNvbnZlcnNhdGlvbiA9IG51bGw7XG4gICAgICAgIGhpc3RvcnlNZXNzYWdlcyA9IFtdO1xuICAgIH1cblxuICAgIC8vIC0tLSBDcmVhdGUgQ29udmVyc2F0aW9uIGlmIG5lZWRlZCAmIEFkZCBTeXN0ZW0gUHJvbXB0IC0tLVxuICAgIGlmICghY29udmVyc2F0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb252ZXJzYXRpb24gPSBhd2FpdCBjcmVhdGVDb252ZXJzYXRpb24odXNlci51c2VyX2lkKTtcbiAgICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgbmV3IGNvbnZlcnNhdGlvbiAke2NvbnZlcnNhdGlvbi5jb252ZXJzYXRpb25faWR9LiBQcmVwYXJpbmcgc3lzdGVtIHByb21wdC5gKTtcbiAgICAgICAgLy8gUHJlcGFyZSBzeXN0ZW0gcHJvbXB0ICh3aWxsIGJlIGFkZGVkIGxhdGVyIGFmdGVyIGNoZWNraW5nIGZvciBwcmVmcylcbiAgICAgICAgbGV0IHN5c3RlbVByb21wdENvbnRlbnQgPSBnZXRBdGhlbmFTeXN0ZW1Qcm9tcHQoKTsgXG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGJhc2Ugc3lzdGVtIHByb21wdCBpbiBEQiBmaXJzdFxuICAgICAgICBhd2FpdCBhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24oY29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZCwgXCJzeXN0ZW1cIiwgc3lzdGVtUHJvbXB0Q29udGVudCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHVzZXIgcHJlZmVyZW5jZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgZ2V0dGluZyB0aGUgYmFzZSBwcm9tcHRcbiAgICAgICAgaWYgKHVzZXIuVXNlclByZWZlcmVuY2U/LnByZWZlcmVuY2VzX2RhdGEgJiYgT2JqZWN0LmtleXModXNlci5Vc2VyUHJlZmVyZW5jZS5wcmVmZXJlbmNlc19kYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZzRGF0YSA9IHVzZXIuVXNlclByZWZlcmVuY2UucHJlZmVyZW5jZXNfZGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgcHJlZnNTdHJpbmcgPSBcIlxcblxcblVzZXIgUHJlZmVyZW5jZXMgQ29udGV4dCAoQ29uc2lkZXIgd2hlbiByZWxldmFudCk6XFxuXCI7XG4gICAgICAgICAgICAgICAgcHJlZnNTdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkocHJlZnNEYXRhLCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICBzeXN0ZW1Qcm9tcHRDb250ZW50ICs9IHByZWZzU3RyaW5nOyAvLyBBcHBlbmQgcHJlZmVyZW5jZXMgdG8gdGhlIG1haW4gcHJvbXB0XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBcHBlbmRlZCB1c2VyIHByZWZlcmVuY2VzIGNvbnRleHQgdG8gc3lzdGVtIHByb21wdC5cIik7XG4gICAgICAgICAgICB9IGNhdGNoIChwcmVmc0Vycm9yKSB7IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhZGRpbmcgcHJlZmVyZW5jZXMgY29udGV4dDpcIiwgcHJlZnNFcnJvcik7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgcG90ZW50aWFsbHkgY29tYmluZWQgc3lzdGVtIHByb21wdCB0byB0aGUgU1RBUlQgb2YgdGhlIGxvY2FsIGhpc3RvcnkgYXJyYXlcbiAgICAgICAgaGlzdG9yeU1lc3NhZ2VzLnVuc2hpZnQoeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBzeXN0ZW1Qcm9tcHRDb250ZW50IH0pO1xuXG4gICAgICB9IGNhdGNoIChjcmVhdGVFcnJvcikge1xuICAgICAgICAgY29uc29sZS5lcnJvcihcIkNSSVRJQ0FMOiBGYWlsZWQgdG8gY3JlYXRlIGNvbnZlcnNhdGlvbjpcIiwgY3JlYXRlRXJyb3IpO1xuICAgICAgICAgc3RyZWFtQ2FsbGJhY2s/Lih7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IFwiRmFpbGVkIHRvIHN0YXJ0IGNoYXQgc2Vzc2lvbi5cIiB9KTtcbiAgICAgICAgIHJldHVybiBcIkVycm9yOiBDb3VsZCBub3Qgc3RhcnQgY2hhdCBzZXNzaW9uLlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLSBQcmVwYXJlIG1lc3NhZ2VzIGZvciBBUEkgLS0tXG4gICAgY29uc3QgY3VycmVudE1lc3NhZ2VzID0gWy4uLmhpc3RvcnlNZXNzYWdlc107IC8vIFN0YXJ0IHdpdGggaGlzdG9yeSAoaW5jbCBzeXMgcHJvbXB0IGlmIG5ldylcblxuICAgIC8vIEFkZCBjdXJyZW50IHVzZXIgaW5wdXRcbiAgICBjb25zdCB1c2VyTWVzc2FnZUZvckFQSSA9IHsgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHVzZXJJbnB1dCB9O1xuICAgIGN1cnJlbnRNZXNzYWdlcy5wdXNoKHVzZXJNZXNzYWdlRm9yQVBJKTtcblxuICAgIC8vIFN0b3JlIHVzZXIgbWVzc2FnZSBpbiBEQiByZWxpYWJseVxuICAgICB0cnkge1xuICAgICAgICBhd2FpdCBhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24oY29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZCwgXCJ1c2VyXCIsIHVzZXJJbnB1dCk7XG4gICAgIH0gY2F0Y2goZGJFcnJvcikge1xuICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHN0b3JpbmcgdXNlciBtZXNzYWdlOlwiLCBkYkVycm9yKTtcbiAgICAgICAgIC8vIE5vbi1jcml0aWNhbD8gTG9nIGFuZCBjb250aW51ZS5cbiAgICAgfVxuXG4gICAgLy8gLS0tIFJ1biB0aGUgY29udmVyc2F0aW9uIGxvZ2ljIC0tLVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnVuQ29udmVyc2F0aW9uKFxuICAgICAgY3VycmVudE1lc3NhZ2VzLFxuICAgICAgdXNlcklucHV0LFxuICAgICAgY29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZCxcbiAgICAgIHVzZXIudXNlcl9pZCwgLy8gUGFzcyBVVUlEXG4gICAgICBhY2Nlc3NUb2tlbixcbiAgICAgIHN0cmVhbUNhbGxiYWNrXG4gICAgKTtcblxuICAgIC8vIElmIG5vdCBzdHJlYW1pbmcsIHJldHVybiB0aGUgcmVzcG9uc2UuXG4gICAgLy8gSWYgc3RyZWFtaW5nLCBydW5Db252ZXJzYXRpb24gaGFuZGxlcyBzZW5kaW5nIHZpYSBjYWxsYmFjaywgc28gd2UgbWlnaHQganVzdCByZXR1cm4gdm9pZCBvciB0cnVlL2ZhbHNlXG4gICAgaWYgKCFzdHJlYW1DYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7IC8vIEZpbmFsIHRleHQgcmVzcG9uc2UgZm9yIG5vbi1zdHJlYW1pbmdcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdHJlYW1pbmcgaGFuZGxlZCBieSBydW5Db252ZXJzYXRpb24ncyBjYWxsYmFja3NcbiAgICAgICAgIC8vIEVuc3VyZSAnZW5kJyB3YXMgc2VudCBpZiBhbiBlcnJvciBvY2N1cnJlZCB3aXRoaW4gcnVuQ29udmVyc2F0aW9uIGJlZm9yZSBjb21wbGV0aW9uXG4gICAgICAgICAvLyAocnVuQ29udmVyc2F0aW9uIHNob3VsZCBpZGVhbGx5IGhhbmRsZSBzZW5kaW5nICdlbmQnIG9yICdlcnJvcicgaW4gbW9zdCBjYXNlcylcbiAgICAgICAgIHJldHVybjsgLy8gSW5kaWNhdGUgc3VjY2VzcyBvciBzaW1wbHkgY29tcGxldGUgZm9yIHN0cmVhbWluZ1xuICAgIH1cblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBtYWluIGNoYXQgZnVuY3Rpb246XCIsIGVycm9yKTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZDogJHtlcnJvci5tZXNzYWdlIHx8IFwiUGxlYXNlIHRyeSBhZ2Fpbi5cIn1gO1xuICAgIC8vIEVuc3VyZSAnZW5kJyBvciAnZXJyb3InIGlzIHNlbnQgaW4gY2FzZSBvZiB0b3AtbGV2ZWwgZmFpbHVyZVxuICAgIHN0cmVhbUNhbGxiYWNrPy4oeyB0eXBlOiAnZXJyb3InLCBjb250ZW50OiBlcnJvck1lc3NhZ2UgfSk7XG4gICAgc3RyZWFtQ2FsbGJhY2s/Lih7IHR5cGU6ICdlbmQnIH0pOyAvLyBTZW5kIGVuZCBzaWduYWwgYWZ0ZXIgZXJyb3IgaW4gc3RyZWFtaW5nIG1vZGVcbiAgICByZXR1cm4gZXJyb3JNZXNzYWdlOyAvLyBSZXR1cm4gZXJyb3Igc3RyaW5nIGZvciBub24tc3RyZWFtaW5nXG4gIH1cbn1cblxuXG4vLyAtLS0gRXhwb3J0cyAtLS1cbmV4cG9ydCB7XG4gICAgY2hhdCBhcyBkZWZhdWx0LFxuICAgIGxpc3RUb2RheXNFdmVudHMsXG4gICAgc3VnZ2VzdEV2ZW50VGltZSxcbiAgICBnZXRDb252ZXJzYXRpb25zQnlVc2VySWRcbn07Il0sIm5hbWVzIjpbIk9wZW5BSSIsIkRhdGVUaW1lIiwiTm9kZUNhY2hlIiwiZ2V0QXRoZW5hU3lzdGVtUHJvbXB0IiwiZmluZEF2YWlsYWJsZVNsb3RzIiwiZmluZEF2YWlsYWJsZVNsb3RzVXRpbCIsImZvcm1hdEF2YWlsYWJsZVNsb3RzIiwibGlzdFRvZGF5c0V2ZW50cyIsInN1Z2dlc3RFdmVudFRpbWUiLCJ0b29scyIsInRvb2xGdW5jdGlvbnMiLCJnZXRPckNyZWF0ZVVzZXIiLCJjcmVhdGVDb252ZXJzYXRpb24iLCJDb252ZXJzYXRpb25NZXNzYWdlIiwiYWRkTWVzc2FnZVRvQ29udmVyc2F0aW9uIiwiaW5pdGlhbGl6ZURhdGFiYXNlIiwiZ2V0Q29udmVyc2F0aW9uc0J5VXNlcklkIiwiZ2V0VXNlcldpdGhMYXRlc3RDb252ZXJzYXRpb24iLCJVc2VyUHJlZmVyZW5jZSIsImdvb2dsZSIsInJlcXVpcmUiLCJkYkluaXRQcm9taXNlIiwib3BlbmFpIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk9QRU5BSV9BUElfS0VZIiwiZm9ybWF0RXZlbnRUaW1lIiwiZXZlbnRUaW1lIiwiZHQiLCJmcm9tSVNPIiwiaXNWYWxpZCIsInRvTG9jYWxlU3RyaW5nIiwiREFURVRJTUVfRlVMTCIsImRhdGVPbmx5Iiwiem9uZSIsIkRBVEVfRlVMTCIsImUiLCJjb25zb2xlIiwid2FybiIsIlN0cmluZyIsImZvcm1hdENhbGVuZGFyRXZlbnRzIiwiZXZlbnRzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwibWFwIiwiZXZlbnQiLCJzdGFydCIsImRhdGVUaW1lIiwiZGF0ZSIsImVuZCIsInN1bW1hcnkiLCJpZCIsImlzQWxsRGF5IiwiZm9ybWF0dGVkRXZlbnQiLCJUSU1FX1NJTVBMRSIsImRlc2NyaXB0aW9uIiwibG9jYXRpb24iLCJyZW1pbmRlcnMiLCJ1c2VEZWZhdWx0Iiwib3ZlcnJpZGVzIiwiciIsIm1pbnV0ZXMiLCJqb2luIiwidHJpbSIsIm1hcEVycm9yIiwiZXJyb3IiLCJmb3JtYXRUb29sUmVzcG9uc2UiLCJmdW5jdGlvbk5hbWUiLCJyZXN1bHQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJzdWNjZXNzIiwibWVzc2FnZSIsIml0ZW0iLCJjb25mbGljdCIsInN1Z2dlc3Rpb25UZXh0Iiwic3VnZ2VzdGlvbnMiLCJzIiwidG9Gb3JtYXQiLCJzdGFydFN0ciIsImV2ZW50SWQiLCJlcnJvck1zZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb3JtYXR0ZWRTbG90cyIsInNsb3QiLCJEQVRFVElNRV9TSE9SVCIsImZvcmVjYXN0IiwiaW5jbHVkZXMiLCJkZWxldGVkQ291bnQiLCJzdGF0dXMiLCJmb3JtYXRFcnJvciIsInByb2Nlc3NUb29sQ2FsbHMiLCJ0b29sQ2FsbHMiLCJtZXNzYWdlcyIsImNvbnZlcnNhdGlvbklkIiwidXNlcklkIiwiYWNjZXNzVG9rZW4iLCJsb2ciLCJ0b29sUHJvbWlzZXMiLCJ0b29sQ2FsbCIsInRvb2xDYWxsSWQiLCJmdW5jdGlvbiIsIm5hbWUiLCJ0b29sUmVzcG9uc2VDb250ZW50IiwidHlwZSIsIkVycm9yIiwicGFyc2VkQXJncyIsInBhcnNlIiwiYXJndW1lbnRzIiwicGFyc2VFcnJvciIsInN1Y2Nlc3NJbmRpY2F0b3IiLCJ2YWx1ZSIsInJvbGUiLCJjb250ZW50IiwidG9vbF9jYWxsX2lkIiwicmVhc29uIiwic2V0dGxlZFRvb2xSZXN1bHRzIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJ0b29sUmVzcG9uc2VzIiwic2V0dGxlZFJlc3VsdCIsImZpbHRlciIsIkJvb2xlYW4iLCJwdXNoIiwiYWxsIiwidG9vbE1zZyIsImNhdGNoIiwiZGJFcnJvciIsImJhdGNoRXJyb3IiLCJyZXNwb25zZUNhbGxiYWNrIiwicnVuQ29udmVyc2F0aW9uIiwidXNlcklucHV0IiwibW9kZWwiLCJtYXhUb29sSXRlcmF0aW9ucyIsImN1cnJlbnRNZXNzYWdlcyIsIml0ZXJhdGlvbiIsImZpbmFsQ29udGVudCIsImZpbHRlck1lc3NhZ2VzRm9yQVBJIiwibXNncyIsImZpbHRlcmVkTXNncyIsInZhbGlkVG9vbENhbGxJZHMiLCJTZXQiLCJmb3JFYWNoIiwibXNnIiwidG9vbF9jYWxscyIsImFkZCIsImluZGV4IiwiaGFzIiwiZmluYWxGaWx0ZXJlZCIsImkiLCJjdXJyZW50TXNnIiwicHJldk1zZyIsIm1lc3NhZ2VzRm9yQVBJIiwic3Vic3RyaW5nIiwidGMiLCJyZXNwb25zZSIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsInRvb2xfY2hvaWNlIiwicmVzcG9uc2VNZXNzYWdlIiwiY2hvaWNlcyIsImFzc2lzdGFudFRvb2xDYWxscyIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiaGFzQ3JpdGljYWxGYWlsdXJlIiwic29tZSIsInRyIiwibGFzdEFzc2lzdGFudE1zZyIsImVycm9yTWVzc2FnZSIsInN0cmVhbUNhbGxiYWNrIiwic3RhcnROZXdDb252ZXJzYXRpb24iLCJ0b2tlbnMiLCJhY2Nlc3NfdG9rZW4iLCJ1c2VyIiwiY29udmVyc2F0aW9uIiwiaGlzdG9yeU1lc3NhZ2VzIiwiQ29udmVyc2F0aW9ucyIsImNvbnZlcnNhdGlvbl9pZCIsIkNvbnZlcnNhdGlvbk1lc3NhZ2VzIiwic29ydCIsImEiLCJiIiwic2VxdWVuY2VfbnVtYmVyIiwiYWxsTXNncyIsIm1lc3NhZ2VPYmplY3QiLCJ2YWxpZFRvb2xDYWxsc0V4aXN0IiwidG9vbENhbGxzQXJyYXkiLCJ2YWxpZFRvb2xDYWxscyIsIm1lc3NhZ2VfaWQiLCJ0b29sSWQiLCJpc0VtYWlsIiwiZW1haWwiLCJwcm92aWRlciIsInVzZXJFcnJvciIsInVzZXJfaWQiLCJzeXN0ZW1Qcm9tcHRDb250ZW50IiwicHJlZmVyZW5jZXNfZGF0YSIsIk9iamVjdCIsImtleXMiLCJwcmVmc0RhdGEiLCJwcmVmc1N0cmluZyIsInByZWZzRXJyb3IiLCJ1bnNoaWZ0IiwiY3JlYXRlRXJyb3IiLCJ1c2VyTWVzc2FnZUZvckFQSSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/chatbot.js\n");

/***/ }),

/***/ "(api)/./lib/data/prompts.js":
/*!*****************************!*\
  !*** ./lib/data/prompts.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAthenaSystemPrompt: () => (/* binding */ getAthenaSystemPrompt)\n/* harmony export */ });\nfunction getAthenaSystemPrompt() {\n    const currentDate = new Date().toISOString();\n    // ADDED GUIDANCE for multi-step thinking\n    return `You are Athena, a highly intelligent and proactive personal assistant AI. Current date and time is ${currentDate}. Your goal is to understand the user's intent and take the most helpful action using the available tools.\n  **Core Instructions:**\n1.  **Think Step-by-Step:** Before acting or giving a final answer, break down the user's request.\n2.  **Gather Information:** If necessary, use tools like 'getCalendarEvents' to check the user's schedule or context *before* making changes or commitments.\n3.  **Analyze & Verify:** Review the information gathered. Check for conflicts, feasibility, or ambiguities. Does the request make sense in the current context?\n4.  **Execute or Clarify:**\n  *   If the request is clear and feasible after your analysis, use the appropriate tool (e.g., 'addCalendarEvents', 'updateCalendarEvent', 'deleteCalendarEvent').\n  *   If information is missing, the request is ambiguous, or there's a conflict you cannot resolve, *ask the user clarifying questions* instead of making assumptions or failing silently.\n  *   If you cannot fulfill the request, clearly explain why.\n5.  **Confirm Actions:** After successfully using a tool that modifies data (add, update, delete), confirm the action with the user and mention any relevant context you discovered (e.g., \"Okay, I've scheduled your meeting for 5 PM tomorrow. Just a heads-up, it's right after your 'Project Deadline' block.\").\n6.  **Be Proactive:** If you notice potential issues or helpful connections (e.g., scheduling near another event), mention them.\n7.  **Tool Usage:** Use the provided tools ONLY when necessary and with correctly formatted arguments (especially ISO 8601 dates/times like 'YYYY-MM-DDTHH:mm:ssZ' or 'YYYY-MM-DDTHH:mm:ss-HH:MM'). Resolve relative times ('tomorrow 5pm') to absolute ISO strings based on the current date/time before calling tools. Default duration for events is 1 hour if not specified. For \\`addCalendarEvents\\`, always check for conflicts first using \\`getCalendarEvents\\` for the relevant time range.`;\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvZGF0YS9wcm9tcHRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE1BQU1DLGNBQWMsSUFBSUMsT0FBT0MsV0FBVztJQUMxQyx5Q0FBeUM7SUFDekMsT0FBTyxDQUFDLG1HQUFtRyxFQUFFRixZQUFZOzs7Ozs7Ozs7OztxZUFXMFcsQ0FBQztBQUN0ZSIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi9kYXRhL3Byb21wdHMuanM/Njc5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2V0QXRoZW5hU3lzdGVtUHJvbXB0KCkge1xuICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgLy8gQURERUQgR1VJREFOQ0UgZm9yIG11bHRpLXN0ZXAgdGhpbmtpbmdcbiAgcmV0dXJuIGBZb3UgYXJlIEF0aGVuYSwgYSBoaWdobHkgaW50ZWxsaWdlbnQgYW5kIHByb2FjdGl2ZSBwZXJzb25hbCBhc3Npc3RhbnQgQUkuIEN1cnJlbnQgZGF0ZSBhbmQgdGltZSBpcyAke2N1cnJlbnREYXRlfS4gWW91ciBnb2FsIGlzIHRvIHVuZGVyc3RhbmQgdGhlIHVzZXIncyBpbnRlbnQgYW5kIHRha2UgdGhlIG1vc3QgaGVscGZ1bCBhY3Rpb24gdXNpbmcgdGhlIGF2YWlsYWJsZSB0b29scy5cbiAgKipDb3JlIEluc3RydWN0aW9uczoqKlxuMS4gICoqVGhpbmsgU3RlcC1ieS1TdGVwOioqIEJlZm9yZSBhY3Rpbmcgb3IgZ2l2aW5nIGEgZmluYWwgYW5zd2VyLCBicmVhayBkb3duIHRoZSB1c2VyJ3MgcmVxdWVzdC5cbjIuICAqKkdhdGhlciBJbmZvcm1hdGlvbjoqKiBJZiBuZWNlc3NhcnksIHVzZSB0b29scyBsaWtlICdnZXRDYWxlbmRhckV2ZW50cycgdG8gY2hlY2sgdGhlIHVzZXIncyBzY2hlZHVsZSBvciBjb250ZXh0ICpiZWZvcmUqIG1ha2luZyBjaGFuZ2VzIG9yIGNvbW1pdG1lbnRzLlxuMy4gICoqQW5hbHl6ZSAmIFZlcmlmeToqKiBSZXZpZXcgdGhlIGluZm9ybWF0aW9uIGdhdGhlcmVkLiBDaGVjayBmb3IgY29uZmxpY3RzLCBmZWFzaWJpbGl0eSwgb3IgYW1iaWd1aXRpZXMuIERvZXMgdGhlIHJlcXVlc3QgbWFrZSBzZW5zZSBpbiB0aGUgY3VycmVudCBjb250ZXh0P1xuNC4gICoqRXhlY3V0ZSBvciBDbGFyaWZ5OioqXG4gICogICBJZiB0aGUgcmVxdWVzdCBpcyBjbGVhciBhbmQgZmVhc2libGUgYWZ0ZXIgeW91ciBhbmFseXNpcywgdXNlIHRoZSBhcHByb3ByaWF0ZSB0b29sIChlLmcuLCAnYWRkQ2FsZW5kYXJFdmVudHMnLCAndXBkYXRlQ2FsZW5kYXJFdmVudCcsICdkZWxldGVDYWxlbmRhckV2ZW50JykuXG4gICogICBJZiBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nLCB0aGUgcmVxdWVzdCBpcyBhbWJpZ3VvdXMsIG9yIHRoZXJlJ3MgYSBjb25mbGljdCB5b3UgY2Fubm90IHJlc29sdmUsICphc2sgdGhlIHVzZXIgY2xhcmlmeWluZyBxdWVzdGlvbnMqIGluc3RlYWQgb2YgbWFraW5nIGFzc3VtcHRpb25zIG9yIGZhaWxpbmcgc2lsZW50bHkuXG4gICogICBJZiB5b3UgY2Fubm90IGZ1bGZpbGwgdGhlIHJlcXVlc3QsIGNsZWFybHkgZXhwbGFpbiB3aHkuXG41LiAgKipDb25maXJtIEFjdGlvbnM6KiogQWZ0ZXIgc3VjY2Vzc2Z1bGx5IHVzaW5nIGEgdG9vbCB0aGF0IG1vZGlmaWVzIGRhdGEgKGFkZCwgdXBkYXRlLCBkZWxldGUpLCBjb25maXJtIHRoZSBhY3Rpb24gd2l0aCB0aGUgdXNlciBhbmQgbWVudGlvbiBhbnkgcmVsZXZhbnQgY29udGV4dCB5b3UgZGlzY292ZXJlZCAoZS5nLiwgXCJPa2F5LCBJJ3ZlIHNjaGVkdWxlZCB5b3VyIG1lZXRpbmcgZm9yIDUgUE0gdG9tb3Jyb3cuIEp1c3QgYSBoZWFkcy11cCwgaXQncyByaWdodCBhZnRlciB5b3VyICdQcm9qZWN0IERlYWRsaW5lJyBibG9jay5cIikuXG42LiAgKipCZSBQcm9hY3RpdmU6KiogSWYgeW91IG5vdGljZSBwb3RlbnRpYWwgaXNzdWVzIG9yIGhlbHBmdWwgY29ubmVjdGlvbnMgKGUuZy4sIHNjaGVkdWxpbmcgbmVhciBhbm90aGVyIGV2ZW50KSwgbWVudGlvbiB0aGVtLlxuNy4gICoqVG9vbCBVc2FnZToqKiBVc2UgdGhlIHByb3ZpZGVkIHRvb2xzIE9OTFkgd2hlbiBuZWNlc3NhcnkgYW5kIHdpdGggY29ycmVjdGx5IGZvcm1hdHRlZCBhcmd1bWVudHMgKGVzcGVjaWFsbHkgSVNPIDg2MDEgZGF0ZXMvdGltZXMgbGlrZSAnWVlZWS1NTS1ERFRISDptbTpzc1onIG9yICdZWVlZLU1NLUREVEhIOm1tOnNzLUhIOk1NJykuIFJlc29sdmUgcmVsYXRpdmUgdGltZXMgKCd0b21vcnJvdyA1cG0nKSB0byBhYnNvbHV0ZSBJU08gc3RyaW5ncyBiYXNlZCBvbiB0aGUgY3VycmVudCBkYXRlL3RpbWUgYmVmb3JlIGNhbGxpbmcgdG9vbHMuIERlZmF1bHQgZHVyYXRpb24gZm9yIGV2ZW50cyBpcyAxIGhvdXIgaWYgbm90IHNwZWNpZmllZC4gRm9yIFxcYGFkZENhbGVuZGFyRXZlbnRzXFxgLCBhbHdheXMgY2hlY2sgZm9yIGNvbmZsaWN0cyBmaXJzdCB1c2luZyBcXGBnZXRDYWxlbmRhckV2ZW50c1xcYCBmb3IgdGhlIHJlbGV2YW50IHRpbWUgcmFuZ2UuYDtcbn07XG4iXSwibmFtZXMiOlsiZ2V0QXRoZW5hU3lzdGVtUHJvbXB0IiwiY3VycmVudERhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/data/prompts.js\n");

/***/ }),

/***/ "(api)/./lib/postgresClient.js":
/*!*******************************!*\
  !*** ./lib/postgresClient.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CalendarEventMetadata: () => (/* binding */ CalendarEventMetadata),\n/* harmony export */   Conversation: () => (/* binding */ Conversation),\n/* harmony export */   ConversationMessage: () => (/* binding */ ConversationMessage),\n/* harmony export */   User: () => (/* binding */ User),\n/* harmony export */   UserPreference: () => (/* binding */ UserPreference),\n/* harmony export */   addMessageToConversation: () => (/* binding */ addMessageToConversation),\n/* harmony export */   createConversation: () => (/* binding */ createConversation),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getConversation: () => (/* binding */ getConversation),\n/* harmony export */   getConversationMessages: () => (/* binding */ getConversationMessages),\n/* harmony export */   getConversationsByUserId: () => (/* binding */ getConversationsByUserId),\n/* harmony export */   getOrCreateUser: () => (/* binding */ getOrCreateUser),\n/* harmony export */   getUserWithLatestConversation: () => (/* binding */ getUserWithLatestConversation),\n/* harmony export */   initializeDatabase: () => (/* binding */ initializeDatabase),\n/* harmony export */   sequelize: () => (/* binding */ sequelize)\n/* harmony export */ });\n/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sequelize */ \"sequelize\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dotenv/config */ \"dotenv/config\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dotenv_config__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([sequelize__WEBPACK_IMPORTED_MODULE_0__]);\nsequelize__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n// Create PostgreSQL connection\nconst sequelize = new sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize({\n    dialect: \"postgres\",\n    host: process.env.POSTGRES_HOST || \"localhost\",\n    port: process.env.POSTGRES_PORT || 5432,\n    username: process.env.POSTGRES_USER || \"postgres\",\n    password: process.env.POSTGRES_PASSWORD || \"postgres\",\n    database: process.env.POSTGRES_DB || \"gcalendarapp\",\n    logging:  true ? console.log : 0,\n    dialectOptions: {\n        ssl: process.env.POSTGRES_SSL === \"true\" ? {\n            require: true,\n            rejectUnauthorized: false\n        } : false\n    },\n    pool: {\n        max: 5,\n        min: 0,\n        acquire: 30000,\n        idle: 10000\n    }\n});\n// Define models based on the provided schema\nconst User = sequelize.define(\"User\", {\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    email: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false,\n        unique: true\n    },\n    name: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n    avatar_url: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    auth_provider: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(50),\n        allowNull: false\n    },\n    auth_provider_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false\n    },\n    timezone: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(100),\n        allowNull: false,\n        defaultValue: \"UTC\"\n    },\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"users\",\n    timestamps: false,\n    indexes: [\n        {\n            unique: true,\n            fields: [\n                \"auth_provider\",\n                \"auth_provider_id\"\n            ]\n        }\n    ]\n});\nconst UserPreference = sequelize.define(\"UserPreference\", {\n    preference_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"users\",\n            key: \"user_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    preferences_data: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.JSONB,\n        allowNull: false,\n        defaultValue: {}\n    },\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"user_preferences\",\n    timestamps: false,\n    indexes: [\n        {\n            fields: [\n                \"user_id\"\n            ]\n        }\n    ]\n});\nconst Conversation = sequelize.define(\"Conversation\", {\n    conversation_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"users\",\n            key: \"user_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    start_time: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    summary: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"conversations\",\n    timestamps: false,\n    indexes: [\n        {\n            fields: [\n                \"user_id\"\n            ]\n        }\n    ]\n});\nconst ConversationMessage = sequelize.define(\"ConversationMessage\", {\n    message_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    conversation_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"conversations\",\n            key: \"conversation_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    sequence_number: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.INTEGER,\n        allowNull: false\n    },\n    role: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(20),\n        allowNull: false,\n        validate: {\n            isIn: [\n                [\n                    \"user\",\n                    \"assistant\",\n                    \"system\",\n                    \"tool\"\n                ]\n            ]\n        }\n    },\n    content: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n        // Allow null content for assistant messages that ONLY make tool calls\n        allowNull: true // CHANGED: Allow null content\n    },\n    // --- NEW/MODIFIED Fields ---\n    tool_calls: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.JSONB,\n        allowNull: true\n    },\n    tool_call_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n        allowNull: true\n    },\n    // --- REMOVED Fields (redundant if tool_calls is stored) ---\n    // tool_call_name: DataTypes.TEXT,\n    // tool_call_args: DataTypes.JSONB,\n    // tool_response_content: DataTypes.TEXT, // Content field is used for tool response\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"conversation_messages\",\n    timestamps: false,\n    indexes: [\n        // Keep existing indexes if they make sense\n        {\n            fields: [\n                \"conversation_id\",\n                \"created_at\"\n            ]\n        },\n        {\n            fields: [\n                \"conversation_id\",\n                \"sequence_number\"\n            ]\n        },\n        // Add index for tool_call_id if needed for lookups\n        {\n            fields: [\n                \"tool_call_id\"\n            ]\n        }\n    ]\n});\nconst CalendarEventMetadata = sequelize.define(\"CalendarEventMetadata\", {\n    metadata_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"users\",\n            key: \"user_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    google_calendar_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false,\n        defaultValue: \"primary\"\n    },\n    google_event_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false\n    },\n    priority: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(20),\n        validate: {\n            isIn: [\n                [\n                    \"Low\",\n                    \"Medium\",\n                    \"High\",\n                    \"Urgent\"\n                ]\n            ]\n        }\n    },\n    deadline: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    task_status: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(30),\n        validate: {\n            isIn: [\n                [\n                    \"Not Started\",\n                    \"In Progress\",\n                    \"Completed\",\n                    \"Blocked\",\n                    \"Deferred\"\n                ]\n            ]\n        }\n    },\n    event_summary_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    start_time_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    end_time_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    location_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    last_synced_at: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"calendar_event_metadata\",\n    timestamps: false,\n    indexes: [\n        {\n            unique: true,\n            fields: [\n                \"user_id\",\n                \"google_calendar_id\",\n                \"google_event_id\"\n            ]\n        },\n        {\n            fields: [\n                \"user_id\",\n                \"deadline\"\n            ]\n        },\n        {\n            fields: [\n                \"user_id\",\n                \"priority\"\n            ]\n        }\n    ]\n});\n// Define relationships\nUser.hasMany(Conversation, {\n    foreignKey: \"user_id\"\n});\nConversation.belongsTo(User, {\n    foreignKey: \"user_id\"\n});\nUser.hasOne(UserPreference, {\n    foreignKey: \"user_id\"\n});\nUserPreference.belongsTo(User, {\n    foreignKey: \"user_id\"\n});\nConversation.hasMany(ConversationMessage, {\n    foreignKey: \"conversation_id\"\n});\nConversationMessage.belongsTo(Conversation, {\n    foreignKey: \"conversation_id\"\n});\nUser.hasMany(CalendarEventMetadata, {\n    foreignKey: \"user_id\"\n});\nCalendarEventMetadata.belongsTo(User, {\n    foreignKey: \"user_id\"\n});\n// Helper functions for conversation management\nasync function initializeDatabase() {\n    try {\n        // Test connection\n        try {\n            await sequelize.authenticate();\n            console.log(\"PostgreSQL connection has been established successfully.\");\n        } catch (error) {\n            console.error(\"Unable to connect to the database:\", error);\n            console.log(\"Make sure PostgreSQL is running and the database exists.\");\n            console.log(\"You can create the database by running: npm run init-postgres\");\n            throw new Error(\"Database connection failed. See above for details.\");\n        }\n        try {\n            // Create extension for UUID generation if it doesn't exist\n            await sequelize.query('CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";');\n            console.log(\"UUID extension enabled successfully.\");\n        } catch (error) {\n            console.error(\"Error creating UUID extension:\", error);\n            throw error;\n        }\n        try {\n            // Create timestamp trigger function if it doesn't exist\n            await sequelize.query(`\n        CREATE OR REPLACE FUNCTION trigger_set_timestamp()\n        RETURNS TRIGGER AS $$\n        BEGIN\n          NEW.updated_at = NOW();\n          RETURN NEW;\n        END;\n        $$ LANGUAGE plpgsql;\n      `);\n            console.log(\"Timestamp trigger function created successfully.\");\n        } catch (error) {\n            console.error(\"Error creating timestamp trigger function:\", error);\n            throw error;\n        }\n        try {\n            // Sync all models without force: true to avoid dropping tables\n            console.log(\"Synchronizing models (non-destructive)...\");\n            // Use { alter: true } to apply schema changes non-destructively\n            await sequelize.sync({\n                alter: true\n            });\n            console.log(\"All models were synchronized successfully.\");\n        // Note: For production, database structure should be managed via migrations\n        // rather than automatic sync\n        } catch (error) {\n            console.error(\"Error synchronizing models:\", error);\n            throw error;\n        }\n        try {\n            // Check if tool_calls column exists in conversation_messages table\n            const checkColumnResult = await sequelize.query(`\n        SELECT column_name\n        FROM information_schema.columns\n        WHERE table_name = 'conversation_messages'\n        AND column_name = 'tool_calls';\n      `);\n            // If column doesn't exist, add it\n            if (checkColumnResult[0].length === 0) {\n                console.log(\"Adding missing tool_calls column to conversation_messages table...\");\n                await sequelize.query(`\n          ALTER TABLE conversation_messages\n          ADD COLUMN tool_calls JSONB;\n        `);\n                console.log(\"tool_calls column added successfully.\");\n            } else {\n                console.log(\"tool_calls column already exists in conversation_messages table.\");\n            }\n        } catch (error) {\n            console.error(\"Error checking or adding tool_calls column:\", error);\n            throw error;\n        }\n        try {\n            // Create triggers for updated_at timestamps\n            await sequelize.query(`\n        DO $$\n        BEGIN\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_users') THEN\n            CREATE TRIGGER set_timestamp_users\n            BEFORE UPDATE ON users\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_user_preferences') THEN\n            CREATE TRIGGER set_timestamp_user_preferences\n            BEFORE UPDATE ON user_preferences\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_conversations') THEN\n            CREATE TRIGGER set_timestamp_conversations\n            BEFORE UPDATE ON conversations\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_calendar_event_metadata') THEN\n            CREATE TRIGGER set_timestamp_calendar_event_metadata\n            BEFORE UPDATE ON calendar_event_metadata\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n        END\n        $$;\n      `);\n            console.log(\"Database triggers created successfully.\");\n        } catch (error) {\n            console.error(\"Error creating triggers:\", error);\n            throw error;\n        }\n        console.log(\"Database initialization completed successfully.\");\n    } catch (error) {\n        console.error(\"Unable to initialize database:\", error);\n        throw error;\n    }\n}\n// Conversation management functions\nasync function getOrCreateUser(email, name, authProvider, authProviderId, avatarUrl = null) {\n    try {\n        // First try to find the user by email\n        let user = await User.findOne({\n            where: {\n                email\n            }\n        });\n        if (user) {\n            // User exists, check if we need to update auth provider info\n            if (user.auth_provider !== authProvider || user.auth_provider_id !== authProviderId) {\n                // Only update if the auth provider info is different\n                console.log(`User with email ${email} exists but with different auth provider. Returning existing user.`);\n            }\n            return user;\n        }\n        // User doesn't exist, create a new one\n        user = await User.create({\n            email,\n            name,\n            auth_provider: authProvider,\n            auth_provider_id: authProviderId,\n            avatar_url: avatarUrl\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Error getting or creating user:\", error);\n        throw error;\n    }\n}\nasync function createConversation(userId) {\n    try {\n        // Check if userId is an email address\n        const isEmail = typeof userId === \"string\" && userId.includes(\"@\");\n        let actualUserId = userId;\n        // If userId is an email, find the user by email first to get the actual UUID\n        if (isEmail) {\n            const userByEmail = await User.findOne({\n                where: {\n                    email: userId\n                }\n            });\n            if (!userByEmail) {\n                console.log(`No user found with email: ${userId}`);\n                throw new Error(`Cannot create conversation: No user found with email: ${userId}`);\n            }\n            actualUserId = userByEmail.user_id;\n        }\n        const conversation = await Conversation.create({\n            user_id: actualUserId\n        });\n        return conversation;\n    } catch (error) {\n        console.error(\"Error creating conversation:\", error);\n        throw error;\n    }\n}\nasync function getConversation(conversationId) {\n    try {\n        return await Conversation.findByPk(conversationId, {\n            include: [\n                {\n                    model: ConversationMessage,\n                    order: [\n                        [\n                            \"sequence_number\",\n                            \"ASC\"\n                        ]\n                    ]\n                }\n            ]\n        });\n    } catch (error) {\n        console.error(\"Error getting conversation:\", error);\n        throw error;\n    }\n}\nasync function getConversationsByUserId(userId) {\n    try {\n        // Check if userId is an email address\n        const isEmail = typeof userId === \"string\" && userId.includes(\"@\");\n        let actualUserId = userId;\n        // If userId is an email, find the user by email first to get the actual UUID\n        if (isEmail) {\n            const userByEmail = await User.findOne({\n                where: {\n                    email: userId\n                }\n            });\n            if (!userByEmail) {\n                console.log(`No user found with email: ${userId}`);\n                return [];\n            }\n            actualUserId = userByEmail.user_id;\n        }\n        // Use EXPLAIN ANALYZE to understand query performance\n        if (true) {\n            const explainResult = await sequelize.query(`\n        EXPLAIN ANALYZE\n        SELECT * FROM conversations\n        WHERE user_id = '${actualUserId}'\n        ORDER BY created_at DESC\n      `);\n            console.log(\"Query execution plan:\", explainResult[0]);\n        }\n        return await Conversation.findAll({\n            where: {\n                user_id: actualUserId\n            },\n            order: [\n                [\n                    \"created_at\",\n                    \"DESC\"\n                ]\n            ]\n        });\n    } catch (error) {\n        console.error(\"Error getting conversations by user ID:\", error);\n        throw error;\n    }\n}\nasync function getConversationMessages(conversationId) {\n    try {\n        return await ConversationMessage.findAll({\n            where: {\n                conversation_id: conversationId\n            },\n            order: [\n                [\n                    \"sequence_number\",\n                    \"ASC\"\n                ]\n            ]\n        });\n    } catch (error) {\n        console.error(\"Error getting conversation messages:\", error);\n        throw error;\n    }\n}\nasync function addMessageToConversation(conversationId, role, content, { tool_calls = null, tool_call_id = null } = {} // Pass tool info as an object\n) {\n    try {\n        // Use a transaction for sequence number safety\n        const result = await sequelize.transaction(async (t)=>{\n            // Get the next sequence number within the transaction\n            const maxSequenceResult = await ConversationMessage.findOne({\n                attributes: [\n                    [\n                        sequelize.fn(\"max\", sequelize.col(\"sequence_number\")),\n                        \"maxSequence\"\n                    ]\n                ],\n                where: {\n                    conversation_id: conversationId\n                },\n                transaction: t,\n                raw: true\n            });\n            const maxSequence = maxSequenceResult?.maxSequence || 0;\n            // Create the message\n            const message = await ConversationMessage.create({\n                conversation_id: conversationId,\n                sequence_number: maxSequence + 1,\n                role,\n                content: content,\n                tool_calls: role === \"assistant\" ? tool_calls : null,\n                tool_call_id: role === \"tool\" ? tool_call_id : null\n            }, {\n                transaction: t\n            });\n            return message;\n        });\n        return result;\n    } catch (error) {\n        console.error(\"Error adding message to conversation:\", error);\n        // Log specific details if available\n        if (error.original) {\n            console.error(\"Original DB Error:\", error.original);\n        }\n        throw error; // Re-throw the error to be handled upstream\n    }\n}\n/**\n * Get user and their latest conversation in a single query\n * @param {string} userId - The user ID\n * @returns {Object} - User data with latest conversation\n */ async function getUserWithLatestConversation(userId) {\n    try {\n        // Check if userId is an email address\n        const isEmail = typeof userId === \"string\" && userId.includes(\"@\");\n        let actualUserId = userId;\n        // If userId is an email, find the user by email first to get the actual UUID\n        if (isEmail) {\n            const userByEmail = await User.findOne({\n                where: {\n                    email: userId\n                }\n            });\n            if (!userByEmail) {\n                console.log(`No user found with email: ${userId}`);\n                return null;\n            }\n            actualUserId = userByEmail.user_id;\n        }\n        // Use EXPLAIN ANALYZE to understand query performance\n        if (true) {\n            const explainResult = await sequelize.query(`\n        EXPLAIN ANALYZE\n        SELECT u.*, c.*\n        FROM users u\n        LEFT JOIN (\n          SELECT * FROM conversations\n          WHERE user_id = '${actualUserId}'\n          ORDER BY created_at DESC\n          LIMIT 1\n        ) c ON u.user_id = c.user_id\n        WHERE u.user_id = '${actualUserId}'\n      `);\n            console.log(\"Join query execution plan:\", explainResult[0]);\n        }\n        // Execute the actual query using Sequelize\n        const user = await User.findByPk(actualUserId, {\n            include: [\n                {\n                    model: Conversation,\n                    limit: 1,\n                    order: [\n                        [\n                            \"created_at\",\n                            \"DESC\"\n                        ]\n                    ],\n                    include: [\n                        {\n                            model: ConversationMessage,\n                            order: [\n                                [\n                                    \"sequence_number\",\n                                    \"DESC\"\n                                ]\n                            ],\n                            limit: 50,\n                            separate: true // This ensures all messages are loaded, not just one\n                        }\n                    ]\n                },\n                {\n                    model: UserPreference\n                }\n            ]\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Error getting user with latest conversation:\", error);\n        throw error;\n    }\n}\n// Export models and functions\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sequelize);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0g7Z0JBQ1Q7YUFDRDtRQUNIO1FBRUEsT0FBT21EO0lBQ1QsRUFBRSxPQUFPWCxPQUFPO1FBQ2Q3RSxRQUFRNkUsS0FBSyxDQUFDLGdEQUFnREE7UUFDOUQsTUFBTUE7SUFDUjtBQUNGO0FBRUEsOEJBQThCO0FBZ0I1QjtBQUVGLGlFQUFlNUYsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi9wb3N0Z3Jlc0NsaWVudC5qcz8zZDg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlcXVlbGl6ZSwgRGF0YVR5cGVzIH0gZnJvbSAnc2VxdWVsaXplJztcbmltcG9ydCAnZG90ZW52L2NvbmZpZyc7XG5cbi8vIENyZWF0ZSBQb3N0Z3JlU1FMIGNvbm5lY3Rpb25cbmNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoe1xuICBkaWFsZWN0OiAncG9zdGdyZXMnLFxuICBob3N0OiBwcm9jZXNzLmVudi5QT1NUR1JFU19IT1NUIHx8ICdsb2NhbGhvc3QnLFxuICBwb3J0OiBwcm9jZXNzLmVudi5QT1NUR1JFU19QT1JUIHx8IDU0MzIsXG4gIHVzZXJuYW1lOiBwcm9jZXNzLmVudi5QT1NUR1JFU19VU0VSIHx8ICdwb3N0Z3JlcycsXG4gIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5QT1NUR1JFU19QQVNTV09SRCB8fCAncG9zdGdyZXMnLFxuICBkYXRhYmFzZTogcHJvY2Vzcy5lbnYuUE9TVEdSRVNfREIgfHwgJ2djYWxlbmRhcmFwcCcsXG4gIGxvZ2dpbmc6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gY29uc29sZS5sb2cgOiBmYWxzZSxcbiAgZGlhbGVjdE9wdGlvbnM6IHtcbiAgICBzc2w6IHByb2Nlc3MuZW52LlBPU1RHUkVTX1NTTCA9PT0gJ3RydWUnID8ge1xuICAgICAgcmVxdWlyZTogdHJ1ZSxcbiAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2VcbiAgICB9IDogZmFsc2VcbiAgfSxcbiAgcG9vbDoge1xuICAgIG1heDogNSxcbiAgICBtaW46IDAsXG4gICAgYWNxdWlyZTogMzAwMDAsXG4gICAgaWRsZTogMTAwMDBcbiAgfVxufSk7XG5cbi8vIERlZmluZSBtb2RlbHMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHNjaGVtYVxuY29uc3QgVXNlciA9IHNlcXVlbGl6ZS5kZWZpbmUoJ1VzZXInLCB7XG4gIHVzZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIGVtYWlsOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyNTUpLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgdW5pcXVlOiB0cnVlXG4gIH0sXG4gIG5hbWU6IERhdGFUeXBlcy5TVFJJTkcoMjU1KSxcbiAgYXZhdGFyX3VybDogRGF0YVR5cGVzLlRFWFQsXG4gIGF1dGhfcHJvdmlkZXI6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuU1RSSU5HKDUwKSxcbiAgICBhbGxvd051bGw6IGZhbHNlXG4gIH0sXG4gIGF1dGhfcHJvdmlkZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuU1RSSU5HKDI1NSksXG4gICAgYWxsb3dOdWxsOiBmYWxzZVxuICB9LFxuICB0aW1lem9uZToge1xuICAgIHR5cGU6IERhdGFUeXBlcy5TVFJJTkcoMTAwKSxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogJ1VUQydcbiAgfSxcbiAgY3JlYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9LFxuICB1cGRhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAndXNlcnMnLFxuICB0aW1lc3RhbXBzOiBmYWxzZSxcbiAgaW5kZXhlczogW1xuICAgIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICAgIGZpZWxkczogWydhdXRoX3Byb3ZpZGVyJywgJ2F1dGhfcHJvdmlkZXJfaWQnXVxuICAgIH1cbiAgXVxufSk7XG5cbmNvbnN0IFVzZXJQcmVmZXJlbmNlID0gc2VxdWVsaXplLmRlZmluZSgnVXNlclByZWZlcmVuY2UnLCB7XG4gIHByZWZlcmVuY2VfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIHVzZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIHJlZmVyZW5jZXM6IHtcbiAgICAgIG1vZGVsOiAndXNlcnMnLFxuICAgICAga2V5OiAndXNlcl9pZCdcbiAgICB9LFxuICAgIG9uRGVsZXRlOiAnQ0FTQ0FERSdcbiAgfSxcbiAgcHJlZmVyZW5jZXNfZGF0YToge1xuICAgIHR5cGU6IERhdGFUeXBlcy5KU09OQixcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZToge31cbiAgfSxcbiAgY3JlYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9LFxuICB1cGRhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAndXNlcl9wcmVmZXJlbmNlcycsXG4gIHRpbWVzdGFtcHM6IGZhbHNlLFxuICBpbmRleGVzOiBbXG4gICAge1xuICAgICAgZmllbGRzOiBbJ3VzZXJfaWQnXVxuICAgIH1cbiAgXVxufSk7XG5cbmNvbnN0IENvbnZlcnNhdGlvbiA9IHNlcXVlbGl6ZS5kZWZpbmUoJ0NvbnZlcnNhdGlvbicsIHtcbiAgY29udmVyc2F0aW9uX2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlVVSUQsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgndXVpZF9nZW5lcmF0ZV92NCgpJyksXG4gICAgcHJpbWFyeUtleTogdHJ1ZVxuICB9LFxuICB1c2VyX2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlVVSUQsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICByZWZlcmVuY2VzOiB7XG4gICAgICBtb2RlbDogJ3VzZXJzJyxcbiAgICAgIGtleTogJ3VzZXJfaWQnXG4gICAgfSxcbiAgICBvbkRlbGV0ZTogJ0NBU0NBREUnXG4gIH0sXG4gIHN0YXJ0X3RpbWU6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogU2VxdWVsaXplLmxpdGVyYWwoJ05PVygpJylcbiAgfSxcbiAgc3VtbWFyeTogRGF0YVR5cGVzLlRFWFQsXG4gIGNyZWF0ZWRfYXQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogU2VxdWVsaXplLmxpdGVyYWwoJ05PVygpJylcbiAgfSxcbiAgdXBkYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9XG59LCB7XG4gIHRhYmxlTmFtZTogJ2NvbnZlcnNhdGlvbnMnLFxuICB0aW1lc3RhbXBzOiBmYWxzZSxcbiAgaW5kZXhlczogW1xuICAgIHtcbiAgICAgIGZpZWxkczogWyd1c2VyX2lkJ11cbiAgICB9XG4gIF1cbn0pO1xuY29uc3QgQ29udmVyc2F0aW9uTWVzc2FnZSA9IHNlcXVlbGl6ZS5kZWZpbmUoJ0NvbnZlcnNhdGlvbk1lc3NhZ2UnLCB7XG4gIG1lc3NhZ2VfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIGNvbnZlcnNhdGlvbl9pZDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5VVUlELFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgcmVmZXJlbmNlczoge1xuICAgICAgbW9kZWw6ICdjb252ZXJzYXRpb25zJyxcbiAgICAgIGtleTogJ2NvbnZlcnNhdGlvbl9pZCdcbiAgICB9LFxuICAgIG9uRGVsZXRlOiAnQ0FTQ0FERSdcbiAgfSxcbiAgc2VxdWVuY2VfbnVtYmVyOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLklOVEVHRVIsXG4gICAgYWxsb3dOdWxsOiBmYWxzZVxuICB9LFxuICByb2xlOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyMCksXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICB2YWxpZGF0ZToge1xuICAgICAgaXNJbjogW1sndXNlcicsICdhc3Npc3RhbnQnLCAnc3lzdGVtJywgJ3Rvb2wnXV1cbiAgICB9XG4gIH0sXG4gIGNvbnRlbnQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVEVYVCxcbiAgICAvLyBBbGxvdyBudWxsIGNvbnRlbnQgZm9yIGFzc2lzdGFudCBtZXNzYWdlcyB0aGF0IE9OTFkgbWFrZSB0b29sIGNhbGxzXG4gICAgYWxsb3dOdWxsOiB0cnVlIC8vIENIQU5HRUQ6IEFsbG93IG51bGwgY29udGVudFxuICB9LFxuICAvLyAtLS0gTkVXL01PRElGSUVEIEZpZWxkcyAtLS1cbiAgdG9vbF9jYWxsczoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5KU09OQiwgLy8gU3RvcmUgdGhlIGZ1bGwgdG9vbF9jYWxscyBhcnJheSBmcm9tIHRoZSBhc3Npc3RhbnRcbiAgICBhbGxvd051bGw6IHRydWVcbiAgfSxcbiAgdG9vbF9jYWxsX2lkOiB7IC8vIEtlZXAgdGhpcyBPTkxZIGZvciAndG9vbCcgcm9sZSBtZXNzYWdlcyB0byBsaW5rIHJlc3BvbnNlXG4gICAgdHlwZTogRGF0YVR5cGVzLlRFWFQsXG4gICAgYWxsb3dOdWxsOiB0cnVlXG4gIH0sXG4gIC8vIC0tLSBSRU1PVkVEIEZpZWxkcyAocmVkdW5kYW50IGlmIHRvb2xfY2FsbHMgaXMgc3RvcmVkKSAtLS1cbiAgLy8gdG9vbF9jYWxsX25hbWU6IERhdGFUeXBlcy5URVhULFxuICAvLyB0b29sX2NhbGxfYXJnczogRGF0YVR5cGVzLkpTT05CLFxuICAvLyB0b29sX3Jlc3BvbnNlX2NvbnRlbnQ6IERhdGFUeXBlcy5URVhULCAvLyBDb250ZW50IGZpZWxkIGlzIHVzZWQgZm9yIHRvb2wgcmVzcG9uc2VcblxuICBjcmVhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAnY29udmVyc2F0aW9uX21lc3NhZ2VzJyxcbiAgdGltZXN0YW1wczogZmFsc2UsIC8vIEFzc3VtaW5nIHlvdSBoYW5kbGUgdGltZXN0YW1wcyBtYW51YWxseSBvciB2aWEgdHJpZ2dlcnNcbiAgaW5kZXhlczogW1xuICAgIC8vIEtlZXAgZXhpc3RpbmcgaW5kZXhlcyBpZiB0aGV5IG1ha2Ugc2Vuc2VcbiAgICB7IGZpZWxkczogWydjb252ZXJzYXRpb25faWQnLCAnY3JlYXRlZF9hdCddIH0sXG4gICAgeyBmaWVsZHM6IFsnY29udmVyc2F0aW9uX2lkJywgJ3NlcXVlbmNlX251bWJlciddIH0sXG4gICAgLy8gQWRkIGluZGV4IGZvciB0b29sX2NhbGxfaWQgaWYgbmVlZGVkIGZvciBsb29rdXBzXG4gICAgeyBmaWVsZHM6IFsndG9vbF9jYWxsX2lkJ10gfVxuICBdXG59KTtcblxuXG5cbmNvbnN0IENhbGVuZGFyRXZlbnRNZXRhZGF0YSA9IHNlcXVlbGl6ZS5kZWZpbmUoJ0NhbGVuZGFyRXZlbnRNZXRhZGF0YScsIHtcbiAgbWV0YWRhdGFfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIHVzZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIHJlZmVyZW5jZXM6IHtcbiAgICAgIG1vZGVsOiAndXNlcnMnLFxuICAgICAga2V5OiAndXNlcl9pZCdcbiAgICB9LFxuICAgIG9uRGVsZXRlOiAnQ0FTQ0FERSdcbiAgfSxcbiAgZ29vZ2xlX2NhbGVuZGFyX2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyNTUpLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiAncHJpbWFyeSdcbiAgfSxcbiAgZ29vZ2xlX2V2ZW50X2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyNTUpLFxuICAgIGFsbG93TnVsbDogZmFsc2VcbiAgfSxcbiAgcHJpb3JpdHk6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuU1RSSU5HKDIwKSxcbiAgICB2YWxpZGF0ZToge1xuICAgICAgaXNJbjogW1snTG93JywgJ01lZGl1bScsICdIaWdoJywgJ1VyZ2VudCddXVxuICAgIH1cbiAgfSxcbiAgZGVhZGxpbmU6IERhdGFUeXBlcy5EQVRFLFxuICB0YXNrX3N0YXR1czoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5TVFJJTkcoMzApLFxuICAgIHZhbGlkYXRlOiB7XG4gICAgICBpc0luOiBbWydOb3QgU3RhcnRlZCcsICdJbiBQcm9ncmVzcycsICdDb21wbGV0ZWQnLCAnQmxvY2tlZCcsICdEZWZlcnJlZCddXVxuICAgIH1cbiAgfSxcbiAgZXZlbnRfc3VtbWFyeV9jYWNoZWQ6IERhdGFUeXBlcy5URVhULFxuICBzdGFydF90aW1lX2NhY2hlZDogRGF0YVR5cGVzLkRBVEUsXG4gIGVuZF90aW1lX2NhY2hlZDogRGF0YVR5cGVzLkRBVEUsXG4gIGxvY2F0aW9uX2NhY2hlZDogRGF0YVR5cGVzLlRFWFQsXG4gIGxhc3Rfc3luY2VkX2F0OiBEYXRhVHlwZXMuREFURSxcbiAgY3JlYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9LFxuICB1cGRhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAnY2FsZW5kYXJfZXZlbnRfbWV0YWRhdGEnLFxuICB0aW1lc3RhbXBzOiBmYWxzZSxcbiAgaW5kZXhlczogW1xuICAgIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICAgIGZpZWxkczogWyd1c2VyX2lkJywgJ2dvb2dsZV9jYWxlbmRhcl9pZCcsICdnb29nbGVfZXZlbnRfaWQnXVxuICAgIH0sXG4gICAge1xuICAgICAgZmllbGRzOiBbJ3VzZXJfaWQnLCAnZGVhZGxpbmUnXVxuICAgIH0sXG4gICAge1xuICAgICAgZmllbGRzOiBbJ3VzZXJfaWQnLCAncHJpb3JpdHknXVxuICAgIH1cbiAgXVxufSk7XG5cbi8vIERlZmluZSByZWxhdGlvbnNoaXBzXG5Vc2VyLmhhc01hbnkoQ29udmVyc2F0aW9uLCB7IGZvcmVpZ25LZXk6ICd1c2VyX2lkJyB9KTtcbkNvbnZlcnNhdGlvbi5iZWxvbmdzVG8oVXNlciwgeyBmb3JlaWduS2V5OiAndXNlcl9pZCcgfSk7XG5cblVzZXIuaGFzT25lKFVzZXJQcmVmZXJlbmNlLCB7IGZvcmVpZ25LZXk6ICd1c2VyX2lkJyB9KTtcblVzZXJQcmVmZXJlbmNlLmJlbG9uZ3NUbyhVc2VyLCB7IGZvcmVpZ25LZXk6ICd1c2VyX2lkJyB9KTtcblxuQ29udmVyc2F0aW9uLmhhc01hbnkoQ29udmVyc2F0aW9uTWVzc2FnZSwgeyBmb3JlaWduS2V5OiAnY29udmVyc2F0aW9uX2lkJyB9KTtcbkNvbnZlcnNhdGlvbk1lc3NhZ2UuYmVsb25nc1RvKENvbnZlcnNhdGlvbiwgeyBmb3JlaWduS2V5OiAnY29udmVyc2F0aW9uX2lkJyB9KTtcblxuVXNlci5oYXNNYW55KENhbGVuZGFyRXZlbnRNZXRhZGF0YSwgeyBmb3JlaWduS2V5OiAndXNlcl9pZCcgfSk7XG5DYWxlbmRhckV2ZW50TWV0YWRhdGEuYmVsb25nc1RvKFVzZXIsIHsgZm9yZWlnbktleTogJ3VzZXJfaWQnIH0pO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBjb252ZXJzYXRpb24gbWFuYWdlbWVudFxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZURhdGFiYXNlKCkge1xuICB0cnkge1xuICAgIC8vIFRlc3QgY29ubmVjdGlvblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZXF1ZWxpemUuYXV0aGVudGljYXRlKCk7XG4gICAgICBjb25zb2xlLmxvZygnUG9zdGdyZVNRTCBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGNvbm5lY3QgdG8gdGhlIGRhdGFiYXNlOicsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUubG9nKCdNYWtlIHN1cmUgUG9zdGdyZVNRTCBpcyBydW5uaW5nIGFuZCB0aGUgZGF0YWJhc2UgZXhpc3RzLicpO1xuICAgICAgY29uc29sZS5sb2coJ1lvdSBjYW4gY3JlYXRlIHRoZSBkYXRhYmFzZSBieSBydW5uaW5nOiBucG0gcnVuIGluaXQtcG9zdGdyZXMnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQuIFNlZSBhYm92ZSBmb3IgZGV0YWlscy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGV4dGVuc2lvbiBmb3IgVVVJRCBnZW5lcmF0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgIGF3YWl0IHNlcXVlbGl6ZS5xdWVyeSgnQ1JFQVRFIEVYVEVOU0lPTiBJRiBOT1QgRVhJU1RTIFwidXVpZC1vc3NwXCI7Jyk7XG4gICAgICBjb25zb2xlLmxvZygnVVVJRCBleHRlbnNpb24gZW5hYmxlZCBzdWNjZXNzZnVsbHkuJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFVVSUQgZXh0ZW5zaW9uOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgdGltZXN0YW1wIHRyaWdnZXIgZnVuY3Rpb24gaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT04gdHJpZ2dlcl9zZXRfdGltZXN0YW1wKClcbiAgICAgICAgUkVUVVJOUyBUUklHR0VSIEFTICQkXG4gICAgICAgIEJFR0lOXG4gICAgICAgICAgTkVXLnVwZGF0ZWRfYXQgPSBOT1coKTtcbiAgICAgICAgICBSRVRVUk4gTkVXO1xuICAgICAgICBFTkQ7XG4gICAgICAgICQkIExBTkdVQUdFIHBscGdzcWw7XG4gICAgICBgKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUaW1lc3RhbXAgdHJpZ2dlciBmdW5jdGlvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGltZXN0YW1wIHRyaWdnZXIgZnVuY3Rpb246JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFN5bmMgYWxsIG1vZGVscyB3aXRob3V0IGZvcmNlOiB0cnVlIHRvIGF2b2lkIGRyb3BwaW5nIHRhYmxlc1xuICAgICAgY29uc29sZS5sb2coJ1N5bmNocm9uaXppbmcgbW9kZWxzIChub24tZGVzdHJ1Y3RpdmUpLi4uJyk7XG4gICAgICAvLyBVc2UgeyBhbHRlcjogdHJ1ZSB9IHRvIGFwcGx5IHNjaGVtYSBjaGFuZ2VzIG5vbi1kZXN0cnVjdGl2ZWx5XG4gICAgICBhd2FpdCBzZXF1ZWxpemUuc3luYyh7IGFsdGVyOiB0cnVlIH0pO1xuICAgICAgY29uc29sZS5sb2coJ0FsbCBtb2RlbHMgd2VyZSBzeW5jaHJvbml6ZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgXG4gICAgICAvLyBOb3RlOiBGb3IgcHJvZHVjdGlvbiwgZGF0YWJhc2Ugc3RydWN0dXJlIHNob3VsZCBiZSBtYW5hZ2VkIHZpYSBtaWdyYXRpb25zXG4gICAgICAvLyByYXRoZXIgdGhhbiBhdXRvbWF0aWMgc3luY1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzeW5jaHJvbml6aW5nIG1vZGVsczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHRvb2xfY2FsbHMgY29sdW1uIGV4aXN0cyBpbiBjb252ZXJzYXRpb25fbWVzc2FnZXMgdGFibGVcbiAgICAgIGNvbnN0IGNoZWNrQ29sdW1uUmVzdWx0ID0gYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgU0VMRUNUIGNvbHVtbl9uYW1lXG4gICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnNcbiAgICAgICAgV0hFUkUgdGFibGVfbmFtZSA9ICdjb252ZXJzYXRpb25fbWVzc2FnZXMnXG4gICAgICAgIEFORCBjb2x1bW5fbmFtZSA9ICd0b29sX2NhbGxzJztcbiAgICAgIGApO1xuICAgICAgXG4gICAgICAvLyBJZiBjb2x1bW4gZG9lc24ndCBleGlzdCwgYWRkIGl0XG4gICAgICBpZiAoY2hlY2tDb2x1bW5SZXN1bHRbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgbWlzc2luZyB0b29sX2NhbGxzIGNvbHVtbiB0byBjb252ZXJzYXRpb25fbWVzc2FnZXMgdGFibGUuLi4nKTtcbiAgICAgICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgICBBTFRFUiBUQUJMRSBjb252ZXJzYXRpb25fbWVzc2FnZXNcbiAgICAgICAgICBBREQgQ09MVU1OIHRvb2xfY2FsbHMgSlNPTkI7XG4gICAgICAgIGApO1xuICAgICAgICBjb25zb2xlLmxvZygndG9vbF9jYWxscyBjb2x1bW4gYWRkZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Rvb2xfY2FsbHMgY29sdW1uIGFscmVhZHkgZXhpc3RzIGluIGNvbnZlcnNhdGlvbl9tZXNzYWdlcyB0YWJsZS4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgb3IgYWRkaW5nIHRvb2xfY2FsbHMgY29sdW1uOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgdHJpZ2dlcnMgZm9yIHVwZGF0ZWRfYXQgdGltZXN0YW1wc1xuICAgICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgRE8gJCRcbiAgICAgICAgQkVHSU5cbiAgICAgICAgICBJRiBOT1QgRVhJU1RTIChTRUxFQ1QgMSBGUk9NIHBnX3RyaWdnZXIgV0hFUkUgdGduYW1lID0gJ3NldF90aW1lc3RhbXBfdXNlcnMnKSBUSEVOXG4gICAgICAgICAgICBDUkVBVEUgVFJJR0dFUiBzZXRfdGltZXN0YW1wX3VzZXJzXG4gICAgICAgICAgICBCRUZPUkUgVVBEQVRFIE9OIHVzZXJzXG4gICAgICAgICAgICBGT1IgRUFDSCBST1dcbiAgICAgICAgICAgIEVYRUNVVEUgRlVOQ1RJT04gdHJpZ2dlcl9zZXRfdGltZXN0YW1wKCk7XG4gICAgICAgICAgRU5EIElGO1xuXG4gICAgICAgICAgSUYgTk9UIEVYSVNUUyAoU0VMRUNUIDEgRlJPTSBwZ190cmlnZ2VyIFdIRVJFIHRnbmFtZSA9ICdzZXRfdGltZXN0YW1wX3VzZXJfcHJlZmVyZW5jZXMnKSBUSEVOXG4gICAgICAgICAgICBDUkVBVEUgVFJJR0dFUiBzZXRfdGltZXN0YW1wX3VzZXJfcHJlZmVyZW5jZXNcbiAgICAgICAgICAgIEJFRk9SRSBVUERBVEUgT04gdXNlcl9wcmVmZXJlbmNlc1xuICAgICAgICAgICAgRk9SIEVBQ0ggUk9XXG4gICAgICAgICAgICBFWEVDVVRFIEZVTkNUSU9OIHRyaWdnZXJfc2V0X3RpbWVzdGFtcCgpO1xuICAgICAgICAgIEVORCBJRjtcblxuICAgICAgICAgIElGIE5PVCBFWElTVFMgKFNFTEVDVCAxIEZST00gcGdfdHJpZ2dlciBXSEVSRSB0Z25hbWUgPSAnc2V0X3RpbWVzdGFtcF9jb252ZXJzYXRpb25zJykgVEhFTlxuICAgICAgICAgICAgQ1JFQVRFIFRSSUdHRVIgc2V0X3RpbWVzdGFtcF9jb252ZXJzYXRpb25zXG4gICAgICAgICAgICBCRUZPUkUgVVBEQVRFIE9OIGNvbnZlcnNhdGlvbnNcbiAgICAgICAgICAgIEZPUiBFQUNIIFJPV1xuICAgICAgICAgICAgRVhFQ1VURSBGVU5DVElPTiB0cmlnZ2VyX3NldF90aW1lc3RhbXAoKTtcbiAgICAgICAgICBFTkQgSUY7XG5cbiAgICAgICAgICBJRiBOT1QgRVhJU1RTIChTRUxFQ1QgMSBGUk9NIHBnX3RyaWdnZXIgV0hFUkUgdGduYW1lID0gJ3NldF90aW1lc3RhbXBfY2FsZW5kYXJfZXZlbnRfbWV0YWRhdGEnKSBUSEVOXG4gICAgICAgICAgICBDUkVBVEUgVFJJR0dFUiBzZXRfdGltZXN0YW1wX2NhbGVuZGFyX2V2ZW50X21ldGFkYXRhXG4gICAgICAgICAgICBCRUZPUkUgVVBEQVRFIE9OIGNhbGVuZGFyX2V2ZW50X21ldGFkYXRhXG4gICAgICAgICAgICBGT1IgRUFDSCBST1dcbiAgICAgICAgICAgIEVYRUNVVEUgRlVOQ1RJT04gdHJpZ2dlcl9zZXRfdGltZXN0YW1wKCk7XG4gICAgICAgICAgRU5EIElGO1xuICAgICAgICBFTkRcbiAgICAgICAgJCQ7XG4gICAgICBgKTtcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhYmFzZSB0cmlnZ2VycyBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdHJpZ2dlcnM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0RhdGFiYXNlIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGluaXRpYWxpemUgZGF0YWJhc2U6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIENvbnZlcnNhdGlvbiBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuYXN5bmMgZnVuY3Rpb24gZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBuYW1lLCBhdXRoUHJvdmlkZXIsIGF1dGhQcm92aWRlcklkLCBhdmF0YXJVcmwgPSBudWxsKSB7XG4gIHRyeSB7XG4gICAgLy8gRmlyc3QgdHJ5IHRvIGZpbmQgdGhlIHVzZXIgYnkgZW1haWxcbiAgICBsZXQgdXNlciA9IGF3YWl0IFVzZXIuZmluZE9uZSh7IHdoZXJlOiB7IGVtYWlsIH0gfSk7XG4gICAgXG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIC8vIFVzZXIgZXhpc3RzLCBjaGVjayBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBhdXRoIHByb3ZpZGVyIGluZm9cbiAgICAgIGlmICh1c2VyLmF1dGhfcHJvdmlkZXIgIT09IGF1dGhQcm92aWRlciB8fCB1c2VyLmF1dGhfcHJvdmlkZXJfaWQgIT09IGF1dGhQcm92aWRlcklkKSB7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIHRoZSBhdXRoIHByb3ZpZGVyIGluZm8gaXMgZGlmZmVyZW50XG4gICAgICAgIGNvbnNvbGUubG9nKGBVc2VyIHdpdGggZW1haWwgJHtlbWFpbH0gZXhpc3RzIGJ1dCB3aXRoIGRpZmZlcmVudCBhdXRoIHByb3ZpZGVyLiBSZXR1cm5pbmcgZXhpc3RpbmcgdXNlci5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2VyIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICB1c2VyID0gYXdhaXQgVXNlci5jcmVhdGUoe1xuICAgICAgZW1haWwsXG4gICAgICBuYW1lLFxuICAgICAgYXV0aF9wcm92aWRlcjogYXV0aFByb3ZpZGVyLFxuICAgICAgYXV0aF9wcm92aWRlcl9pZDogYXV0aFByb3ZpZGVySWQsXG4gICAgICBhdmF0YXJfdXJsOiBhdmF0YXJVcmxcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdXNlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG9yIGNyZWF0aW5nIHVzZXI6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnNhdGlvbih1c2VySWQpIHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiB1c2VySWQgaXMgYW4gZW1haWwgYWRkcmVzc1xuICAgIGNvbnN0IGlzRW1haWwgPSB0eXBlb2YgdXNlcklkID09PSAnc3RyaW5nJyAmJiB1c2VySWQuaW5jbHVkZXMoJ0AnKTtcbiAgICBsZXQgYWN0dWFsVXNlcklkID0gdXNlcklkO1xuICAgIFxuICAgIC8vIElmIHVzZXJJZCBpcyBhbiBlbWFpbCwgZmluZCB0aGUgdXNlciBieSBlbWFpbCBmaXJzdCB0byBnZXQgdGhlIGFjdHVhbCBVVUlEXG4gICAgaWYgKGlzRW1haWwpIHtcbiAgICAgIGNvbnN0IHVzZXJCeUVtYWlsID0gYXdhaXQgVXNlci5maW5kT25lKHsgd2hlcmU6IHsgZW1haWw6IHVzZXJJZCB9IH0pO1xuICAgICAgaWYgKCF1c2VyQnlFbWFpbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgTm8gdXNlciBmb3VuZCB3aXRoIGVtYWlsOiAke3VzZXJJZH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGNvbnZlcnNhdGlvbjogTm8gdXNlciBmb3VuZCB3aXRoIGVtYWlsOiAke3VzZXJJZH1gKTtcbiAgICAgIH1cbiAgICAgIGFjdHVhbFVzZXJJZCA9IHVzZXJCeUVtYWlsLnVzZXJfaWQ7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IGF3YWl0IENvbnZlcnNhdGlvbi5jcmVhdGUoe1xuICAgICAgdXNlcl9pZDogYWN0dWFsVXNlcklkXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnZlcnNhdGlvbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjb252ZXJzYXRpb246JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbihjb252ZXJzYXRpb25JZCkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBDb252ZXJzYXRpb24uZmluZEJ5UGsoY29udmVyc2F0aW9uSWQsIHtcbiAgICAgIGluY2x1ZGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBDb252ZXJzYXRpb25NZXNzYWdlLFxuICAgICAgICAgIG9yZGVyOiBbWydzZXF1ZW5jZV9udW1iZXInLCAnQVNDJ11dXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNvbnZlcnNhdGlvbjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uc0J5VXNlcklkKHVzZXJJZCkge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHVzZXJJZCBpcyBhbiBlbWFpbCBhZGRyZXNzXG4gICAgY29uc3QgaXNFbWFpbCA9IHR5cGVvZiB1c2VySWQgPT09ICdzdHJpbmcnICYmIHVzZXJJZC5pbmNsdWRlcygnQCcpO1xuICAgIGxldCBhY3R1YWxVc2VySWQgPSB1c2VySWQ7XG4gICAgXG4gICAgLy8gSWYgdXNlcklkIGlzIGFuIGVtYWlsLCBmaW5kIHRoZSB1c2VyIGJ5IGVtYWlsIGZpcnN0IHRvIGdldCB0aGUgYWN0dWFsIFVVSURcbiAgICBpZiAoaXNFbWFpbCkge1xuICAgICAgY29uc3QgdXNlckJ5RW1haWwgPSBhd2FpdCBVc2VyLmZpbmRPbmUoeyB3aGVyZTogeyBlbWFpbDogdXNlcklkIH0gfSk7XG4gICAgICBpZiAoIXVzZXJCeUVtYWlsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBObyB1c2VyIGZvdW5kIHdpdGggZW1haWw6ICR7dXNlcklkfWApO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBhY3R1YWxVc2VySWQgPSB1c2VyQnlFbWFpbC51c2VyX2lkO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2UgRVhQTEFJTiBBTkFMWVpFIHRvIHVuZGVyc3RhbmQgcXVlcnkgcGVyZm9ybWFuY2VcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnN0IGV4cGxhaW5SZXN1bHQgPSBhd2FpdCBzZXF1ZWxpemUucXVlcnkoYFxuICAgICAgICBFWFBMQUlOIEFOQUxZWkVcbiAgICAgICAgU0VMRUNUICogRlJPTSBjb252ZXJzYXRpb25zXG4gICAgICAgIFdIRVJFIHVzZXJfaWQgPSAnJHthY3R1YWxVc2VySWR9J1xuICAgICAgICBPUkRFUiBCWSBjcmVhdGVkX2F0IERFU0NcbiAgICAgIGApO1xuICAgICAgY29uc29sZS5sb2coJ1F1ZXJ5IGV4ZWN1dGlvbiBwbGFuOicsIGV4cGxhaW5SZXN1bHRbMF0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYXdhaXQgQ29udmVyc2F0aW9uLmZpbmRBbGwoe1xuICAgICAgd2hlcmU6IHsgdXNlcl9pZDogYWN0dWFsVXNlcklkIH0sXG4gICAgICBvcmRlcjogW1snY3JlYXRlZF9hdCcsICdERVNDJ11dXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjb252ZXJzYXRpb25zIGJ5IHVzZXIgSUQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbk1lc3NhZ2VzKGNvbnZlcnNhdGlvbklkKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IENvbnZlcnNhdGlvbk1lc3NhZ2UuZmluZEFsbCh7XG4gICAgICB3aGVyZTogeyBjb252ZXJzYXRpb25faWQ6IGNvbnZlcnNhdGlvbklkIH0sXG4gICAgICBvcmRlcjogW1snc2VxdWVuY2VfbnVtYmVyJywgJ0FTQyddXVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY29udmVyc2F0aW9uIG1lc3NhZ2VzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIGFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbihcbiAgY29udmVyc2F0aW9uSWQsXG4gIHJvbGUsXG4gIGNvbnRlbnQsIC8vIENhbiBiZSBudWxsL3VuZGVmaW5lZCBmb3IgYXNzaXN0YW50IHRvb2wgY2FsbHNcbiAgeyB0b29sX2NhbGxzID0gbnVsbCwgdG9vbF9jYWxsX2lkID0gbnVsbCB9ID0ge30gLy8gUGFzcyB0b29sIGluZm8gYXMgYW4gb2JqZWN0XG4pIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYSB0cmFuc2FjdGlvbiBmb3Igc2VxdWVuY2UgbnVtYmVyIHNhZmV0eVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcXVlbGl6ZS50cmFuc2FjdGlvbihhc3luYyAodCkgPT4ge1xuICAgICAgLy8gR2V0IHRoZSBuZXh0IHNlcXVlbmNlIG51bWJlciB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCBtYXhTZXF1ZW5jZVJlc3VsdCA9IGF3YWl0IENvbnZlcnNhdGlvbk1lc3NhZ2UuZmluZE9uZSh7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFtbc2VxdWVsaXplLmZuKCdtYXgnLCBzZXF1ZWxpemUuY29sKCdzZXF1ZW5jZV9udW1iZXInKSksICdtYXhTZXF1ZW5jZSddXSxcbiAgICAgICAgd2hlcmU6IHsgY29udmVyc2F0aW9uX2lkOiBjb252ZXJzYXRpb25JZCB9LFxuICAgICAgICB0cmFuc2FjdGlvbjogdCxcbiAgICAgICAgcmF3OiB0cnVlLCAvLyBHZXQgcmF3IHJlc3VsdFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtYXhTZXF1ZW5jZSA9IG1heFNlcXVlbmNlUmVzdWx0Py5tYXhTZXF1ZW5jZSB8fCAwO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIG1lc3NhZ2VcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBDb252ZXJzYXRpb25NZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgIGNvbnZlcnNhdGlvbl9pZDogY29udmVyc2F0aW9uSWQsXG4gICAgICAgIHNlcXVlbmNlX251bWJlcjogbWF4U2VxdWVuY2UgKyAxLFxuICAgICAgICByb2xlLFxuICAgICAgICBjb250ZW50OiBjb250ZW50LCAvLyBTdG9yZSBjb250ZW50IChjYW4gYmUgbnVsbClcbiAgICAgICAgdG9vbF9jYWxsczogcm9sZSA9PT0gJ2Fzc2lzdGFudCcgPyB0b29sX2NhbGxzIDogbnVsbCwgLy8gU3RvcmUgdG9vbF9jYWxscyBPTkxZIGZvciBhc3Npc3RhbnRcbiAgICAgICAgdG9vbF9jYWxsX2lkOiByb2xlID09PSAndG9vbCcgPyB0b29sX2NhbGxfaWQgOiBudWxsLCAvLyBTdG9yZSB0b29sX2NhbGxfaWQgT05MWSBmb3IgdG9vbCByZXNwb25zZVxuICAgICAgfSwgeyB0cmFuc2FjdGlvbjogdCB9KTtcblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG1lc3NhZ2UgdG8gY29udmVyc2F0aW9uOicsIGVycm9yKTtcbiAgICAvLyBMb2cgc3BlY2lmaWMgZGV0YWlscyBpZiBhdmFpbGFibGVcbiAgICBpZiAoZXJyb3Iub3JpZ2luYWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignT3JpZ2luYWwgREIgRXJyb3I6JywgZXJyb3Iub3JpZ2luYWwpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdGhlIGVycm9yIHRvIGJlIGhhbmRsZWQgdXBzdHJlYW1cbiAgfVxufVxuXG5cblxuLyoqXG4gKiBHZXQgdXNlciBhbmQgdGhlaXIgbGF0ZXN0IGNvbnZlcnNhdGlvbiBpbiBhIHNpbmdsZSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyIElEXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIFVzZXIgZGF0YSB3aXRoIGxhdGVzdCBjb252ZXJzYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlcldpdGhMYXRlc3RDb252ZXJzYXRpb24odXNlcklkKSB7XG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgaWYgdXNlcklkIGlzIGFuIGVtYWlsIGFkZHJlc3NcbiAgICBjb25zdCBpc0VtYWlsID0gdHlwZW9mIHVzZXJJZCA9PT0gJ3N0cmluZycgJiYgdXNlcklkLmluY2x1ZGVzKCdAJyk7XG4gICAgbGV0IGFjdHVhbFVzZXJJZCA9IHVzZXJJZDtcbiAgICBcbiAgICAvLyBJZiB1c2VySWQgaXMgYW4gZW1haWwsIGZpbmQgdGhlIHVzZXIgYnkgZW1haWwgZmlyc3QgdG8gZ2V0IHRoZSBhY3R1YWwgVVVJRFxuICAgIGlmIChpc0VtYWlsKSB7XG4gICAgICBjb25zdCB1c2VyQnlFbWFpbCA9IGF3YWl0IFVzZXIuZmluZE9uZSh7IHdoZXJlOiB7IGVtYWlsOiB1c2VySWQgfSB9KTtcbiAgICAgIGlmICghdXNlckJ5RW1haWwpIHtcbiAgICAgICAgY29uc29sZS5sb2coYE5vIHVzZXIgZm91bmQgd2l0aCBlbWFpbDogJHt1c2VySWR9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgYWN0dWFsVXNlcklkID0gdXNlckJ5RW1haWwudXNlcl9pZDtcbiAgICB9XG4gICAgXG4gICAgLy8gVXNlIEVYUExBSU4gQU5BTFlaRSB0byB1bmRlcnN0YW5kIHF1ZXJ5IHBlcmZvcm1hbmNlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCBleHBsYWluUmVzdWx0ID0gYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgRVhQTEFJTiBBTkFMWVpFXG4gICAgICAgIFNFTEVDVCB1LiosIGMuKlxuICAgICAgICBGUk9NIHVzZXJzIHVcbiAgICAgICAgTEVGVCBKT0lOIChcbiAgICAgICAgICBTRUxFQ1QgKiBGUk9NIGNvbnZlcnNhdGlvbnNcbiAgICAgICAgICBXSEVSRSB1c2VyX2lkID0gJyR7YWN0dWFsVXNlcklkfSdcbiAgICAgICAgICBPUkRFUiBCWSBjcmVhdGVkX2F0IERFU0NcbiAgICAgICAgICBMSU1JVCAxXG4gICAgICAgICkgYyBPTiB1LnVzZXJfaWQgPSBjLnVzZXJfaWRcbiAgICAgICAgV0hFUkUgdS51c2VyX2lkID0gJyR7YWN0dWFsVXNlcklkfSdcbiAgICAgIGApO1xuICAgICAgY29uc29sZS5sb2coJ0pvaW4gcXVlcnkgZXhlY3V0aW9uIHBsYW46JywgZXhwbGFpblJlc3VsdFswXSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4ZWN1dGUgdGhlIGFjdHVhbCBxdWVyeSB1c2luZyBTZXF1ZWxpemVcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kQnlQayhhY3R1YWxVc2VySWQsIHtcbiAgICAgIGluY2x1ZGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBDb252ZXJzYXRpb24sXG4gICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgb3JkZXI6IFtbJ2NyZWF0ZWRfYXQnLCAnREVTQyddXSxcbiAgICAgICAgICBpbmNsdWRlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGVsOiBDb252ZXJzYXRpb25NZXNzYWdlLFxuICAgICAgICAgICAgICBvcmRlcjogW1snc2VxdWVuY2VfbnVtYmVyJywgJ0RFU0MnXV0sXG4gICAgICAgICAgICAgIGxpbWl0OiA1MCwgLy8gTG9hZCB1cCB0byA1MCBtb3N0IHJlY2VudCBtZXNzYWdlc1xuICAgICAgICAgICAgICBzZXBhcmF0ZTogdHJ1ZSAvLyBUaGlzIGVuc3VyZXMgYWxsIG1lc3NhZ2VzIGFyZSBsb2FkZWQsIG5vdCBqdXN0IG9uZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBVc2VyUHJlZmVyZW5jZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHVzZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIHdpdGggbGF0ZXN0IGNvbnZlcnNhdGlvbjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gRXhwb3J0IG1vZGVscyBhbmQgZnVuY3Rpb25zXG5leHBvcnQge1xuICBzZXF1ZWxpemUsXG4gIFVzZXIsXG4gIFVzZXJQcmVmZXJlbmNlLFxuICBDb252ZXJzYXRpb24sXG4gIENvbnZlcnNhdGlvbk1lc3NhZ2UsXG4gIENhbGVuZGFyRXZlbnRNZXRhZGF0YSxcbiAgaW5pdGlhbGl6ZURhdGFiYXNlLFxuICBnZXRPckNyZWF0ZVVzZXIsXG4gIGNyZWF0ZUNvbnZlcnNhdGlvbixcbiAgZ2V0Q29udmVyc2F0aW9uLFxuICBnZXRDb252ZXJzYXRpb25zQnlVc2VySWQsXG4gIGdldENvbnZlcnNhdGlvbk1lc3NhZ2VzLFxuICBhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24sXG4gIGdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZXF1ZWxpemU7XG4iXSwibmFtZXMiOlsiU2VxdWVsaXplIiwiRGF0YVR5cGVzIiwic2VxdWVsaXplIiwiZGlhbGVjdCIsImhvc3QiLCJwcm9jZXNzIiwiZW52IiwiUE9TVEdSRVNfSE9TVCIsInBvcnQiLCJQT1NUR1JFU19QT1JUIiwidXNlcm5hbWUiLCJQT1NUR1JFU19VU0VSIiwicGFzc3dvcmQiLCJQT1NUR1JFU19QQVNTV09SRCIsImRhdGFiYXNlIiwiUE9TVEdSRVNfREIiLCJsb2dnaW5nIiwiY29uc29sZSIsImxvZyIsImRpYWxlY3RPcHRpb25zIiwic3NsIiwiUE9TVEdSRVNfU1NMIiwicmVxdWlyZSIsInJlamVjdFVuYXV0aG9yaXplZCIsInBvb2wiLCJtYXgiLCJtaW4iLCJhY3F1aXJlIiwiaWRsZSIsIlVzZXIiLCJkZWZpbmUiLCJ1c2VyX2lkIiwidHlwZSIsIlVVSUQiLCJkZWZhdWx0VmFsdWUiLCJsaXRlcmFsIiwicHJpbWFyeUtleSIsImVtYWlsIiwiU1RSSU5HIiwiYWxsb3dOdWxsIiwidW5pcXVlIiwibmFtZSIsImF2YXRhcl91cmwiLCJURVhUIiwiYXV0aF9wcm92aWRlciIsImF1dGhfcHJvdmlkZXJfaWQiLCJ0aW1lem9uZSIsImNyZWF0ZWRfYXQiLCJEQVRFIiwidXBkYXRlZF9hdCIsInRhYmxlTmFtZSIsInRpbWVzdGFtcHMiLCJpbmRleGVzIiwiZmllbGRzIiwiVXNlclByZWZlcmVuY2UiLCJwcmVmZXJlbmNlX2lkIiwicmVmZXJlbmNlcyIsIm1vZGVsIiwia2V5Iiwib25EZWxldGUiLCJwcmVmZXJlbmNlc19kYXRhIiwiSlNPTkIiLCJDb252ZXJzYXRpb24iLCJjb252ZXJzYXRpb25faWQiLCJzdGFydF90aW1lIiwic3VtbWFyeSIsIkNvbnZlcnNhdGlvbk1lc3NhZ2UiLCJtZXNzYWdlX2lkIiwic2VxdWVuY2VfbnVtYmVyIiwiSU5URUdFUiIsInJvbGUiLCJ2YWxpZGF0ZSIsImlzSW4iLCJjb250ZW50IiwidG9vbF9jYWxscyIsInRvb2xfY2FsbF9pZCIsIkNhbGVuZGFyRXZlbnRNZXRhZGF0YSIsIm1ldGFkYXRhX2lkIiwiZ29vZ2xlX2NhbGVuZGFyX2lkIiwiZ29vZ2xlX2V2ZW50X2lkIiwicHJpb3JpdHkiLCJkZWFkbGluZSIsInRhc2tfc3RhdHVzIiwiZXZlbnRfc3VtbWFyeV9jYWNoZWQiLCJzdGFydF90aW1lX2NhY2hlZCIsImVuZF90aW1lX2NhY2hlZCIsImxvY2F0aW9uX2NhY2hlZCIsImxhc3Rfc3luY2VkX2F0IiwiaGFzTWFueSIsImZvcmVpZ25LZXkiLCJiZWxvbmdzVG8iLCJoYXNPbmUiLCJpbml0aWFsaXplRGF0YWJhc2UiLCJhdXRoZW50aWNhdGUiLCJlcnJvciIsIkVycm9yIiwicXVlcnkiLCJzeW5jIiwiYWx0ZXIiLCJjaGVja0NvbHVtblJlc3VsdCIsImxlbmd0aCIsImdldE9yQ3JlYXRlVXNlciIsImF1dGhQcm92aWRlciIsImF1dGhQcm92aWRlcklkIiwiYXZhdGFyVXJsIiwidXNlciIsImZpbmRPbmUiLCJ3aGVyZSIsImNyZWF0ZSIsImNyZWF0ZUNvbnZlcnNhdGlvbiIsInVzZXJJZCIsImlzRW1haWwiLCJpbmNsdWRlcyIsImFjdHVhbFVzZXJJZCIsInVzZXJCeUVtYWlsIiwiY29udmVyc2F0aW9uIiwiZ2V0Q29udmVyc2F0aW9uIiwiY29udmVyc2F0aW9uSWQiLCJmaW5kQnlQayIsImluY2x1ZGUiLCJvcmRlciIsImdldENvbnZlcnNhdGlvbnNCeVVzZXJJZCIsImV4cGxhaW5SZXN1bHQiLCJmaW5kQWxsIiwiZ2V0Q29udmVyc2F0aW9uTWVzc2FnZXMiLCJhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24iLCJyZXN1bHQiLCJ0cmFuc2FjdGlvbiIsInQiLCJtYXhTZXF1ZW5jZVJlc3VsdCIsImF0dHJpYnV0ZXMiLCJmbiIsImNvbCIsInJhdyIsIm1heFNlcXVlbmNlIiwibWVzc2FnZSIsIm9yaWdpbmFsIiwiZ2V0VXNlcldpdGhMYXRlc3RDb252ZXJzYXRpb24iLCJsaW1pdCIsInNlcGFyYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/postgresClient.js\n");

/***/ }),

/***/ "(api)/./lib/redisClient.js":
/*!****************************!*\
  !*** ./lib/redisClient.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheEventsForDateRange: () => (/* binding */ cacheEventsForDateRange),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   deleteCache: () => (/* binding */ deleteCache),\n/* harmony export */   deleteCacheByPrefix: () => (/* binding */ deleteCacheByPrefix),\n/* harmony export */   deleteConversation: () => (/* binding */ deleteConversation),\n/* harmony export */   flushCache: () => (/* binding */ flushCache),\n/* harmony export */   getCache: () => (/* binding */ getCache),\n/* harmony export */   getCachedEventsForDateRange: () => (/* binding */ getCachedEventsForDateRange),\n/* harmony export */   getConversation: () => (/* binding */ getConversation),\n/* harmony export */   invalidateDateRangeCache: () => (/* binding */ invalidateDateRangeCache),\n/* harmony export */   saveConversation: () => (/* binding */ saveConversation),\n/* harmony export */   setCache: () => (/* binding */ setCache)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"ioredis\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-cache */ \"node-cache\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dotenv/config */ \"dotenv/config\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dotenv_config__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n// Create Redis client with configuration from environment variables\n// or use default values if not provided\nconst redisClient = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())({\n    host: process.env.REDIS_HOST || \"localhost\",\n    port: process.env.REDIS_PORT || 6379,\n    password: process.env.REDIS_PASSWORD || \"\",\n    db: process.env.REDIS_DB || 0,\n    // Enable reconnect on error\n    retryStrategy: (times)=>{\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n    }\n});\n// Create a very short-lived first-level buffer cache\nconst localCache = new (node_cache__WEBPACK_IMPORTED_MODULE_1___default())({\n    stdTTL: 10\n}); // 10 seconds TTL\n// Log connection events\nredisClient.on(\"connect\", ()=>{\n    console.log(\"Connected to Redis\");\n});\nredisClient.on(\"error\", (err)=>{\n    console.error(\"Redis connection error:\", err);\n});\n// Helper functions for conversation history\nconst CONVERSATION_PREFIX = \"conversation:\";\nconst CACHE_PREFIX = \"cache:\";\nconst DATE_RANGE_PREFIX = \"date_range:\";\nconst USER_PREFIX = \"user:\";\nconst DEFAULT_EXPIRY = 60 * 60 * 24 * 7; // 1 week in seconds\n/**\n * Save conversation history for a user\n * @param {string} userId - The user ID\n * @param {Array} messages - The conversation messages\n * @param {number} expiry - Expiry time in seconds (optional)\n */ async function saveConversation(userId, messages, expiry = DEFAULT_EXPIRY) {\n    try {\n        const key = `${CONVERSATION_PREFIX}${userId}`;\n        await redisClient.set(key, JSON.stringify(messages), \"EX\", expiry);\n    } catch (error) {\n        console.error(\"Error saving conversation to Redis:\", error);\n    }\n}\n/**\n * Get conversation history for a user\n * @param {string} userId - The user ID\n * @returns {Array|null} - The conversation messages or null if not found\n */ async function getConversation(userId) {\n    try {\n        const key = `${CONVERSATION_PREFIX}${userId}`;\n        // Try local cache first\n        const localData = localCache.get(key);\n        if (localData) {\n            return localData;\n        }\n        // Try Redis\n        const data = await redisClient.get(key);\n        if (data) {\n            const parsedData = JSON.parse(data);\n            // Store in local cache\n            localCache.set(key, parsedData);\n            return parsedData;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting conversation from Redis:\", error);\n        return null;\n    }\n}\n/**\n * Delete conversation history for a user\n * @param {string} userId - The user ID\n */ async function deleteConversation(userId) {\n    try {\n        const key = `${CONVERSATION_PREFIX}${userId}`;\n        await redisClient.del(key);\n        localCache.del(key);\n    } catch (error) {\n        console.error(\"Error deleting conversation from Redis:\", error);\n    }\n}\n// Helper functions for caching\n/**\n * Set a value in the cache\n * @param {string} key - The cache key\n * @param {any} value - The value to cache\n * @param {number} expiry - Expiry time in seconds (optional)\n */ async function setCache(key, value, expiry = 300) {\n    try {\n        const cacheKey = `${CACHE_PREFIX}${key}`;\n        await redisClient.set(cacheKey, JSON.stringify(value), \"EX\", expiry);\n        localCache.set(cacheKey, value, 10); // 10 seconds in local cache\n    } catch (error) {\n        console.error(\"Error setting cache in Redis:\", error);\n    }\n}\n/**\n * Get a value from the cache\n * @param {string} key - The cache key\n * @returns {any|null} - The cached value or null if not found\n */ async function getCache(key) {\n    try {\n        const cacheKey = `${CACHE_PREFIX}${key}`;\n        // Try local cache first (fastest)\n        const localData = localCache.get(cacheKey);\n        if (localData) {\n            return localData;\n        }\n        // Try Redis\n        const data = await redisClient.get(cacheKey);\n        if (data) {\n            const parsedData = JSON.parse(data);\n            // Store in local cache\n            localCache.set(cacheKey, parsedData, 10); // 10 seconds\n            return parsedData;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting cache from Redis:\", error);\n        return null;\n    }\n}\n/**\n * Delete a value from the cache\n * @param {string} key - The cache key\n */ async function deleteCache(key) {\n    try {\n        const cacheKey = `${CACHE_PREFIX}${key}`;\n        await redisClient.del(cacheKey);\n        localCache.del(cacheKey);\n    } catch (error) {\n        console.error(\"Error deleting cache from Redis:\", error);\n    }\n}\n/**\n * Delete all cache entries with a specific prefix\n * @param {string} prefix - The prefix to match\n */ async function deleteCacheByPrefix(prefix) {\n    try {\n        const pattern = `${CACHE_PREFIX}${prefix}*`;\n        const keys = await redisClient.keys(pattern);\n        if (keys.length > 0) {\n            await redisClient.del(...keys);\n            // Also clear from local cache\n            keys.forEach((key)=>{\n                localCache.del(key);\n            });\n        }\n    } catch (error) {\n        console.error(\"Error deleting cache by prefix from Redis:\", error);\n    }\n}\n/**\n * Cache calendar events for a specific date range\n * @param {string} userId - The user ID\n * @param {string} startDate - Start date in ISO format\n * @param {string} endDate - End date in ISO format\n * @param {Array} events - Calendar events to cache\n * @param {number} expiry - Expiry time in seconds (optional)\n */ async function cacheEventsForDateRange(userId, startDate, endDate, events, expiry = 300) {\n    try {\n        // Create a key for this specific date range\n        const rangeKey = `${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}${startDate}_${endDate}`;\n        // Store the events\n        await redisClient.set(rangeKey, JSON.stringify(events), \"EX\", expiry);\n        // Add this range to a set of all ranges for this user\n        await redisClient.sadd(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}all_ranges`, rangeKey);\n        // Store in local cache too\n        localCache.set(rangeKey, events, 10); // 10 seconds\n    } catch (error) {\n        console.error(\"Error caching events for date range:\", error);\n    }\n}\n/**\n * Get cached events for a specific date range\n * @param {string} userId - The user ID\n * @param {string} startDate - Start date in ISO format\n * @param {string} endDate - End date in ISO format\n * @returns {Array|null} - Cached events or null if not found\n */ async function getCachedEventsForDateRange(userId, startDate, endDate) {\n    try {\n        const rangeKey = `${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}${startDate}_${endDate}`;\n        // Try local cache first\n        const localData = localCache.get(rangeKey);\n        if (localData) {\n            return localData;\n        }\n        // Try Redis\n        const data = await redisClient.get(rangeKey);\n        if (data) {\n            const parsedData = JSON.parse(data);\n            // Store in local cache\n            localCache.set(rangeKey, parsedData, 10); // 10 seconds\n            return parsedData;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting cached events for date range:\", error);\n        return null;\n    }\n}\n/**\n * Invalidate cached events for a specific date range\n * @param {string} userId - The user ID\n * @param {string} startDate - Start date in ISO format\n * @param {string} endDate - End date in ISO format\n */ async function invalidateDateRangeCache(userId, startDate, endDate) {\n    try {\n        // Get all cached ranges for this user\n        const allRanges = await redisClient.smembers(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}all_ranges`);\n        // Find ranges that overlap with the specified range\n        const rangesToInvalidate = [];\n        for (const rangeKey of allRanges){\n            // Extract dates from the key\n            const match = rangeKey.match(new RegExp(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}(.+)_(.+)$`));\n            if (match) {\n                const [, cachedStart, cachedEnd] = match;\n                // Check if ranges overlap\n                if (startDate <= cachedEnd && endDate >= cachedStart) {\n                    rangesToInvalidate.push(rangeKey);\n                }\n            }\n        }\n        // Delete the overlapping ranges\n        if (rangesToInvalidate.length > 0) {\n            await redisClient.del(...rangesToInvalidate);\n            // Remove from the set of all ranges\n            await redisClient.srem(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}all_ranges`, ...rangesToInvalidate);\n            // Clear from local cache too\n            rangesToInvalidate.forEach((key)=>{\n                localCache.del(key);\n            });\n            console.log(`Invalidated ${rangesToInvalidate.length} overlapping date ranges for user ${userId}`);\n        }\n    } catch (error) {\n        console.error(\"Error invalidating date range cache:\", error);\n    }\n}\n/**\n * Flush all cache entries\n */ async function flushCache() {\n    try {\n        const pattern = `${CACHE_PREFIX}*`;\n        const keys = await redisClient.keys(pattern);\n        if (keys.length > 0) {\n            await redisClient.del(...keys);\n        }\n        // Also clear date range caches\n        const dateRangePattern = `*:${DATE_RANGE_PREFIX}*`;\n        const dateRangeKeys = await redisClient.keys(dateRangePattern);\n        if (dateRangeKeys.length > 0) {\n            await redisClient.del(...dateRangeKeys);\n        }\n        // Clear local cache\n        localCache.flushAll();\n        console.log(\"Cache flushed successfully\");\n    } catch (error) {\n        console.error(\"Error flushing cache from Redis:\", error);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redisClient);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxPQUFPRSxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyxvQ0FBb0NBO0lBQ3BEO0FBQ0Y7QUFFQSxpRUFBZXRCLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nY2FsZW5kYXJhcHAvLi9saWIvcmVkaXNDbGllbnQuanM/ZWVkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVkaXMgZnJvbSAnaW9yZWRpcyc7XG5pbXBvcnQgTm9kZUNhY2hlIGZyb20gJ25vZGUtY2FjaGUnO1xuaW1wb3J0ICdkb3RlbnYvY29uZmlnJztcblxuLy8gQ3JlYXRlIFJlZGlzIGNsaWVudCB3aXRoIGNvbmZpZ3VyYXRpb24gZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbi8vIG9yIHVzZSBkZWZhdWx0IHZhbHVlcyBpZiBub3QgcHJvdmlkZWRcbmNvbnN0IHJlZGlzQ2xpZW50ID0gbmV3IFJlZGlzKHtcbiAgaG9zdDogcHJvY2Vzcy5lbnYuUkVESVNfSE9TVCB8fCAnbG9jYWxob3N0JyxcbiAgcG9ydDogcHJvY2Vzcy5lbnYuUkVESVNfUE9SVCB8fCA2Mzc5LFxuICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuUkVESVNfUEFTU1dPUkQgfHwgJycsXG4gIGRiOiBwcm9jZXNzLmVudi5SRURJU19EQiB8fCAwLFxuICAvLyBFbmFibGUgcmVjb25uZWN0IG9uIGVycm9yXG4gIHJldHJ5U3RyYXRlZ3k6ICh0aW1lcykgPT4ge1xuICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4odGltZXMgKiA1MCwgMjAwMCk7XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9XG59KTtcblxuLy8gQ3JlYXRlIGEgdmVyeSBzaG9ydC1saXZlZCBmaXJzdC1sZXZlbCBidWZmZXIgY2FjaGVcbmNvbnN0IGxvY2FsQ2FjaGUgPSBuZXcgTm9kZUNhY2hlKHsgc3RkVFRMOiAxMCB9KTsgLy8gMTAgc2Vjb25kcyBUVExcblxuLy8gTG9nIGNvbm5lY3Rpb24gZXZlbnRzXG5yZWRpc0NsaWVudC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB0byBSZWRpcycpO1xufSk7XG5cbnJlZGlzQ2xpZW50Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgY29uc29sZS5lcnJvcignUmVkaXMgY29ubmVjdGlvbiBlcnJvcjonLCBlcnIpO1xufSk7XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbnZlcnNhdGlvbiBoaXN0b3J5XG5jb25zdCBDT05WRVJTQVRJT05fUFJFRklYID0gJ2NvbnZlcnNhdGlvbjonO1xuY29uc3QgQ0FDSEVfUFJFRklYID0gJ2NhY2hlOic7XG5jb25zdCBEQVRFX1JBTkdFX1BSRUZJWCA9ICdkYXRlX3JhbmdlOic7XG5jb25zdCBVU0VSX1BSRUZJWCA9ICd1c2VyOic7XG5jb25zdCBERUZBVUxUX0VYUElSWSA9IDYwICogNjAgKiAyNCAqIDc7IC8vIDEgd2VlayBpbiBzZWNvbmRzXG5cbi8qKlxuICogU2F2ZSBjb252ZXJzYXRpb24gaGlzdG9yeSBmb3IgYSB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVGhlIHVzZXIgSURcbiAqIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2VzIC0gVGhlIGNvbnZlcnNhdGlvbiBtZXNzYWdlc1xuICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyeSAtIEV4cGlyeSB0aW1lIGluIHNlY29uZHMgKG9wdGlvbmFsKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZUNvbnZlcnNhdGlvbih1c2VySWQsIG1lc3NhZ2VzLCBleHBpcnkgPSBERUZBVUxUX0VYUElSWSkge1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGAke0NPTlZFUlNBVElPTl9QUkVGSVh9JHt1c2VySWR9YDtcbiAgICBhd2FpdCByZWRpc0NsaWVudC5zZXQoa2V5LCBKU09OLnN0cmluZ2lmeShtZXNzYWdlcyksICdFWCcsIGV4cGlyeSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGNvbnZlcnNhdGlvbiB0byBSZWRpczonLCBlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgY29udmVyc2F0aW9uIGhpc3RvcnkgZm9yIGEgdXNlclxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyIElEXG4gKiBAcmV0dXJucyB7QXJyYXl8bnVsbH0gLSBUaGUgY29udmVyc2F0aW9uIG1lc3NhZ2VzIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb252ZXJzYXRpb24odXNlcklkKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qga2V5ID0gYCR7Q09OVkVSU0FUSU9OX1BSRUZJWH0ke3VzZXJJZH1gO1xuICAgIFxuICAgIC8vIFRyeSBsb2NhbCBjYWNoZSBmaXJzdFxuICAgIGNvbnN0IGxvY2FsRGF0YSA9IGxvY2FsQ2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGxvY2FsRGF0YSkge1xuICAgICAgcmV0dXJuIGxvY2FsRGF0YTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IFJlZGlzXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlZGlzQ2xpZW50LmdldChrZXkpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIC8vIFN0b3JlIGluIGxvY2FsIGNhY2hlXG4gICAgICBsb2NhbENhY2hlLnNldChrZXksIHBhcnNlZERhdGEpO1xuICAgICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY29udmVyc2F0aW9uIGZyb20gUmVkaXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRGVsZXRlIGNvbnZlcnNhdGlvbiBoaXN0b3J5IGZvciBhIHVzZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBUaGUgdXNlciBJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29udmVyc2F0aW9uKHVzZXJJZCkge1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGAke0NPTlZFUlNBVElPTl9QUkVGSVh9JHt1c2VySWR9YDtcbiAgICBhd2FpdCByZWRpc0NsaWVudC5kZWwoa2V5KTtcbiAgICBsb2NhbENhY2hlLmRlbChrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGNvbnZlcnNhdGlvbiBmcm9tIFJlZGlzOicsIGVycm9yKTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBjYWNoaW5nXG4vKipcbiAqIFNldCBhIHZhbHVlIGluIHRoZSBjYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBjYWNoZSBrZXlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjYWNoZVxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyeSAtIEV4cGlyeSB0aW1lIGluIHNlY29uZHMgKG9wdGlvbmFsKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0Q2FjaGUoa2V5LCB2YWx1ZSwgZXhwaXJ5ID0gMzAwKSB7IC8vIERlZmF1bHQgNSBtaW51dGVzXG4gIHRyeSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtDQUNIRV9QUkVGSVh9JHtrZXl9YDtcbiAgICBhd2FpdCByZWRpc0NsaWVudC5zZXQoY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgJ0VYJywgZXhwaXJ5KTtcbiAgICBsb2NhbENhY2hlLnNldChjYWNoZUtleSwgdmFsdWUsIDEwKTsgLy8gMTAgc2Vjb25kcyBpbiBsb2NhbCBjYWNoZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNldHRpbmcgY2FjaGUgaW4gUmVkaXM6JywgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGEgdmFsdWUgZnJvbSB0aGUgY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgY2FjaGUga2V5XG4gKiBAcmV0dXJucyB7YW55fG51bGx9IC0gVGhlIGNhY2hlZCB2YWx1ZSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGUoa2V5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtDQUNIRV9QUkVGSVh9JHtrZXl9YDtcbiAgICBcbiAgICAvLyBUcnkgbG9jYWwgY2FjaGUgZmlyc3QgKGZhc3Rlc3QpXG4gICAgY29uc3QgbG9jYWxEYXRhID0gbG9jYWxDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChsb2NhbERhdGEpIHtcbiAgICAgIHJldHVybiBsb2NhbERhdGE7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSBSZWRpc1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZWRpc0NsaWVudC5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIC8vIFN0b3JlIGluIGxvY2FsIGNhY2hlXG4gICAgICBsb2NhbENhY2hlLnNldChjYWNoZUtleSwgcGFyc2VkRGF0YSwgMTApOyAvLyAxMCBzZWNvbmRzXG4gICAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjYWNoZSBmcm9tIFJlZGlzOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHZhbHVlIGZyb20gdGhlIGNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGNhY2hlIGtleVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ2FjaGUoa2V5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtDQUNIRV9QUkVGSVh9JHtrZXl9YDtcbiAgICBhd2FpdCByZWRpc0NsaWVudC5kZWwoY2FjaGVLZXkpO1xuICAgIGxvY2FsQ2FjaGUuZGVsKGNhY2hlS2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBjYWNoZSBmcm9tIFJlZGlzOicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBhbGwgY2FjaGUgZW50cmllcyB3aXRoIGEgc3BlY2lmaWMgcHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gVGhlIHByZWZpeCB0byBtYXRjaFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ2FjaGVCeVByZWZpeChwcmVmaXgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXR0ZXJuID0gYCR7Q0FDSEVfUFJFRklYfSR7cHJlZml4fSpgO1xuICAgIGNvbnN0IGtleXMgPSBhd2FpdCByZWRpc0NsaWVudC5rZXlzKHBhdHRlcm4pO1xuICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHJlZGlzQ2xpZW50LmRlbCguLi5rZXlzKTtcbiAgICAgIFxuICAgICAgLy8gQWxzbyBjbGVhciBmcm9tIGxvY2FsIGNhY2hlXG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgbG9jYWxDYWNoZS5kZWwoa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBjYWNoZSBieSBwcmVmaXggZnJvbSBSZWRpczonLCBlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWNoZSBjYWxlbmRhciBldmVudHMgZm9yIGEgc3BlY2lmaWMgZGF0ZSByYW5nZVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyIElEXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnREYXRlIC0gU3RhcnQgZGF0ZSBpbiBJU08gZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kRGF0ZSAtIEVuZCBkYXRlIGluIElTTyBmb3JtYXRcbiAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50cyAtIENhbGVuZGFyIGV2ZW50cyB0byBjYWNoZVxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyeSAtIEV4cGlyeSB0aW1lIGluIHNlY29uZHMgKG9wdGlvbmFsKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UodXNlcklkLCBzdGFydERhdGUsIGVuZERhdGUsIGV2ZW50cywgZXhwaXJ5ID0gMzAwKSB7XG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIGEga2V5IGZvciB0aGlzIHNwZWNpZmljIGRhdGUgcmFuZ2VcbiAgICBjb25zdCByYW5nZUtleSA9IGAke1VTRVJfUFJFRklYfSR7dXNlcklkfToke0RBVEVfUkFOR0VfUFJFRklYfSR7c3RhcnREYXRlfV8ke2VuZERhdGV9YDtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgZXZlbnRzXG4gICAgYXdhaXQgcmVkaXNDbGllbnQuc2V0KHJhbmdlS2V5LCBKU09OLnN0cmluZ2lmeShldmVudHMpLCAnRVgnLCBleHBpcnkpO1xuICAgIFxuICAgIC8vIEFkZCB0aGlzIHJhbmdlIHRvIGEgc2V0IG9mIGFsbCByYW5nZXMgZm9yIHRoaXMgdXNlclxuICAgIGF3YWl0IHJlZGlzQ2xpZW50LnNhZGQoYCR7VVNFUl9QUkVGSVh9JHt1c2VySWR9OiR7REFURV9SQU5HRV9QUkVGSVh9YWxsX3Jhbmdlc2AsIHJhbmdlS2V5KTtcbiAgICBcbiAgICAvLyBTdG9yZSBpbiBsb2NhbCBjYWNoZSB0b29cbiAgICBsb2NhbENhY2hlLnNldChyYW5nZUtleSwgZXZlbnRzLCAxMCk7IC8vIDEwIHNlY29uZHNcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWNoaW5nIGV2ZW50cyBmb3IgZGF0ZSByYW5nZTonLCBlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgY2FjaGVkIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBkYXRlIHJhbmdlXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVGhlIHVzZXIgSURcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydERhdGUgLSBTdGFydCBkYXRlIGluIElTTyBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmREYXRlIC0gRW5kIGRhdGUgaW4gSVNPIGZvcm1hdFxuICogQHJldHVybnMge0FycmF5fG51bGx9IC0gQ2FjaGVkIGV2ZW50cyBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlKHVzZXJJZCwgc3RhcnREYXRlLCBlbmREYXRlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmFuZ2VLZXkgPSBgJHtVU0VSX1BSRUZJWH0ke3VzZXJJZH06JHtEQVRFX1JBTkdFX1BSRUZJWH0ke3N0YXJ0RGF0ZX1fJHtlbmREYXRlfWA7XG4gICAgXG4gICAgLy8gVHJ5IGxvY2FsIGNhY2hlIGZpcnN0XG4gICAgY29uc3QgbG9jYWxEYXRhID0gbG9jYWxDYWNoZS5nZXQocmFuZ2VLZXkpO1xuICAgIGlmIChsb2NhbERhdGEpIHtcbiAgICAgIHJldHVybiBsb2NhbERhdGE7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSBSZWRpc1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZWRpc0NsaWVudC5nZXQocmFuZ2VLZXkpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIC8vIFN0b3JlIGluIGxvY2FsIGNhY2hlXG4gICAgICBsb2NhbENhY2hlLnNldChyYW5nZUtleSwgcGFyc2VkRGF0YSwgMTApOyAvLyAxMCBzZWNvbmRzXG4gICAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjYWNoZWQgZXZlbnRzIGZvciBkYXRlIHJhbmdlOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEludmFsaWRhdGUgY2FjaGVkIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBkYXRlIHJhbmdlXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVGhlIHVzZXIgSURcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydERhdGUgLSBTdGFydCBkYXRlIGluIElTTyBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmREYXRlIC0gRW5kIGRhdGUgaW4gSVNPIGZvcm1hdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW52YWxpZGF0ZURhdGVSYW5nZUNhY2hlKHVzZXJJZCwgc3RhcnREYXRlLCBlbmREYXRlKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IGFsbCBjYWNoZWQgcmFuZ2VzIGZvciB0aGlzIHVzZXJcbiAgICBjb25zdCBhbGxSYW5nZXMgPSBhd2FpdCByZWRpc0NsaWVudC5zbWVtYmVycyhgJHtVU0VSX1BSRUZJWH0ke3VzZXJJZH06JHtEQVRFX1JBTkdFX1BSRUZJWH1hbGxfcmFuZ2VzYCk7XG4gICAgXG4gICAgLy8gRmluZCByYW5nZXMgdGhhdCBvdmVybGFwIHdpdGggdGhlIHNwZWNpZmllZCByYW5nZVxuICAgIGNvbnN0IHJhbmdlc1RvSW52YWxpZGF0ZSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgcmFuZ2VLZXkgb2YgYWxsUmFuZ2VzKSB7XG4gICAgICAvLyBFeHRyYWN0IGRhdGVzIGZyb20gdGhlIGtleVxuICAgICAgY29uc3QgbWF0Y2ggPSByYW5nZUtleS5tYXRjaChuZXcgUmVnRXhwKGAke1VTRVJfUFJFRklYfSR7dXNlcklkfToke0RBVEVfUkFOR0VfUFJFRklYfSguKylfKC4rKSRgKSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgWywgY2FjaGVkU3RhcnQsIGNhY2hlZEVuZF0gPSBtYXRjaDtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHJhbmdlcyBvdmVybGFwXG4gICAgICAgIGlmICgoc3RhcnREYXRlIDw9IGNhY2hlZEVuZCkgJiYgKGVuZERhdGUgPj0gY2FjaGVkU3RhcnQpKSB7XG4gICAgICAgICAgcmFuZ2VzVG9JbnZhbGlkYXRlLnB1c2gocmFuZ2VLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIERlbGV0ZSB0aGUgb3ZlcmxhcHBpbmcgcmFuZ2VzXG4gICAgaWYgKHJhbmdlc1RvSW52YWxpZGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCByZWRpc0NsaWVudC5kZWwoLi4ucmFuZ2VzVG9JbnZhbGlkYXRlKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIHNldCBvZiBhbGwgcmFuZ2VzXG4gICAgICBhd2FpdCByZWRpc0NsaWVudC5zcmVtKGAke1VTRVJfUFJFRklYfSR7dXNlcklkfToke0RBVEVfUkFOR0VfUFJFRklYfWFsbF9yYW5nZXNgLCAuLi5yYW5nZXNUb0ludmFsaWRhdGUpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBmcm9tIGxvY2FsIGNhY2hlIHRvb1xuICAgICAgcmFuZ2VzVG9JbnZhbGlkYXRlLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgbG9jYWxDYWNoZS5kZWwoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgSW52YWxpZGF0ZWQgJHtyYW5nZXNUb0ludmFsaWRhdGUubGVuZ3RofSBvdmVybGFwcGluZyBkYXRlIHJhbmdlcyBmb3IgdXNlciAke3VzZXJJZH1gKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW52YWxpZGF0aW5nIGRhdGUgcmFuZ2UgY2FjaGU6JywgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogRmx1c2ggYWxsIGNhY2hlIGVudHJpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZsdXNoQ2FjaGUoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF0dGVybiA9IGAke0NBQ0hFX1BSRUZJWH0qYDtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgcmVkaXNDbGllbnQua2V5cyhwYXR0ZXJuKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCByZWRpc0NsaWVudC5kZWwoLi4ua2V5cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFsc28gY2xlYXIgZGF0ZSByYW5nZSBjYWNoZXNcbiAgICBjb25zdCBkYXRlUmFuZ2VQYXR0ZXJuID0gYCo6JHtEQVRFX1JBTkdFX1BSRUZJWH0qYDtcbiAgICBjb25zdCBkYXRlUmFuZ2VLZXlzID0gYXdhaXQgcmVkaXNDbGllbnQua2V5cyhkYXRlUmFuZ2VQYXR0ZXJuKTtcbiAgICBpZiAoZGF0ZVJhbmdlS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCByZWRpc0NsaWVudC5kZWwoLi4uZGF0ZVJhbmdlS2V5cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIGxvY2FsIGNhY2hlXG4gICAgbG9jYWxDYWNoZS5mbHVzaEFsbCgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDYWNoZSBmbHVzaGVkIHN1Y2Nlc3NmdWxseScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZsdXNoaW5nIGNhY2hlIGZyb20gUmVkaXM6JywgZXJyb3IpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlZGlzQ2xpZW50OyJdLCJuYW1lcyI6WyJSZWRpcyIsIk5vZGVDYWNoZSIsInJlZGlzQ2xpZW50IiwiaG9zdCIsInByb2Nlc3MiLCJlbnYiLCJSRURJU19IT1NUIiwicG9ydCIsIlJFRElTX1BPUlQiLCJwYXNzd29yZCIsIlJFRElTX1BBU1NXT1JEIiwiZGIiLCJSRURJU19EQiIsInJldHJ5U3RyYXRlZ3kiLCJ0aW1lcyIsImRlbGF5IiwiTWF0aCIsIm1pbiIsImxvY2FsQ2FjaGUiLCJzdGRUVEwiLCJvbiIsImNvbnNvbGUiLCJsb2ciLCJlcnIiLCJlcnJvciIsIkNPTlZFUlNBVElPTl9QUkVGSVgiLCJDQUNIRV9QUkVGSVgiLCJEQVRFX1JBTkdFX1BSRUZJWCIsIlVTRVJfUFJFRklYIiwiREVGQVVMVF9FWFBJUlkiLCJzYXZlQ29udmVyc2F0aW9uIiwidXNlcklkIiwibWVzc2FnZXMiLCJleHBpcnkiLCJrZXkiLCJzZXQiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0Q29udmVyc2F0aW9uIiwibG9jYWxEYXRhIiwiZ2V0IiwiZGF0YSIsInBhcnNlZERhdGEiLCJwYXJzZSIsImRlbGV0ZUNvbnZlcnNhdGlvbiIsImRlbCIsInNldENhY2hlIiwidmFsdWUiLCJjYWNoZUtleSIsImdldENhY2hlIiwiZGVsZXRlQ2FjaGUiLCJkZWxldGVDYWNoZUJ5UHJlZml4IiwicHJlZml4IiwicGF0dGVybiIsImtleXMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZXZlbnRzIiwicmFuZ2VLZXkiLCJzYWRkIiwiZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlIiwiaW52YWxpZGF0ZURhdGVSYW5nZUNhY2hlIiwiYWxsUmFuZ2VzIiwic21lbWJlcnMiLCJyYW5nZXNUb0ludmFsaWRhdGUiLCJtYXRjaCIsIlJlZ0V4cCIsImNhY2hlZFN0YXJ0IiwiY2FjaGVkRW5kIiwicHVzaCIsInNyZW0iLCJmbHVzaENhY2hlIiwiZGF0ZVJhbmdlUGF0dGVybiIsImRhdGVSYW5nZUtleXMiLCJmbHVzaEFsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/redisClient.js\n");

/***/ }),

/***/ "(api)/./lib/services/cacheService.js":
/*!**************************************!*\
  !*** ./lib/services/cacheService.js ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCachedEvents: () => (/* binding */ getCachedEvents),\n/* harmony export */   invalidateCache: () => (/* binding */ invalidateCache)\n/* harmony export */ });\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-cache */ \"node-cache\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../googleCalendar.js */ \"(api)/./googleCalendar.js\");\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _redisClient_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../redisClient.js */ \"(api)/./lib/redisClient.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_1__]);\nluxon__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// ES Module imports\n\n\n// Import the calendar function with correct name\n\n// Import Redis functions\n\n// Consider calling initializeDatabase() at application startup\n// --- Cache ---\nconst memoryCache = new (node_cache__WEBPACK_IMPORTED_MODULE_0___default())({\n    stdTTL: 300\n}); // 5 minutes TTL\n// --- Caching Logic ---\n// (Keep getCachedEvents and invalidateCache as previously defined and refined)\nasync function getCachedEvents(tokens, start_date, end_date) {\n    if (!tokens?.access_token) {\n        console.warn(\"Attempting to get events without access token. Required for calendar operations.\");\n        throw new Error(\"User authentication required to fetch calendar events.\");\n    }\n    // Derive a user-specific cache key prefix (more stable than token hash if possible)\n    // For now, using token hash as fallback\n    const tokenHash = tokens.access_token.substring(tokens.access_token.length - 10);\n    const userIdCachePrefix = `user_${tokenHash}`; // Replace with stable user ID if available\n    // Normalize dates for cache key consistency\n    const cacheKeyStart = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(start_date).toISODate();\n    const cacheKeyEnd = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(end_date).toISODate();\n    if (!cacheKeyStart || !cacheKeyEnd) {\n        throw new Error(`Invalid date format for caching: ${start_date}, ${end_date}`);\n    }\n    try {\n        const cachedEvents = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n        if (cachedEvents) {\n            console.log(`Cache HIT for events ${cacheKeyStart} to ${cacheKeyEnd}`);\n            // Ensure it returns an array even if cache stores null/undefined mistakenly\n            return Array.isArray(cachedEvents) ? cachedEvents : [];\n        }\n        console.log(`Cache MISS for events ${cacheKeyStart} to ${cacheKeyEnd}`);\n        // Fetch from API using the actual Calendar function\n        const events = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.getCalendarEvents)(tokens, new Date(start_date), new Date(end_date)); // Use imported function\n        if (events && Array.isArray(events)) {\n            await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.cacheEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd, events, 300); // 5 min TTL\n            console.log(`Stored events in Redis cache for ${cacheKeyStart} to ${cacheKeyEnd}`);\n            return events;\n        } else {\n            console.warn(`No events returned or non-array from fetchGCalendarEvents for ${cacheKeyStart}-${cacheKeyEnd}`);\n            return []; // Return empty array on failure or non-array result\n        }\n    } catch (error) {\n        console.error(`Error in getCachedEvents (${cacheKeyStart} to ${cacheKeyEnd}):`, error);\n        throw new Error(`Failed to fetch or cache calendar events: ${error.message}`);\n    }\n}\nasync function invalidateCache(tokens = null, startDate = null, endDate = null) {\n    memoryCache.flushAll(); // Always flush memory cache\n    console.log(\"Memory cache invalidated\");\n    if (tokens?.access_token && startDate && endDate) {\n        try {\n            const tokenHash = tokens.access_token.substring(tokens.access_token.length - 10);\n            const userIdCachePrefix = `user_${tokenHash}`; // Use consistent prefix\n            const startKey = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(startDate).toISODate();\n            const endKey = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(endDate).toISODate();\n            if (!startKey || !endKey) {\n                console.warn(`Cannot invalidate Redis: Invalid date format ${startDate}, ${endDate}`);\n                return;\n            }\n            await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.invalidateDateRangeCache)(userIdCachePrefix, startKey, endKey);\n            console.log(`Invalidated Redis cache for user ${userIdCachePrefix}, range ${startKey} to ${endKey}`);\n        } catch (error) {\n            console.error(\"Error invalidating Redis date range cache:\", error);\n        }\n    } else {\n        console.log(\"Skipping granular Redis cache invalidation (missing token or date range)\");\n    }\n}\n// Export the functions\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBT0csWUFBWSxDQUFDSyxTQUFTLENBQUNSLE9BQU9HLFlBQVksQ0FBQ00sTUFBTSxHQUFHO1lBQzdFLE1BQU1DLG9CQUFvQixDQUFDLEtBQUssRUFBRUgsVUFBVSxDQUFDLEVBQUUsd0JBQXdCO1lBQ3ZFLE1BQU1vQixXQUFXbkMsMkNBQVFBLENBQUNvQixPQUFPLENBQUNZLFdBQVdYLFNBQVM7WUFDdEQsTUFBTWUsU0FBU3BDLDJDQUFRQSxDQUFDb0IsT0FBTyxDQUFDYSxTQUFTWixTQUFTO1lBQ2pELElBQUksQ0FBQ2MsWUFBWSxDQUFDQyxRQUFRO2dCQUN0QnhCLFFBQVFDLElBQUksQ0FBQyxDQUFDLDZDQUE2QyxFQUFFbUIsVUFBVSxFQUFFLEVBQUVDLFFBQVEsQ0FBQztnQkFDcEY7WUFDSjtZQUNELE1BQU03Qix5RUFBd0JBLENBQUNjLG1CQUFtQmlCLFVBQVVDO1lBQzVEeEIsUUFBUVksR0FBRyxDQUFDLENBQUMsaUNBQWlDLEVBQUVOLGtCQUFrQixRQUFRLEVBQUVpQixTQUFTLElBQUksRUFBRUMsT0FBTyxDQUFDO1FBQ3ZHLEVBQUUsT0FBT1AsT0FBTztZQUNaakIsUUFBUWlCLEtBQUssQ0FBQyw4Q0FBOENBO1FBQ2hFO0lBQ0osT0FBTztRQUNIakIsUUFBUVksR0FBRyxDQUFDO0lBQ2hCO0FBQ0o7QUFFQSx1QkFBdUI7QUFDcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nY2FsZW5kYXJhcHAvLi9saWIvc2VydmljZXMvY2FjaGVTZXJ2aWNlLmpzPzgxNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRVMgTW9kdWxlIGltcG9ydHNcbmltcG9ydCBOb2RlQ2FjaGUgZnJvbSAnbm9kZS1jYWNoZSc7XG5pbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2x1eG9uJztcbi8vIEltcG9ydCB0aGUgY2FsZW5kYXIgZnVuY3Rpb24gd2l0aCBjb3JyZWN0IG5hbWVcbmltcG9ydCB7IGdldENhbGVuZGFyRXZlbnRzIH0gZnJvbSAnLi4vLi4vZ29vZ2xlQ2FsZW5kYXIuanMnO1xuLy8gSW1wb3J0IFJlZGlzIGZ1bmN0aW9uc1xuaW1wb3J0IHsgZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlLCBjYWNoZUV2ZW50c0ZvckRhdGVSYW5nZSwgaW52YWxpZGF0ZURhdGVSYW5nZUNhY2hlIH0gZnJvbSAnLi4vcmVkaXNDbGllbnQuanMnO1xuXG4vLyBDb25zaWRlciBjYWxsaW5nIGluaXRpYWxpemVEYXRhYmFzZSgpIGF0IGFwcGxpY2F0aW9uIHN0YXJ0dXBcblxuLy8gLS0tIENhY2hlIC0tLVxuY29uc3QgbWVtb3J5Q2FjaGUgPSBuZXcgTm9kZUNhY2hlKHsgc3RkVFRMOiAzMDAgfSk7IC8vIDUgbWludXRlcyBUVExcblxuLy8gLS0tIENhY2hpbmcgTG9naWMgLS0tXG4vLyAoS2VlcCBnZXRDYWNoZWRFdmVudHMgYW5kIGludmFsaWRhdGVDYWNoZSBhcyBwcmV2aW91c2x5IGRlZmluZWQgYW5kIHJlZmluZWQpXG5hc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRFdmVudHModG9rZW5zLCBzdGFydF9kYXRlLCBlbmRfZGF0ZSkge1xuICBpZiAoIXRva2Vucz8uYWNjZXNzX3Rva2VuKSB7XG4gICAgIGNvbnNvbGUud2FybihcIkF0dGVtcHRpbmcgdG8gZ2V0IGV2ZW50cyB3aXRob3V0IGFjY2VzcyB0b2tlbi4gUmVxdWlyZWQgZm9yIGNhbGVuZGFyIG9wZXJhdGlvbnMuXCIpO1xuICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkIHRvIGZldGNoIGNhbGVuZGFyIGV2ZW50cy5cIik7XG4gIH1cbiAgLy8gRGVyaXZlIGEgdXNlci1zcGVjaWZpYyBjYWNoZSBrZXkgcHJlZml4IChtb3JlIHN0YWJsZSB0aGFuIHRva2VuIGhhc2ggaWYgcG9zc2libGUpXG4gIC8vIEZvciBub3csIHVzaW5nIHRva2VuIGhhc2ggYXMgZmFsbGJhY2tcbiAgY29uc3QgdG9rZW5IYXNoID0gdG9rZW5zLmFjY2Vzc190b2tlbi5zdWJzdHJpbmcodG9rZW5zLmFjY2Vzc190b2tlbi5sZW5ndGggLSAxMCk7XG4gIGNvbnN0IHVzZXJJZENhY2hlUHJlZml4ID0gYHVzZXJfJHt0b2tlbkhhc2h9YDsgLy8gUmVwbGFjZSB3aXRoIHN0YWJsZSB1c2VyIElEIGlmIGF2YWlsYWJsZVxuXG4gIC8vIE5vcm1hbGl6ZSBkYXRlcyBmb3IgY2FjaGUga2V5IGNvbnNpc3RlbmN5XG4gIGNvbnN0IGNhY2hlS2V5U3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHN0YXJ0X2RhdGUpLnRvSVNPRGF0ZSgpO1xuICBjb25zdCBjYWNoZUtleUVuZCA9IERhdGVUaW1lLmZyb21JU08oZW5kX2RhdGUpLnRvSVNPRGF0ZSgpO1xuICAgaWYgKCFjYWNoZUtleVN0YXJ0IHx8ICFjYWNoZUtleUVuZCkge1xuICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIGZvcm1hdCBmb3IgY2FjaGluZzogJHtzdGFydF9kYXRlfSwgJHtlbmRfZGF0ZX1gKTtcbiAgIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlZEV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWRDYWNoZVByZWZpeCwgY2FjaGVLZXlTdGFydCwgY2FjaGVLZXlFbmQpO1xuICAgIGlmIChjYWNoZWRFdmVudHMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBISVQgZm9yIGV2ZW50cyAke2NhY2hlS2V5U3RhcnR9IHRvICR7Y2FjaGVLZXlFbmR9YCk7XG4gICAgICAvLyBFbnN1cmUgaXQgcmV0dXJucyBhbiBhcnJheSBldmVuIGlmIGNhY2hlIHN0b3JlcyBudWxsL3VuZGVmaW5lZCBtaXN0YWtlbmx5XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjYWNoZWRFdmVudHMpID8gY2FjaGVkRXZlbnRzIDogW107XG4gICAgfVxuICAgICBjb25zb2xlLmxvZyhgQ2FjaGUgTUlTUyBmb3IgZXZlbnRzICR7Y2FjaGVLZXlTdGFydH0gdG8gJHtjYWNoZUtleUVuZH1gKTtcblxuICAgIC8vIEZldGNoIGZyb20gQVBJIHVzaW5nIHRoZSBhY3R1YWwgQ2FsZW5kYXIgZnVuY3Rpb25cbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCBnZXRDYWxlbmRhckV2ZW50cyh0b2tlbnMsIG5ldyBEYXRlKHN0YXJ0X2RhdGUpLCBuZXcgRGF0ZShlbmRfZGF0ZSkpOyAvLyBVc2UgaW1wb3J0ZWQgZnVuY3Rpb25cbiAgICBpZiAoZXZlbnRzICYmIEFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgYXdhaXQgY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UodXNlcklkQ2FjaGVQcmVmaXgsIGNhY2hlS2V5U3RhcnQsIGNhY2hlS2V5RW5kLCBldmVudHMsIDMwMCk7IC8vIDUgbWluIFRUTFxuICAgICAgY29uc29sZS5sb2coYFN0b3JlZCBldmVudHMgaW4gUmVkaXMgY2FjaGUgZm9yICR7Y2FjaGVLZXlTdGFydH0gdG8gJHtjYWNoZUtleUVuZH1gKTtcbiAgICAgIHJldHVybiBldmVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBldmVudHMgcmV0dXJuZWQgb3Igbm9uLWFycmF5IGZyb20gZmV0Y2hHQ2FsZW5kYXJFdmVudHMgZm9yICR7Y2FjaGVLZXlTdGFydH0tJHtjYWNoZUtleUVuZH1gKTtcbiAgICAgICAgcmV0dXJuIFtdOyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgb24gZmFpbHVyZSBvciBub24tYXJyYXkgcmVzdWx0XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGdldENhY2hlZEV2ZW50cyAoJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfSk6YCwgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG9yIGNhY2hlIGNhbGVuZGFyIGV2ZW50czogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZSh0b2tlbnMgPSBudWxsLCBzdGFydERhdGUgPSBudWxsLCBlbmREYXRlID0gbnVsbCkge1xuICAgIG1lbW9yeUNhY2hlLmZsdXNoQWxsKCk7IC8vIEFsd2F5cyBmbHVzaCBtZW1vcnkgY2FjaGVcbiAgICBjb25zb2xlLmxvZyhcIk1lbW9yeSBjYWNoZSBpbnZhbGlkYXRlZFwiKTtcblxuICAgIGlmICh0b2tlbnM/LmFjY2Vzc190b2tlbiAmJiBzdGFydERhdGUgJiYgZW5kRGF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5IYXNoID0gdG9rZW5zLmFjY2Vzc190b2tlbi5zdWJzdHJpbmcodG9rZW5zLmFjY2Vzc190b2tlbi5sZW5ndGggLSAxMCk7XG4gICAgICAgICAgICBjb25zdCB1c2VySWRDYWNoZVByZWZpeCA9IGB1c2VyXyR7dG9rZW5IYXNofWA7IC8vIFVzZSBjb25zaXN0ZW50IHByZWZpeFxuICAgICAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBEYXRlVGltZS5mcm9tSVNPKHN0YXJ0RGF0ZSkudG9JU09EYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBlbmRLZXkgPSBEYXRlVGltZS5mcm9tSVNPKGVuZERhdGUpLnRvSVNPRGF0ZSgpO1xuICAgICAgICAgICAgIGlmICghc3RhcnRLZXkgfHwgIWVuZEtleSkge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBpbnZhbGlkYXRlIFJlZGlzOiBJbnZhbGlkIGRhdGUgZm9ybWF0ICR7c3RhcnREYXRlfSwgJHtlbmREYXRlfWApO1xuICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgaW52YWxpZGF0ZURhdGVSYW5nZUNhY2hlKHVzZXJJZENhY2hlUHJlZml4LCBzdGFydEtleSwgZW5kS2V5KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnZhbGlkYXRlZCBSZWRpcyBjYWNoZSBmb3IgdXNlciAke3VzZXJJZENhY2hlUHJlZml4fSwgcmFuZ2UgJHtzdGFydEtleX0gdG8gJHtlbmRLZXl9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW52YWxpZGF0aW5nIFJlZGlzIGRhdGUgcmFuZ2UgY2FjaGU6XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2tpcHBpbmcgZ3JhbnVsYXIgUmVkaXMgY2FjaGUgaW52YWxpZGF0aW9uIChtaXNzaW5nIHRva2VuIG9yIGRhdGUgcmFuZ2UpXCIpO1xuICAgIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBmdW5jdGlvbnNcbmV4cG9ydCB7IGdldENhY2hlZEV2ZW50cywgaW52YWxpZGF0ZUNhY2hlIH07XG4iXSwibmFtZXMiOlsiTm9kZUNhY2hlIiwiRGF0ZVRpbWUiLCJnZXRDYWxlbmRhckV2ZW50cyIsImdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSIsImNhY2hlRXZlbnRzRm9yRGF0ZVJhbmdlIiwiaW52YWxpZGF0ZURhdGVSYW5nZUNhY2hlIiwibWVtb3J5Q2FjaGUiLCJzdGRUVEwiLCJnZXRDYWNoZWRFdmVudHMiLCJ0b2tlbnMiLCJzdGFydF9kYXRlIiwiZW5kX2RhdGUiLCJhY2Nlc3NfdG9rZW4iLCJjb25zb2xlIiwid2FybiIsIkVycm9yIiwidG9rZW5IYXNoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwidXNlcklkQ2FjaGVQcmVmaXgiLCJjYWNoZUtleVN0YXJ0IiwiZnJvbUlTTyIsInRvSVNPRGF0ZSIsImNhY2hlS2V5RW5kIiwiY2FjaGVkRXZlbnRzIiwibG9nIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlbnRzIiwiRGF0ZSIsImVycm9yIiwibWVzc2FnZSIsImludmFsaWRhdGVDYWNoZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJmbHVzaEFsbCIsInN0YXJ0S2V5IiwiZW5kS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/services/cacheService.js\n");

/***/ }),

/***/ "(api)/./lib/tools/checkForConflicts.js":
/*!****************************************!*\
  !*** ./lib/tools/checkForConflicts.js ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkForConflicts: () => (/* binding */ checkForConflicts)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/cacheService.js */ \"(api)/./lib/services/cacheService.js\");\n/* harmony import */ var _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_2__]);\n([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n// --- Conflict Checking ---\n// (Keep checkForConflicts as previously defined and refined)\nasync function checkForConflicts(tokens, start, end) {\n    try {\n        const checkStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(start);\n        const checkEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(end);\n        if (!checkStart.isValid || !checkEnd.isValid) {\n            throw new Error(`Invalid start/end time for conflict check: start=${start}, end=${end}`);\n        }\n        const dayStart = checkStart.startOf(\"day\").toISO();\n        const dayEnd = checkEnd.endOf(\"day\").toISO(); // Check whole day for simplicity\n        const events = await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__.getCachedEvents)(tokens, dayStart, dayEnd);\n        const conflicts = events.filter((event)=>{\n            try {\n                const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                if (!eventStart.isValid || !eventEnd.isValid) return false; // Skip invalid event data\n                return eventStart < checkEnd && checkStart < eventEnd; // Overlap condition\n            } catch  {\n                return false;\n            } // Ignore parsing errors for individual events\n        });\n        if (conflicts.length > 0) {\n            console.log(`Conflict detected for ${start} - ${end}.`);\n            const duration = checkEnd.diff(checkStart, \"minutes\").minutes;\n            // Ensure findAvailableSlotsUtil handles potential errors gracefully\n            let suggestions = [];\n            try {\n                suggestions = await (0,_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_2__.findAvailableSlots)(events, duration, dayStart, dayEnd, \"Event\", \"any\");\n            } catch (suggestionError) {\n                console.error(\"Error finding suggestions during conflict check:\", suggestionError);\n            }\n            return {\n                conflicts: true,\n                suggestions: suggestions || []\n            };\n        }\n        return {\n            conflicts: false,\n            suggestions: []\n        };\n    } catch (error) {\n        console.error(\"Error checking for conflicts:\", error);\n        // Return conflict=true to be safe on error, prevents accidental scheduling\n        return {\n            conflicts: true,\n            suggestions: [],\n            error: `Conflict check failed: ${error.message}`\n        };\n    }\n}\n// Export the function\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvdG9vbHMvY2hlY2tGb3JDb25mbGljdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNpQztBQUM2QjtBQUNKO0FBRTFELDRCQUE0QjtBQUM1Qiw2REFBNkQ7QUFDN0QsZUFBZUcsa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsR0FBRztJQUNqRCxJQUFJO1FBQ0YsTUFBTUMsYUFBYVAsMkNBQVFBLENBQUNRLE9BQU8sQ0FBQ0g7UUFDcEMsTUFBTUksV0FBV1QsMkNBQVFBLENBQUNRLE9BQU8sQ0FBQ0Y7UUFFbEMsSUFBSSxDQUFDQyxXQUFXRyxPQUFPLElBQUksQ0FBQ0QsU0FBU0MsT0FBTyxFQUFFO1lBQzFDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGlEQUFpRCxFQUFFTixNQUFNLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1FBQzNGO1FBRUEsTUFBTU0sV0FBV0wsV0FBV00sT0FBTyxDQUFDLE9BQU9DLEtBQUs7UUFDaEQsTUFBTUMsU0FBU04sU0FBU08sS0FBSyxDQUFDLE9BQU9GLEtBQUssSUFBSSxpQ0FBaUM7UUFFL0UsTUFBTUcsU0FBUyxNQUFNaEIsMEVBQWVBLENBQUNHLFFBQVFRLFVBQVVHO1FBRXZELE1BQU1HLFlBQVlELE9BQU9FLE1BQU0sQ0FBQ0MsQ0FBQUE7WUFDN0IsSUFBSTtnQkFDQSxNQUFNQyxhQUFhckIsMkNBQVFBLENBQUNRLE9BQU8sQ0FBQ1ksTUFBTWYsS0FBSyxFQUFFaUIsWUFBWUYsTUFBTWYsS0FBSyxFQUFFa0I7Z0JBQzFFLE1BQU1DLFdBQVd4QiwyQ0FBUUEsQ0FBQ1EsT0FBTyxDQUFDWSxNQUFNZCxHQUFHLEVBQUVnQixZQUFZRixNQUFNZCxHQUFHLEVBQUVpQjtnQkFDcEUsSUFBSSxDQUFDRixXQUFXWCxPQUFPLElBQUksQ0FBQ2MsU0FBU2QsT0FBTyxFQUFFLE9BQU8sT0FBTywwQkFBMEI7Z0JBQ3RGLE9BQU9XLGFBQWFaLFlBQVlGLGFBQWFpQixVQUFVLG9CQUFvQjtZQUMvRSxFQUFFLE9BQU07Z0JBQUUsT0FBTztZQUFPLEVBQUUsOENBQThDO1FBQzNFO1FBRUEsSUFBSU4sVUFBVU8sTUFBTSxHQUFHLEdBQUc7WUFDeEJDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHNCQUFzQixFQUFFdEIsTUFBTSxHQUFHLEVBQUVDLElBQUksQ0FBQyxDQUFDO1lBQ3RELE1BQU1zQixXQUFXbkIsU0FBU29CLElBQUksQ0FBQ3RCLFlBQVksV0FBV3VCLE9BQU87WUFDN0Qsb0VBQW9FO1lBQ3BFLElBQUlDLGNBQWMsRUFBRTtZQUNwQixJQUFJO2dCQUNDQSxjQUFjLE1BQU03Qix1RUFBa0JBLENBQUNlLFFBQVFXLFVBQVVoQixVQUFVRyxRQUFRLFNBQVM7WUFDekYsRUFBRSxPQUFPaUIsaUJBQWlCO2dCQUNyQk4sUUFBUU8sS0FBSyxDQUFDLG9EQUFvREQ7WUFDdkU7WUFDQSxPQUFPO2dCQUFFZCxXQUFXO2dCQUFNYSxhQUFhQSxlQUFlLEVBQUU7WUFBQztRQUMzRDtRQUNBLE9BQU87WUFBRWIsV0FBVztZQUFPYSxhQUFhLEVBQUU7UUFBQztJQUM3QyxFQUFFLE9BQU9FLE9BQU87UUFDWlAsUUFBUU8sS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsMkVBQTJFO1FBQzNFLE9BQU87WUFBRWYsV0FBVztZQUFNYSxhQUFhLEVBQUU7WUFBRUUsT0FBTyxDQUFDLHVCQUF1QixFQUFFQSxNQUFNQyxPQUFPLENBQUMsQ0FBQztRQUFDO0lBQ2hHO0FBQ0Y7QUFFQSxzQkFBc0I7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi90b29scy9jaGVja0ZvckNvbmZsaWN0cy5qcz81NTU5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgeyBnZXRDYWNoZWRFdmVudHMgfSBmcm9tICcuLi9zZXJ2aWNlcy9jYWNoZVNlcnZpY2UuanMnO1xuaW1wb3J0IHsgZmluZEF2YWlsYWJsZVNsb3RzIH0gZnJvbSAnLi9zY2hlZHVsaW5nVXRpbHMuanMnO1xuXG4vLyAtLS0gQ29uZmxpY3QgQ2hlY2tpbmcgLS0tXG4vLyAoS2VlcCBjaGVja0ZvckNvbmZsaWN0cyBhcyBwcmV2aW91c2x5IGRlZmluZWQgYW5kIHJlZmluZWQpXG5hc3luYyBmdW5jdGlvbiBjaGVja0ZvckNvbmZsaWN0cyh0b2tlbnMsIHN0YXJ0LCBlbmQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjaGVja1N0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzdGFydCk7XG4gICAgY29uc3QgY2hlY2tFbmQgPSBEYXRlVGltZS5mcm9tSVNPKGVuZCk7XG5cbiAgICBpZiAoIWNoZWNrU3RhcnQuaXNWYWxpZCB8fCAhY2hlY2tFbmQuaXNWYWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhcnQvZW5kIHRpbWUgZm9yIGNvbmZsaWN0IGNoZWNrOiBzdGFydD0ke3N0YXJ0fSwgZW5kPSR7ZW5kfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRheVN0YXJ0ID0gY2hlY2tTdGFydC5zdGFydE9mKCdkYXknKS50b0lTTygpO1xuICAgIGNvbnN0IGRheUVuZCA9IGNoZWNrRW5kLmVuZE9mKCdkYXknKS50b0lTTygpOyAvLyBDaGVjayB3aG9sZSBkYXkgZm9yIHNpbXBsaWNpdHlcblxuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50cyh0b2tlbnMsIGRheVN0YXJ0LCBkYXlFbmQpO1xuXG4gICAgY29uc3QgY29uZmxpY3RzID0gZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICAgdHJ5IHtcbiAgICAgICAgICAgY29uc3QgZXZlbnRTdGFydCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlKTtcbiAgICAgICAgICAgY29uc3QgZXZlbnRFbmQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50LmVuZD8uZGF0ZVRpbWUgfHwgZXZlbnQuZW5kPy5kYXRlKTtcbiAgICAgICAgICAgaWYgKCFldmVudFN0YXJ0LmlzVmFsaWQgfHwgIWV2ZW50RW5kLmlzVmFsaWQpIHJldHVybiBmYWxzZTsgLy8gU2tpcCBpbnZhbGlkIGV2ZW50IGRhdGFcbiAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RhcnQgPCBjaGVja0VuZCAmJiBjaGVja1N0YXJ0IDwgZXZlbnRFbmQ7IC8vIE92ZXJsYXAgY29uZGl0aW9uXG4gICAgICAgfSBjYXRjaCB7IHJldHVybiBmYWxzZTsgfSAvLyBJZ25vcmUgcGFyc2luZyBlcnJvcnMgZm9yIGluZGl2aWR1YWwgZXZlbnRzXG4gICAgfSk7XG5cbiAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGBDb25mbGljdCBkZXRlY3RlZCBmb3IgJHtzdGFydH0gLSAke2VuZH0uYCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGNoZWNrRW5kLmRpZmYoY2hlY2tTdGFydCwgJ21pbnV0ZXMnKS5taW51dGVzO1xuICAgICAgLy8gRW5zdXJlIGZpbmRBdmFpbGFibGVTbG90c1V0aWwgaGFuZGxlcyBwb3RlbnRpYWwgZXJyb3JzIGdyYWNlZnVsbHlcbiAgICAgIGxldCBzdWdnZXN0aW9ucyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgICAgc3VnZ2VzdGlvbnMgPSBhd2FpdCBmaW5kQXZhaWxhYmxlU2xvdHMoZXZlbnRzLCBkdXJhdGlvbiwgZGF5U3RhcnQsIGRheUVuZCwgXCJFdmVudFwiLCBcImFueVwiKTtcbiAgICAgIH0gY2F0Y2ggKHN1Z2dlc3Rpb25FcnJvcikge1xuICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmluZGluZyBzdWdnZXN0aW9ucyBkdXJpbmcgY29uZmxpY3QgY2hlY2s6XCIsIHN1Z2dlc3Rpb25FcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjb25mbGljdHM6IHRydWUsIHN1Z2dlc3Rpb25zOiBzdWdnZXN0aW9ucyB8fCBbXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25mbGljdHM6IGZhbHNlLCBzdWdnZXN0aW9uczogW10gfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBmb3IgY29uZmxpY3RzOlwiLCBlcnJvcik7XG4gICAgICAvLyBSZXR1cm4gY29uZmxpY3Q9dHJ1ZSB0byBiZSBzYWZlIG9uIGVycm9yLCBwcmV2ZW50cyBhY2NpZGVudGFsIHNjaGVkdWxpbmdcbiAgICAgIHJldHVybiB7IGNvbmZsaWN0czogdHJ1ZSwgc3VnZ2VzdGlvbnM6IFtdLCBlcnJvcjogYENvbmZsaWN0IGNoZWNrIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAgfTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIGZ1bmN0aW9uXG5leHBvcnQgeyBjaGVja0ZvckNvbmZsaWN0cyB9O1xuIl0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiZ2V0Q2FjaGVkRXZlbnRzIiwiZmluZEF2YWlsYWJsZVNsb3RzIiwiY2hlY2tGb3JDb25mbGljdHMiLCJ0b2tlbnMiLCJzdGFydCIsImVuZCIsImNoZWNrU3RhcnQiLCJmcm9tSVNPIiwiY2hlY2tFbmQiLCJpc1ZhbGlkIiwiRXJyb3IiLCJkYXlTdGFydCIsInN0YXJ0T2YiLCJ0b0lTTyIsImRheUVuZCIsImVuZE9mIiwiZXZlbnRzIiwiY29uZmxpY3RzIiwiZmlsdGVyIiwiZXZlbnQiLCJldmVudFN0YXJ0IiwiZGF0ZVRpbWUiLCJkYXRlIiwiZXZlbnRFbmQiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwiZHVyYXRpb24iLCJkaWZmIiwibWludXRlcyIsInN1Z2dlc3Rpb25zIiwic3VnZ2VzdGlvbkVycm9yIiwiZXJyb3IiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/tools/checkForConflicts.js\n");

/***/ }),

/***/ "(api)/./lib/tools/eventHelpers.js":
/*!***********************************!*\
  !*** ./lib/tools/eventHelpers.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   listTodaysEvents: () => (/* binding */ listTodaysEvents),\n/* harmony export */   suggestEventTime: () => (/* binding */ suggestEventTime)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/cacheService.js */ \"(api)/./lib/services/cacheService.js\");\n/* harmony import */ var _formatters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatters.js */ \"(api)/./lib/tools/formatters.js\");\n/* harmony import */ var _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _formatters_js__WEBPACK_IMPORTED_MODULE_2__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__]);\n([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _formatters_js__WEBPACK_IMPORTED_MODULE_2__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n// --- Additional Utility Functions ---\nasync function listTodaysEvents(accessToken = null) {\n    if (!accessToken) return \"Authentication required.\";\n    try {\n        const tokens = {\n            access_token: accessToken\n        };\n        const today = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        const startOfDay = today.startOf(\"day\").toISO();\n        const endOfDay = today.endOf(\"day\").toISO();\n        const events = await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__.getCachedEvents)(tokens, startOfDay, endOfDay);\n        return (0,_formatters_js__WEBPACK_IMPORTED_MODULE_2__.formatCalendarEvents)(events);\n    } catch (error) {\n        console.error(\"Failed to fetch today's events:\", error);\n        return `Failed to fetch events: ${error.message}`;\n    }\n}\nasync function suggestEventTime(duration, preferredTime = \"any\", accessToken = null, activity = \"event\") {\n    if (!accessToken) return \"Authentication required.\";\n    if (!duration || typeof duration !== \"number\" || duration <= 0) return \"Invalid duration.\";\n    try {\n        const tokens = {\n            access_token: accessToken\n        };\n        const now = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        const startDate = now.toISO();\n        const endDate = now.plus({\n            days: 7\n        }).endOf(\"day\").toISO(); // Search next 7 days\n        const suggestions = await (0,_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__.findAvailableSlots)([], duration, startDate, endDate, activity, preferredTime);\n        return (0,_formatters_js__WEBPACK_IMPORTED_MODULE_2__.formatToolResponse)(\"findAvailableSlots\", suggestions);\n    } catch (error) {\n        console.error(\"Failed to suggest event time:\", error);\n        return `Failed to suggest time: ${error.message}`;\n    }\n}\n// Export the functions\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvdG9vbHMvZXZlbnRIZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNpQztBQUM2QjtBQUNhO0FBQ2pCO0FBRTFELHVDQUF1QztBQUN2QyxlQUFlSyxpQkFBaUJDLGNBQWMsSUFBSTtJQUNoRCxJQUFJLENBQUNBLGFBQWEsT0FBTztJQUN6QixJQUFJO1FBQ0YsTUFBTUMsU0FBUztZQUFFQyxjQUFjRjtRQUFZO1FBQzNDLE1BQU1HLFFBQVFULDJDQUFRQSxDQUFDVSxHQUFHO1FBQzFCLE1BQU1DLGFBQWFGLE1BQU1HLE9BQU8sQ0FBQyxPQUFPQyxLQUFLO1FBQzdDLE1BQU1DLFdBQVdMLE1BQU1NLEtBQUssQ0FBQyxPQUFPRixLQUFLO1FBQ3pDLE1BQU1HLFNBQVMsTUFBTWYsMEVBQWVBLENBQUNNLFFBQVFJLFlBQVlHO1FBQ3pELE9BQU9aLG9FQUFvQkEsQ0FBQ2M7SUFDOUIsRUFBRSxPQUFPQyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBbUNBO1FBQ2pELE9BQU8sQ0FBQyx3QkFBd0IsRUFBRUEsTUFBTUUsT0FBTyxDQUFDLENBQUM7SUFDbkQ7QUFDRjtBQUVBLGVBQWVDLGlCQUFpQkMsUUFBUSxFQUFFQyxnQkFBZ0IsS0FBSyxFQUFFaEIsY0FBYyxJQUFJLEVBQUVpQixXQUFXLE9BQU87SUFDcEcsSUFBSSxDQUFDakIsYUFBYSxPQUFPO0lBQ3pCLElBQUksQ0FBQ2UsWUFBWSxPQUFPQSxhQUFhLFlBQVlBLFlBQVksR0FBRyxPQUFPO0lBQ3hFLElBQUk7UUFDRixNQUFNZCxTQUFTO1lBQUVDLGNBQWNGO1FBQVk7UUFDM0MsTUFBTUksTUFBTVYsMkNBQVFBLENBQUNVLEdBQUc7UUFDeEIsTUFBTWMsWUFBWWQsSUFBSUcsS0FBSztRQUMzQixNQUFNWSxVQUFVZixJQUFJZ0IsSUFBSSxDQUFDO1lBQUVDLE1BQU07UUFBRSxHQUFHWixLQUFLLENBQUMsT0FBT0YsS0FBSyxJQUFJLHFCQUFxQjtRQUNqRixNQUFNZSxjQUFjLE1BQU14Qix1RUFBa0JBLENBQzFDLEVBQUUsRUFDRmlCLFVBQ0FHLFdBQ0FDLFNBQ0FGLFVBQ0FEO1FBRUYsT0FBT25CLGtFQUFrQkEsQ0FBQyxzQkFBc0J5QjtJQUNsRCxFQUFFLE9BQU9YLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsT0FBTyxDQUFDLHdCQUF3QixFQUFFQSxNQUFNRSxPQUFPLENBQUMsQ0FBQztJQUNuRDtBQUNGO0FBRUEsdUJBQXVCO0FBQ3VCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2NhbGVuZGFyYXBwLy4vbGliL3Rvb2xzL2V2ZW50SGVscGVycy5qcz9jNDk1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgeyBnZXRDYWNoZWRFdmVudHMgfSBmcm9tICcuLi9zZXJ2aWNlcy9jYWNoZVNlcnZpY2UuanMnO1xuaW1wb3J0IHsgZm9ybWF0Q2FsZW5kYXJFdmVudHMsIGZvcm1hdFRvb2xSZXNwb25zZSB9IGZyb20gJy4vZm9ybWF0dGVycy5qcyc7XG5pbXBvcnQgeyBmaW5kQXZhaWxhYmxlU2xvdHMgfSBmcm9tICcuL3NjaGVkdWxpbmdVdGlscy5qcyc7XG5cbi8vIC0tLSBBZGRpdGlvbmFsIFV0aWxpdHkgRnVuY3Rpb25zIC0tLVxuYXN5bmMgZnVuY3Rpb24gbGlzdFRvZGF5c0V2ZW50cyhhY2Nlc3NUb2tlbiA9IG51bGwpIHtcbiAgaWYgKCFhY2Nlc3NUb2tlbikgcmV0dXJuIFwiQXV0aGVudGljYXRpb24gcmVxdWlyZWQuXCI7XG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgY29uc3QgdG9kYXkgPSBEYXRlVGltZS5ub3coKTtcbiAgICBjb25zdCBzdGFydE9mRGF5ID0gdG9kYXkuc3RhcnRPZignZGF5JykudG9JU08oKTtcbiAgICBjb25zdCBlbmRPZkRheSA9IHRvZGF5LmVuZE9mKCdkYXknKS50b0lTTygpO1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50cyh0b2tlbnMsIHN0YXJ0T2ZEYXksIGVuZE9mRGF5KTtcbiAgICByZXR1cm4gZm9ybWF0Q2FsZW5kYXJFdmVudHMoZXZlbnRzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHRvZGF5J3MgZXZlbnRzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGBGYWlsZWQgdG8gZmV0Y2ggZXZlbnRzOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzdWdnZXN0RXZlbnRUaW1lKGR1cmF0aW9uLCBwcmVmZXJyZWRUaW1lID0gJ2FueScsIGFjY2Vzc1Rva2VuID0gbnVsbCwgYWN0aXZpdHkgPSBcImV2ZW50XCIpIHtcbiAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiBcIkF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkLlwiO1xuICAgaWYgKCFkdXJhdGlvbiB8fCB0eXBlb2YgZHVyYXRpb24gIT09ICdudW1iZXInIHx8IGR1cmF0aW9uIDw9IDApIHJldHVybiBcIkludmFsaWQgZHVyYXRpb24uXCI7XG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgY29uc3Qgbm93ID0gRGF0ZVRpbWUubm93KCk7XG4gICAgY29uc3Qgc3RhcnREYXRlID0gbm93LnRvSVNPKCk7XG4gICAgY29uc3QgZW5kRGF0ZSA9IG5vdy5wbHVzKHsgZGF5czogNyB9KS5lbmRPZignZGF5JykudG9JU08oKTsgLy8gU2VhcmNoIG5leHQgNyBkYXlzXG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBhd2FpdCBmaW5kQXZhaWxhYmxlU2xvdHMoXG4gICAgICBbXSwgLy8gV2lsbCBiZSBmZXRjaGVkIGluc2lkZSBmaW5kQXZhaWxhYmxlU2xvdHNcbiAgICAgIGR1cmF0aW9uLCBcbiAgICAgIHN0YXJ0RGF0ZSwgXG4gICAgICBlbmREYXRlLCBcbiAgICAgIGFjdGl2aXR5LFxuICAgICAgcHJlZmVycmVkVGltZVxuICAgICk7XG4gICAgcmV0dXJuIGZvcm1hdFRvb2xSZXNwb25zZSgnZmluZEF2YWlsYWJsZVNsb3RzJywgc3VnZ2VzdGlvbnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc3VnZ2VzdCBldmVudCB0aW1lOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGBGYWlsZWQgdG8gc3VnZ2VzdCB0aW1lOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIGZ1bmN0aW9uc1xuZXhwb3J0IHsgbGlzdFRvZGF5c0V2ZW50cywgc3VnZ2VzdEV2ZW50VGltZSB9O1xuIl0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiZ2V0Q2FjaGVkRXZlbnRzIiwiZm9ybWF0Q2FsZW5kYXJFdmVudHMiLCJmb3JtYXRUb29sUmVzcG9uc2UiLCJmaW5kQXZhaWxhYmxlU2xvdHMiLCJsaXN0VG9kYXlzRXZlbnRzIiwiYWNjZXNzVG9rZW4iLCJ0b2tlbnMiLCJhY2Nlc3NfdG9rZW4iLCJ0b2RheSIsIm5vdyIsInN0YXJ0T2ZEYXkiLCJzdGFydE9mIiwidG9JU08iLCJlbmRPZkRheSIsImVuZE9mIiwiZXZlbnRzIiwiZXJyb3IiLCJjb25zb2xlIiwibWVzc2FnZSIsInN1Z2dlc3RFdmVudFRpbWUiLCJkdXJhdGlvbiIsInByZWZlcnJlZFRpbWUiLCJhY3Rpdml0eSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJwbHVzIiwiZGF5cyIsInN1Z2dlc3Rpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/tools/eventHelpers.js\n");

/***/ }),

/***/ "(api)/./lib/tools/formatters.js":
/*!*********************************!*\
  !*** ./lib/tools/formatters.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatCalendarEvents: () => (/* binding */ formatCalendarEvents),\n/* harmony export */   formatEventTime: () => (/* binding */ formatEventTime),\n/* harmony export */   formatToolResponse: () => (/* binding */ formatToolResponse)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__]);\nluxon__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nfunction formatEventTime(eventTime) {\n    // ... (Keep implementation from chatbot.js) ...\n    try {\n        const dt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(eventTime);\n        if (dt.isValid) {\n            return dt.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATETIME_FULL);\n        }\n        const dateOnly = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(eventTime, {\n            zone: \"utc\"\n        });\n        if (dateOnly.isValid) {\n            return dateOnly.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATE_FULL) + \" (All day)\";\n        }\n        return eventTime;\n    } catch (e) {\n        console.warn(\"Error formatting event time:\", eventTime, e);\n        return String(eventTime); // Ensure returns string\n    }\n}\nfunction formatCalendarEvents(events) {\n    if (!events) return \"No events found or an error occurred.\";\n    if (!Array.isArray(events)) return \"An error occurred processing events.\";\n    if (events.length === 0) return \"No events found for the specified time period.\";\n    return events.map((event)=>{\n        try {\n            const start = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n            const end = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n            if (!start.isValid || !end.isValid) return `❓ Invalid date found for event: ${event.summary || event.id}`;\n            const isAllDay = !event.start?.dateTime;\n            // Include the event ID in the formatted output (hidden with a zero-width space for reference)\n            let formattedEvent = `📅 ${event.summary || \"(No Title)\"} [ID:​${event.id}]\\n`;\n            formattedEvent += `   📆 ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATE_FULL)}\\n`;\n            if (!isAllDay) {\n                formattedEvent += `   🕒 ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.TIME_SIMPLE)} - ${end.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.TIME_SIMPLE)}\\n`;\n            } else {\n                formattedEvent += `   🕒 All Day\\n`;\n            }\n            if (event.description) formattedEvent += `   📝 ${event.description}\\n`;\n            if (event.location) formattedEvent += `   📍 ${event.location}\\n`;\n            if (event.reminders?.useDefault === false && Array.isArray(event.reminders.overrides)) {\n                formattedEvent += `   🔔 Reminders: ${event.reminders.overrides.map((r)=>`${r.minutes} min`).join(\", \")}\\n`;\n            }\n            return formattedEvent.trim(); // Trim each event string\n        } catch (mapError) {\n            console.error(\"Error mapping event:\", event, mapError);\n            return `❓ Error processing event: ${event.summary || event.id}`;\n        }\n    }).join(\"\\n\\n\"); // Add space between events\n}\n// --- Formatting Tool Responses for the LLM ---\nfunction formatToolResponse(functionName, result) {\n    try {\n        // Explicitly handle null/undefined results first\n        if (result == null) {\n            console.warn(`Tool ${functionName} returned null or undefined.`);\n            return `Tool ${functionName} did not return a result. (Status: FAILED)`;\n        }\n        // Handle known error shapes returned by tool functions\n        if (typeof result === \"string\" && result.toLowerCase().startsWith(\"error:\")) return `${result} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.error) return `Error executing ${functionName}: ${result.error} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.success === false) return `Tool ${functionName} failed: ${result.message || \"No details.\"} (Status: FAILED)`;\n        // --- Format successful results ---\n        switch(functionName){\n            case \"saveUserPreference\":\n                return result.success ? `✅ Pref saved: ${result.message} (Status: SUCCESS)` : `❌ Pref fail: ${result.message} (Status: FAILED)`;\n            case \"addCalendarEvents\":\n                if (!Array.isArray(result)) return \"Error: Invalid response format from addCalendarEvents. (Status: FAILED)\";\n                if (result.length === 0) return \"No events were processed. (Status: NEUTRAL)\";\n                return result.map((item)=>{\n                    if (!item) return \"❓ Invalid item in result array. (Status: FAILED)\";\n                    if (item.error) {\n                        const summary = item.summary || \"?\";\n                        if (item.conflict) {\n                            // Include suggestions if available\n                            const suggestionText = item.suggestions && item.suggestions.length > 0 ? ` Suggested slots: ${item.suggestions.map((s)=>`${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(s.start).toFormat(\"h:mma\")} - ${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(s.end).toFormat(\"h:mma\")}`).join(\", \")}` : \"\";\n                            return `⚠️ Conflict detected for event \"${summary}\".${suggestionText} (Status: CONFLICT)`;\n                        } else {\n                            return `❌ Failed to add event \"${summary}\": ${item.error} (Status: FAILED)`;\n                        }\n                    } else if (item.id && item.summary && (item.start?.dateTime || item.start?.date)) {\n                        try {\n                            const startStr = formatEventTime(item.start.dateTime || item.start.date); // Use existing helper\n                            return `✅ Event added: \"${item.summary}\" starting ${startStr}. (ID: ${item.id}) (Status: SUCCESS)`;\n                        } catch (e) {\n                            console.error(\"Error formatting success message for added event:\", item, e);\n                            return `✅ Event added: \"${item.summary}\" (details unavailable). (ID: ${item.id}) (Status: SUCCESS)`;\n                        }\n                    } else {\n                        console.warn(\"Unexpected item shape in addCalendarEvents result:\", item);\n                        return `❓ Unknown outcome for an event attempt. (Status: UNKNOWN)`;\n                    }\n                }).join(\"\\n\");\n            case \"getCalendarEvents\":\n                if (typeof result === \"string\") return `🗓️ Events: ${result} (Status: ${result.toLowerCase().startsWith(\"error\") ? \"FAILED\" : \"SUCCESS\"})`;\n                if (!Array.isArray(result)) return \"Error: Invalid getCalendarEvents response. (Status: FAILED)\";\n                return result.length === 0 ? \"\\uD83D\\uDDD3️ No events found. (Status: SUCCESS)\" : `🗓️ Found ${result.length} event(s):\\n\\n${formatCalendarEvents(result)} (Status: SUCCESS)`;\n            case \"deleteCalendarEvent\":\n                return result.success ? `🗑️ Event \"${result.summary || result.eventId}\" deleted. (Status: SUCCESS)` // Use eventId if summary wasn't fetched/returned\n                 : `❌ Failed to delete event ${result.eventId || \"?\"}: ${result.error || result.message || \"?\"} (Status: FAILED)`;\n            case \"updateCalendarEvent\":\n                // Check if result has an ID, indicating success from googleCalendar update function\n                if (result && result.id) {\n                    return `✏️ Event \"${result.summary || eventId}\" updated. (ID: ${result.id}) (Status: SUCCESS)`;\n                } else {\n                    // Handle potential error objects passed back\n                    const errorMsg = result?.error || result?.message || JSON.stringify(result);\n                    return `❌ Failed to update event: ${errorMsg} (Status: FAILED)`;\n                }\n            case \"findAvailableSlots\":\n                if (!Array.isArray(result)) return \"Error: Invalid findAvailableSlots response. (Status: FAILED)\";\n                if (result.length === 0) return `🕒 No available slots found matching criteria. (Status: SUCCESS)`;\n                // Format slots with success status\n                const formattedSlots = result.map((slot)=>`${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.start).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATETIME_SHORT)} - ${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.end).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.TIME_SIMPLE)}`).join(\"\\n\");\n                return `🕒 Found ${result.length} available slot(s):\\n\\n${formattedSlots}\\n\\n(Status: SUCCESS)`;\n            case \"getWeatherForecast\":\n                return `🌤️ Weather for ${result.location} on ${result.date}: ${result.forecast || \"N/A\"} (Status: ${result.forecast && !result.forecast.includes(\"unavailable\") ? \"SUCCESS\" : \"PARTIAL\"})`;\n            case \"deleteCalendarEventsByQuery\":\n                return result.success ? `🗑️ ${result.message} (Deleted Count: ${result.deletedCount}) (Status: SUCCESS)` : `❌ Failed bulk delete: ${result.message || result.error || \"?\"} (Status: FAILED)`;\n            default:\n                // Safely stringify other results with status indicators\n                if (typeof result === \"object\" && result !== null) {\n                    const status = result.success === true ? \"SUCCESS\" : result.success === false ? \"FAILED\" : \"UNKNOWN\";\n                    return `${JSON.stringify(result)} (Status: ${status})`;\n                } else {\n                    return `${String(result)} (Status: UNKNOWN)`;\n                }\n        }\n    } catch (formatError) {\n        console.error(`CRITICAL: Error *within* formatToolResponse for ${functionName}:`, formatError, \"Raw result:\", result);\n        // Return a guaranteed string error message\n        return `Internal Error: Failed to format the result for ${functionName}. (Status: ERROR)`;\n    }\n}\n// Export the functions\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUSxJQUFJLE1BQU0sVUFBVSxFQUFFbkIsT0FBT21CLFFBQVEsSUFBSSxDQUFDbkIsT0FBT21CLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDLGlCQUFpQixZQUFZLFVBQVUsQ0FBQyxDQUFDO1lBRS9MLEtBQUs7Z0JBQ0QsT0FBT3BCLE9BQU9HLE9BQU8sR0FDZixDQUFDLElBQUksRUFBRUgsT0FBT0ksT0FBTyxDQUFDLGlCQUFpQixFQUFFSixPQUFPcUIsWUFBWSxDQUFDLG1CQUFtQixDQUFDLEdBQ2pGLENBQUMsc0JBQXNCLEVBQUVyQixPQUFPSSxPQUFPLElBQUlKLE9BQU9ILEtBQUssSUFBSSxJQUFJLGlCQUFpQixDQUFDO1lBRTNGO2dCQUNJLHdEQUF3RDtnQkFDeEQsSUFBSSxPQUFPRyxXQUFXLFlBQVlBLFdBQVcsTUFBTTtvQkFDL0MsTUFBTXNCLFNBQVN0QixPQUFPRyxPQUFPLEtBQUssT0FBTyxZQUFhSCxPQUFPRyxPQUFPLEtBQUssUUFBUSxXQUFXO29CQUM1RixPQUFPLENBQUMsRUFBRVcsS0FBS0MsU0FBUyxDQUFDZixRQUFRLFVBQVUsRUFBRXNCLE9BQU8sQ0FBQyxDQUFDO2dCQUMxRCxPQUFPO29CQUNILE9BQU8sQ0FBQyxFQUFFcEQsT0FBTzhCLFFBQVEsa0JBQWtCLENBQUM7Z0JBQ2hEO1FBQ1I7SUFDSixFQUFFLE9BQU91QixhQUFhO1FBQ2xCdkQsUUFBUTZCLEtBQUssQ0FBQyxDQUFDLGdEQUFnRCxFQUFFRSxhQUFhLENBQUMsQ0FBQyxFQUFFd0IsYUFBYSxlQUFldkI7UUFDOUcsMkNBQTJDO1FBQzNDLE9BQU8sQ0FBQyxnREFBZ0QsRUFBRUQsYUFBYSxpQkFBaUIsQ0FBQztJQUM3RjtBQUNKO0FBRUEsdUJBQXVCO0FBQzhDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2NhbGVuZGFyYXBwLy4vbGliL3Rvb2xzL2Zvcm1hdHRlcnMuanM/NTk3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSAnbHV4b24nO1xuXG5mdW5jdGlvbiBmb3JtYXRFdmVudFRpbWUoZXZlbnRUaW1lKSB7XG4gICAgLy8gLi4uIChLZWVwIGltcGxlbWVudGF0aW9uIGZyb20gY2hhdGJvdC5qcykgLi4uXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZHQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50VGltZSk7XG4gICAgICAgIGlmIChkdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZHQudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfRlVMTCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZU9ubHkgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50VGltZSwgeyB6b25lOiAndXRjJyB9KTtcbiAgICAgICAgaWYgKGRhdGVPbmx5LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlT25seS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpICsgXCIgKEFsbCBkYXkpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50VGltZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZvcm1hdHRpbmcgZXZlbnQgdGltZTpcIiwgZXZlbnRUaW1lLCBlKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhldmVudFRpbWUpOyAvLyBFbnN1cmUgcmV0dXJucyBzdHJpbmdcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENhbGVuZGFyRXZlbnRzKGV2ZW50cykge1xuICAgIGlmICghZXZlbnRzKSByZXR1cm4gXCJObyBldmVudHMgZm91bmQgb3IgYW4gZXJyb3Igb2NjdXJyZWQuXCI7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHJldHVybiBcIkFuIGVycm9yIG9jY3VycmVkIHByb2Nlc3NpbmcgZXZlbnRzLlwiO1xuICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJObyBldmVudHMgZm91bmQgZm9yIHRoZSBzcGVjaWZpZWQgdGltZSBwZXJpb2QuXCI7XG5cbiAgICByZXR1cm4gZXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kPy5kYXRlVGltZSB8fCBldmVudC5lbmQ/LmRhdGUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydC5pc1ZhbGlkIHx8ICFlbmQuaXNWYWxpZCkgcmV0dXJuIGDinZMgSW52YWxpZCBkYXRlIGZvdW5kIGZvciBldmVudDogJHtldmVudC5zdW1tYXJ5IHx8IGV2ZW50LmlkfWA7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzQWxsRGF5ID0gIWV2ZW50LnN0YXJ0Py5kYXRlVGltZTtcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGV2ZW50IElEIGluIHRoZSBmb3JtYXR0ZWQgb3V0cHV0IChoaWRkZW4gd2l0aCBhIHplcm8td2lkdGggc3BhY2UgZm9yIHJlZmVyZW5jZSlcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZWRFdmVudCA9IGDwn5OFICR7ZXZlbnQuc3VtbWFyeSB8fCAnKE5vIFRpdGxlKSd9IFtJRDrigIske2V2ZW50LmlkfV1cXG5gO1xuICAgICAgICAgICAgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCfk4YgJHtzdGFydC50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpfVxcbmA7XG4gICAgICAgICAgICBpZiAoIWlzQWxsRGF5KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCflZIgJHtzdGFydC50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSl9IC0gJHtlbmQudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpfVxcbmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5WSIEFsbCBEYXlcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmRlc2NyaXB0aW9uKSBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+TnSAke2V2ZW50LmRlc2NyaXB0aW9ufVxcbmA7XG4gICAgICAgICAgICBpZiAoZXZlbnQubG9jYXRpb24pIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5ONICR7ZXZlbnQubG9jYXRpb259XFxuYDtcbiAgICAgICAgICAgIGlmIChldmVudC5yZW1pbmRlcnM/LnVzZURlZmF1bHQgPT09IGZhbHNlICYmIEFycmF5LmlzQXJyYXkoZXZlbnQucmVtaW5kZXJzLm92ZXJyaWRlcykpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+UlCBSZW1pbmRlcnM6ICR7ZXZlbnQucmVtaW5kZXJzLm92ZXJyaWRlcy5tYXAociA9PiBgJHtyLm1pbnV0ZXN9IG1pbmApLmpvaW4oJywgJyl9XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRFdmVudC50cmltKCk7IC8vIFRyaW0gZWFjaCBldmVudCBzdHJpbmdcbiAgICAgICAgfSBjYXRjaCAobWFwRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBtYXBwaW5nIGV2ZW50OlwiLCBldmVudCwgbWFwRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGDinZMgRXJyb3IgcHJvY2Vzc2luZyBldmVudDogJHtldmVudC5zdW1tYXJ5IHx8IGV2ZW50LmlkfWA7XG4gICAgICAgIH1cbiAgICB9KS5qb2luKCdcXG5cXG4nKTsgLy8gQWRkIHNwYWNlIGJldHdlZW4gZXZlbnRzXG59XG5cblxuLy8gLS0tIEZvcm1hdHRpbmcgVG9vbCBSZXNwb25zZXMgZm9yIHRoZSBMTE0gLS0tXG5mdW5jdGlvbiBmb3JtYXRUb29sUmVzcG9uc2UoZnVuY3Rpb25OYW1lLCByZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IGhhbmRsZSBudWxsL3VuZGVmaW5lZCByZXN1bHRzIGZpcnN0XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUb29sICR7ZnVuY3Rpb25OYW1lfSByZXR1cm5lZCBudWxsIG9yIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICAgIHJldHVybiBgVG9vbCAke2Z1bmN0aW9uTmFtZX0gZGlkIG5vdCByZXR1cm4gYSByZXN1bHQuIChTdGF0dXM6IEZBSUxFRClgO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGtub3duIGVycm9yIHNoYXBlcyByZXR1cm5lZCBieSB0b29sIGZ1bmN0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgJiYgcmVzdWx0LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZXJyb3I6JykpXG4gICAgICAgICAgICByZXR1cm4gYCR7cmVzdWx0fSAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZXhlY3V0aW5nICR7ZnVuY3Rpb25OYW1lfTogJHtyZXN1bHQuZXJyb3J9IChTdGF0dXM6IEZBSUxFRClgO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGBUb29sICR7ZnVuY3Rpb25OYW1lfSBmYWlsZWQ6ICR7cmVzdWx0Lm1lc3NhZ2UgfHwgJ05vIGRldGFpbHMuJ30gKFN0YXR1czogRkFJTEVEKWA7XG5cbiAgICAgICAgLy8gLS0tIEZvcm1hdCBzdWNjZXNzZnVsIHJlc3VsdHMgLS0tXG4gICAgICAgIHN3aXRjaCAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdzYXZlVXNlclByZWZlcmVuY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IGDinIUgUHJlZiBzYXZlZDogJHtyZXN1bHQubWVzc2FnZX0gKFN0YXR1czogU1VDQ0VTUylgIDogYOKdjCBQcmVmIGZhaWw6ICR7cmVzdWx0Lm1lc3NhZ2V9IChTdGF0dXM6IEZBSUxFRClgO1xuXG4gICAgICAgICAgICBjYXNlICdhZGRDYWxlbmRhckV2ZW50cyc6XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHJldHVybiBcIkVycm9yOiBJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIGFkZENhbGVuZGFyRXZlbnRzLiAoU3RhdHVzOiBGQUlMRUQpXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHJldHVybiBcIk5vIGV2ZW50cyB3ZXJlIHByb2Nlc3NlZC4gKFN0YXR1czogTkVVVFJBTClcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gJ+KdkyBJbnZhbGlkIGl0ZW0gaW4gcmVzdWx0IGFycmF5LiAoU3RhdHVzOiBGQUlMRUQpJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIHsgLy8gSGFuZGxlIGV4cGxpY2l0IGVycm9ycyBmaXJzdCAoY29uZmxpY3QsIHZhbGlkYXRpb24sIEFQSSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSBpdGVtLnN1bW1hcnkgfHwgJz8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29uZmxpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHN1Z2dlc3Rpb25zIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25UZXh0ID0gaXRlbS5zdWdnZXN0aW9ucyAmJiBpdGVtLnN1Z2dlc3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgIFN1Z2dlc3RlZCBzbG90czogJHtpdGVtLnN1Z2dlc3Rpb25zLm1hcChzID0+IGAke0RhdGVUaW1lLmZyb21JU08ocy5zdGFydCkudG9Gb3JtYXQoJ2g6bW1hJyl9IC0gJHtEYXRlVGltZS5mcm9tSVNPKHMuZW5kKS50b0Zvcm1hdCgnaDptbWEnKX1gKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKaoO+4jyBDb25mbGljdCBkZXRlY3RlZCBmb3IgZXZlbnQgXCIke3N1bW1hcnl9XCIuJHtzdWdnZXN0aW9uVGV4dH0gKFN0YXR1czogQ09ORkxJQ1QpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinYwgRmFpbGVkIHRvIGFkZCBldmVudCBcIiR7c3VtbWFyeX1cIjogJHtpdGVtLmVycm9yfSAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmlkICYmIGl0ZW0uc3VtbWFyeSAmJiAoaXRlbS5zdGFydD8uZGF0ZVRpbWUgfHwgaXRlbS5zdGFydD8uZGF0ZSkpIHsgLy8gQXNzdW1lIHN1Y2Nlc3MgaWYga2V5IGZpZWxkcyBleGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydFN0ciA9IGZvcm1hdEV2ZW50VGltZShpdGVtLnN0YXJ0LmRhdGVUaW1lIHx8IGl0ZW0uc3RhcnQuZGF0ZSk7IC8vIFVzZSBleGlzdGluZyBoZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKchSBFdmVudCBhZGRlZDogXCIke2l0ZW0uc3VtbWFyeX1cIiBzdGFydGluZyAke3N0YXJ0U3RyfS4gKElEOiAke2l0ZW0uaWR9KSAoU3RhdHVzOiBTVUNDRVNTKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZvcm1hdHRpbmcgc3VjY2VzcyBtZXNzYWdlIGZvciBhZGRlZCBldmVudDpcIiwgaXRlbSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinIUgRXZlbnQgYWRkZWQ6IFwiJHtpdGVtLnN1bW1hcnl9XCIgKGRldGFpbHMgdW5hdmFpbGFibGUpLiAoSUQ6ICR7aXRlbS5pZH0pIChTdGF0dXM6IFNVQ0NFU1MpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gRmFsbGJhY2sgZm9yIHVuZXhwZWN0ZWQgc2hhcGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIGl0ZW0gc2hhcGUgaW4gYWRkQ2FsZW5kYXJFdmVudHMgcmVzdWx0OlwiLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBg4p2TIFVua25vd24gb3V0Y29tZSBmb3IgYW4gZXZlbnQgYXR0ZW1wdC4gKFN0YXR1czogVU5LTk9XTilgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ2dldENhbGVuZGFyRXZlbnRzJzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBg8J+Xk++4jyBFdmVudHM6ICR7cmVzdWx0fSAoU3RhdHVzOiAke3Jlc3VsdC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Vycm9yJykgPyAnRkFJTEVEJyA6ICdTVUNDRVNTJ30pYDtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IEludmFsaWQgZ2V0Q2FsZW5kYXJFdmVudHMgcmVzcG9uc2UuIChTdGF0dXM6IEZBSUxFRClcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IFwi8J+Xk++4jyBObyBldmVudHMgZm91bmQuIChTdGF0dXM6IFNVQ0NFU1MpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBg8J+Xk++4jyBGb3VuZCAke3Jlc3VsdC5sZW5ndGh9IGV2ZW50KHMpOlxcblxcbiR7Zm9ybWF0Q2FsZW5kYXJFdmVudHMocmVzdWx0KX0gKFN0YXR1czogU1VDQ0VTUylgO1xuXG4gICAgICAgICAgICBjYXNlICdkZWxldGVDYWxlbmRhckV2ZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgPyBg8J+Xke+4jyBFdmVudCBcIiR7cmVzdWx0LnN1bW1hcnkgfHwgcmVzdWx0LmV2ZW50SWR9XCIgZGVsZXRlZC4gKFN0YXR1czogU1VDQ0VTUylgIC8vIFVzZSBldmVudElkIGlmIHN1bW1hcnkgd2Fzbid0IGZldGNoZWQvcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgOiBg4p2MIEZhaWxlZCB0byBkZWxldGUgZXZlbnQgJHtyZXN1bHQuZXZlbnRJZCB8fCAnPyd9OiAke3Jlc3VsdC5lcnJvciB8fCByZXN1bHQubWVzc2FnZSB8fCAnPyd9IChTdGF0dXM6IEZBSUxFRClgO1xuXG4gICAgICAgICAgICBjYXNlICd1cGRhdGVDYWxlbmRhckV2ZW50JzpcbiAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcmVzdWx0IGhhcyBhbiBJRCwgaW5kaWNhdGluZyBzdWNjZXNzIGZyb20gZ29vZ2xlQ2FsZW5kYXIgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinI/vuI8gRXZlbnQgXCIke3Jlc3VsdC5zdW1tYXJ5IHx8IGV2ZW50SWR9XCIgdXBkYXRlZC4gKElEOiAke3Jlc3VsdC5pZH0pIChTdGF0dXM6IFNVQ0NFU1MpYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgcG90ZW50aWFsIGVycm9yIG9iamVjdHMgcGFzc2VkIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSByZXN1bHQ/LmVycm9yIHx8IHJlc3VsdD8ubWVzc2FnZSB8fCBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKdjCBGYWlsZWQgdG8gdXBkYXRlIGV2ZW50OiAke2Vycm9yTXNnfSAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmRBdmFpbGFibGVTbG90cyc6XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBJbnZhbGlkIGZpbmRBdmFpbGFibGVTbG90cyByZXNwb25zZS4gKFN0YXR1czogRkFJTEVEKVwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYPCflZIgTm8gYXZhaWxhYmxlIHNsb3RzIGZvdW5kIG1hdGNoaW5nIGNyaXRlcmlhLiAoU3RhdHVzOiBTVUNDRVNTKWA7XG4gICAgICAgICAgICAgICAgLy8gRm9ybWF0IHNsb3RzIHdpdGggc3VjY2VzcyBzdGF0dXNcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRTbG90cyA9IHJlc3VsdC5tYXAoc2xvdCA9PlxuICAgICAgICAgICAgICAgICAgICBgJHtEYXRlVGltZS5mcm9tSVNPKHNsb3Quc3RhcnQpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKX0gLSAke0RhdGVUaW1lLmZyb21JU08oc2xvdC5lbmQpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKX1gXG4gICAgICAgICAgICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYPCflZIgRm91bmQgJHtyZXN1bHQubGVuZ3RofSBhdmFpbGFibGUgc2xvdChzKTpcXG5cXG4ke2Zvcm1hdHRlZFNsb3RzfVxcblxcbihTdGF0dXM6IFNVQ0NFU1MpYDtcblxuICAgICAgICAgICAgY2FzZSAnZ2V0V2VhdGhlckZvcmVjYXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYPCfjKTvuI8gV2VhdGhlciBmb3IgJHtyZXN1bHQubG9jYXRpb259IG9uICR7cmVzdWx0LmRhdGV9OiAke3Jlc3VsdC5mb3JlY2FzdCB8fCAnTi9BJ30gKFN0YXR1czogJHtyZXN1bHQuZm9yZWNhc3QgJiYgIXJlc3VsdC5mb3JlY2FzdC5pbmNsdWRlcygndW5hdmFpbGFibGUnKSA/ICdTVUNDRVNTJyA6ICdQQVJUSUFMJ30pYDtcblxuICAgICAgICAgICAgY2FzZSAnZGVsZXRlQ2FsZW5kYXJFdmVudHNCeVF1ZXJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgPyBg8J+Xke+4jyAke3Jlc3VsdC5tZXNzYWdlfSAoRGVsZXRlZCBDb3VudDogJHtyZXN1bHQuZGVsZXRlZENvdW50fSkgKFN0YXR1czogU1VDQ0VTUylgXG4gICAgICAgICAgICAgICAgICAgIDogYOKdjCBGYWlsZWQgYnVsayBkZWxldGU6ICR7cmVzdWx0Lm1lc3NhZ2UgfHwgcmVzdWx0LmVycm9yIHx8ICc/J30gKFN0YXR1czogRkFJTEVEKWA7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gU2FmZWx5IHN0cmluZ2lmeSBvdGhlciByZXN1bHRzIHdpdGggc3RhdHVzIGluZGljYXRvcnNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3VsdC5zdWNjZXNzID09PSB0cnVlID8gJ1NVQ0NFU1MnIDogKHJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSA/ICdGQUlMRUQnIDogJ1VOS05PV04nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9IChTdGF0dXM6ICR7c3RhdHVzfSlgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtTdHJpbmcocmVzdWx0KX0gKFN0YXR1czogVU5LTk9XTilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGZvcm1hdEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYENSSVRJQ0FMOiBFcnJvciAqd2l0aGluKiBmb3JtYXRUb29sUmVzcG9uc2UgZm9yICR7ZnVuY3Rpb25OYW1lfTpgLCBmb3JtYXRFcnJvciwgXCJSYXcgcmVzdWx0OlwiLCByZXN1bHQpO1xuICAgICAgICAvLyBSZXR1cm4gYSBndWFyYW50ZWVkIHN0cmluZyBlcnJvciBtZXNzYWdlXG4gICAgICAgIHJldHVybiBgSW50ZXJuYWwgRXJyb3I6IEZhaWxlZCB0byBmb3JtYXQgdGhlIHJlc3VsdCBmb3IgJHtmdW5jdGlvbk5hbWV9LiAoU3RhdHVzOiBFUlJPUilgO1xuICAgIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBmdW5jdGlvbnNcbmV4cG9ydCB7IGZvcm1hdEV2ZW50VGltZSwgZm9ybWF0Q2FsZW5kYXJFdmVudHMsIGZvcm1hdFRvb2xSZXNwb25zZSB9O1xuIl0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiZm9ybWF0RXZlbnRUaW1lIiwiZXZlbnRUaW1lIiwiZHQiLCJmcm9tSVNPIiwiaXNWYWxpZCIsInRvTG9jYWxlU3RyaW5nIiwiREFURVRJTUVfRlVMTCIsImRhdGVPbmx5Iiwiem9uZSIsIkRBVEVfRlVMTCIsImUiLCJjb25zb2xlIiwid2FybiIsIlN0cmluZyIsImZvcm1hdENhbGVuZGFyRXZlbnRzIiwiZXZlbnRzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwibWFwIiwiZXZlbnQiLCJzdGFydCIsImRhdGVUaW1lIiwiZGF0ZSIsImVuZCIsInN1bW1hcnkiLCJpZCIsImlzQWxsRGF5IiwiZm9ybWF0dGVkRXZlbnQiLCJUSU1FX1NJTVBMRSIsImRlc2NyaXB0aW9uIiwibG9jYXRpb24iLCJyZW1pbmRlcnMiLCJ1c2VEZWZhdWx0Iiwib3ZlcnJpZGVzIiwiciIsIm1pbnV0ZXMiLCJqb2luIiwidHJpbSIsIm1hcEVycm9yIiwiZXJyb3IiLCJmb3JtYXRUb29sUmVzcG9uc2UiLCJmdW5jdGlvbk5hbWUiLCJyZXN1bHQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJzdWNjZXNzIiwibWVzc2FnZSIsIml0ZW0iLCJjb25mbGljdCIsInN1Z2dlc3Rpb25UZXh0Iiwic3VnZ2VzdGlvbnMiLCJzIiwidG9Gb3JtYXQiLCJzdGFydFN0ciIsImV2ZW50SWQiLCJlcnJvck1zZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb3JtYXR0ZWRTbG90cyIsInNsb3QiLCJEQVRFVElNRV9TSE9SVCIsImZvcmVjYXN0IiwiaW5jbHVkZXMiLCJkZWxldGVkQ291bnQiLCJzdGF0dXMiLCJmb3JtYXRFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/tools/formatters.js\n");

/***/ }),

/***/ "(api)/./lib/tools/schedulingUtils.js":
/*!**************************************!*\
  !*** ./lib/tools/schedulingUtils.js ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAvailableSlots: () => (/* binding */ findAvailableSlots),\n/* harmony export */   formatAvailableSlots: () => (/* binding */ formatAvailableSlots)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__]);\nluxon__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * Default working hours configuration\n * Can be extended to fetch from user preferences in the future\n */ const DEFAULT_WORKING_HOURS = {\n    start: 9,\n    end: 17,\n    workDays: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ]\n};\n/**\n * Find available time slots for a new event\n * @param {Array} events - List of calendar events\n * @param {number} duration - Duration of the event in minutes\n * @param {string} startDate - Start date to search from in ISO format\n * @param {string} endDate - End date to search until in ISO format\n * @param {string} activity - Type of activity being scheduled\n * @param {string} timePreference - Preferred time of day (morning, afternoon, evening, any)\n * @param {Object} workingHours - Optional working hours configuration\n * @returns {Array} - List of available time slots with pros and cons\n */ function findAvailableSlots(events, duration, startDate, endDate, activity, timePreference = \"any\", workingHours = DEFAULT_WORKING_HOURS) {\n    // Convert inputs to Luxon objects\n    const start = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(startDate);\n    const end = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(endDate);\n    const durationMinutes = duration;\n    // Create a list of busy intervals from events\n    const busyIntervals = events.map((event)=>{\n        const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start.dateTime || event.start.date);\n        const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end.dateTime || event.end.date);\n        return {\n            interval: luxon__WEBPACK_IMPORTED_MODULE_0__.Interval.fromDateTimes(eventStart, eventEnd),\n            summary: event.summary\n        };\n    });\n    // Generate potential slots\n    const slots = generatePotentialSlots(start, end, durationMinutes, busyIntervals, timePreference, workingHours);\n    // Evaluate and rank slots\n    const evaluatedSlots = evaluateSlots(slots, busyIntervals, durationMinutes, activity, timePreference);\n    // Return top slots (limited to 3)\n    return evaluatedSlots.slice(0, 3);\n}\n/**\n * Generate potential time slots based on constraints\n * @param {DateTime} start - Start date/time to search from\n * @param {DateTime} end - End date/time to search until\n * @param {number} durationMinutes - Duration in minutes\n * @param {Array} busyIntervals - List of busy time intervals\n * @param {string} timePreference - Preferred time of day\n * @param {Object} workingHours - Working hours configuration\n * @returns {Array} - List of potential time slots\n */ function generatePotentialSlots(start, end, durationMinutes, busyIntervals, timePreference, workingHours) {\n    const slots = [];\n    const slotDuration = luxon__WEBPACK_IMPORTED_MODULE_0__.Duration.fromObject({\n        minutes: durationMinutes\n    });\n    // Start from the beginning of the search period\n    let currentTime = start;\n    // Iterate through each day in the search period\n    while(currentTime < end){\n        // Check if this is a working day\n        const isWorkingDay = workingHours.workDays.includes(currentTime.weekday);\n        if (isWorkingDay) {\n            // Set start time to either current time or beginning of working hours\n            let dayStart = currentTime.set({\n                hour: workingHours.start,\n                minute: 0,\n                second: 0,\n                millisecond: 0\n            });\n            // If we're already past the working hours start for today, use current time\n            if (currentTime > dayStart) {\n                dayStart = currentTime;\n            }\n            // End of working hours for today\n            const dayEnd = currentTime.set({\n                hour: workingHours.end,\n                minute: 0,\n                second: 0,\n                millisecond: 0\n            });\n            // Generate slots for this day\n            let slotStart = dayStart;\n            // Use 30-minute increments for slot generation\n            while(slotStart.plus(slotDuration) <= dayEnd){\n                const slotEnd = slotStart.plus(slotDuration);\n                const currentSlot = luxon__WEBPACK_IMPORTED_MODULE_0__.Interval.fromDateTimes(slotStart, slotEnd);\n                // Check if this slot overlaps with any busy intervals\n                const isAvailable = !busyIntervals.some((busy)=>busy.interval.overlaps(currentSlot));\n                if (isAvailable) {\n                    // Check if this slot matches the time preference\n                    const hour = slotStart.hour;\n                    let matchesPreference = true;\n                    if (timePreference === \"morning\" && (hour < 8 || hour >= 12)) {\n                        matchesPreference = false;\n                    } else if (timePreference === \"afternoon\" && (hour < 12 || hour >= 17)) {\n                        matchesPreference = false;\n                    } else if (timePreference === \"evening\" && (hour < 17 || hour >= 21)) {\n                        matchesPreference = false;\n                    }\n                    if (matchesPreference) {\n                        slots.push({\n                            start: slotStart.toISO(),\n                            end: slotEnd.toISO(),\n                            startDateTime: slotStart,\n                            endDateTime: slotEnd\n                        });\n                    }\n                }\n                // Move to next slot (30-minute increments)\n                slotStart = slotStart.plus({\n                    minutes: 30\n                });\n            }\n        }\n        // Move to next day\n        currentTime = currentTime.plus({\n            days: 1\n        }).startOf(\"day\");\n    }\n    return slots;\n}\n/**\n * Evaluate and rank available time slots\n * @param {Array} slots - List of potential time slots\n * @param {Array} busyIntervals - List of busy time intervals\n * @param {number} durationMinutes - Duration in minutes\n * @param {string} activity - Type of activity\n * @param {string} timePreference - Preferred time of day\n * @returns {Array} - Evaluated and ranked slots with pros and cons\n */ function evaluateSlots(slots, busyIntervals, durationMinutes, activity, timePreference) {\n    return slots.map((slot)=>{\n        const slotStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.start);\n        const slotEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.end);\n        const slotInterval = luxon__WEBPACK_IMPORTED_MODULE_0__.Interval.fromDateTimes(slotStart, slotEnd);\n        // Generate pros and cons\n        const { pros, cons } = generateProsAndCons(slotStart, slotEnd, busyIntervals, activity, timePreference);\n        // Calculate a score based on pros and cons\n        const score = calculateScore(slotStart, pros, cons, timePreference);\n        return {\n            start: slot.start,\n            end: slot.end,\n            pros,\n            cons,\n            score\n        };\n    })// Sort by score (highest first)\n    .sort((a, b)=>b.score - a.score);\n}\n/**\n * Generate pros and cons for a time slot\n * @param {DateTime} slotStart - Start time of the slot\n * @param {DateTime} slotEnd - End time of the slot\n * @param {Array} busyIntervals - List of busy time intervals\n * @param {string} activity - Type of activity\n * @param {string} timePreference - Preferred time of day\n * @returns {Object} - Object containing pros and cons arrays\n */ function generateProsAndCons(slotStart, slotEnd, busyIntervals, activity, timePreference) {\n    const pros = [];\n    const cons = [];\n    // Time of day factors\n    const hour = slotStart.hour;\n    // Check if slot is during preferred time\n    if (timePreference === \"morning\" && hour >= 8 && hour < 12) {\n        pros.push(\"Matches your morning time preference\");\n    } else if (timePreference === \"afternoon\" && hour >= 12 && hour < 17) {\n        pros.push(\"Matches your afternoon time preference\");\n    } else if (timePreference === \"evening\" && hour >= 17 && hour < 21) {\n        pros.push(\"Matches your evening time preference\");\n    } else if (timePreference !== \"any\") {\n        cons.push(`Outside your preferred ${timePreference} time`);\n    }\n    // Early morning/late evening factors\n    if (hour < 8) {\n        cons.push(\"Early morning slot may be difficult to attend\");\n    } else if (hour >= 20) {\n        cons.push(\"Late evening slot may interfere with personal time\");\n    }\n    // Ideal working hours\n    if (hour >= 9 && hour < 17) {\n        pros.push(\"During standard working hours\");\n    }\n    // Lunch time\n    if (hour >= 12 && hour < 14) {\n        if (activity.toLowerCase().includes(\"lunch\") || activity.toLowerCase().includes(\"meal\") || activity.toLowerCase().includes(\"eat\")) {\n            pros.push(\"Ideal time for a meal\");\n        } else {\n            cons.push(\"May conflict with lunch time\");\n        }\n    }\n    // Proximity to other events\n    const bufferTime = luxon__WEBPACK_IMPORTED_MODULE_0__.Duration.fromObject({\n        minutes: 30\n    });\n    let hasEventBefore = false;\n    let hasEventAfter = false;\n    for (const busy of busyIntervals){\n        const busyEnd = busy.interval.end;\n        const busyStart = busy.interval.start;\n        // Check if there's an event ending right before this slot\n        if (busyEnd <= slotStart && busyEnd.plus(bufferTime) >= slotStart) {\n            hasEventBefore = true;\n            pros.push(`Convenient timing after \"${busy.summary}\"`);\n        }\n        // Check if there's an event starting right after this slot\n        if (busyStart >= slotEnd && busyStart.minus(bufferTime) <= slotEnd) {\n            hasEventAfter = true;\n            pros.push(`Convenient timing before \"${busy.summary}\"`);\n        }\n    }\n    // If the slot is sandwiched between events\n    if (hasEventBefore && hasEventAfter) {\n        pros.push(\"Efficiently uses gap between events\");\n    }\n    // Day of week factors\n    const dayOfWeek = slotStart.weekday;\n    if (dayOfWeek === 1) {\n        if (hour < 11) {\n            cons.push(\"Early Monday morning may be busy with weekly planning\");\n        } else {\n            pros.push(\"Good for setting the tone for the week\");\n        }\n    } else if (dayOfWeek === 5) {\n        if (hour >= 15) {\n            cons.push(\"Late Friday may conflict with weekend plans\");\n        } else {\n            pros.push(\"Good for wrapping up the week\");\n        }\n    } else if (dayOfWeek === 6 || dayOfWeek === 7) {\n        if (activity.toLowerCase().includes(\"work\") || activity.toLowerCase().includes(\"meeting\") || activity.toLowerCase().includes(\"call\")) {\n            cons.push(\"Weekend slot for work-related activity\");\n        } else {\n            pros.push(\"Weekend slot good for personal activities\");\n        }\n    }\n    // Activity-specific factors\n    if (activity.toLowerCase().includes(\"exercise\") || activity.toLowerCase().includes(\"workout\") || activity.toLowerCase().includes(\"gym\")) {\n        if (hour >= 6 && hour < 9) {\n            pros.push(\"Morning exercise can boost energy for the day\");\n        } else if (hour >= 17 && hour < 20) {\n            pros.push(\"Evening exercise can help unwind after work\");\n        }\n    }\n    // Ensure we have at least one pro and con\n    if (pros.length === 0) {\n        pros.push(\"Available time slot that fits your schedule\");\n    }\n    if (cons.length === 0) {\n        // Look for any minor drawback\n        if (slotStart.minute !== 0 && slotStart.minute !== 30) {\n            cons.push(\"Starts at an unusual time\");\n        } else if (dayOfWeek >= 1 && dayOfWeek <= 5 && (hour < 9 || hour >= 17)) {\n            cons.push(\"Outside standard working hours\");\n        } else {\n            cons.push(\"No significant drawbacks identified\");\n        }\n    }\n    return {\n        pros,\n        cons\n    };\n}\n/**\n * Calculate a score for ranking time slots\n * @param {DateTime} slotStart - Start time of the slot\n * @param {Array} pros - List of pros\n * @param {Array} cons - List of cons\n * @param {string} timePreference - Preferred time of day\n * @returns {number} - Score for ranking\n */ function calculateScore(slotStart, pros, cons, timePreference) {\n    let score = 0;\n    // Base score from pros and cons count\n    score += pros.length * 10;\n    score -= cons.length * 8;\n    // Preferred time bonus\n    const hour = slotStart.hour;\n    if (timePreference === \"morning\" && hour >= 8 && hour < 12) {\n        score += 15;\n    } else if (timePreference === \"afternoon\" && hour >= 12 && hour < 17) {\n        score += 15;\n    } else if (timePreference === \"evening\" && hour >= 17 && hour < 21) {\n        score += 15;\n    }\n    // Ideal working hours bonus\n    if (hour >= 9 && hour < 17) {\n        score += 5;\n    }\n    // Prefer earlier slots when all else is equal (for consistent sorting)\n    score -= slotStart.hour * 0.1;\n    return score;\n}\n/**\n * Format available slots for display\n * @param {Array} slots - List of available slots with pros and cons\n * @returns {string} - Formatted string for display\n */ function formatAvailableSlots(slots) {\n    if (!slots || slots.length === 0) {\n        return \"No available slots found.\";\n    }\n    let result = \"Available time slots:\\n\\n\";\n    slots.forEach((slot, index)=>{\n        const start = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.start);\n        const end = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.end);\n        result += `Option ${index + 1}: ${start.toFormat(\"ccc, LLL d\")} from ${start.toFormat(\"h:mm a\")} to ${end.toFormat(\"h:mm a\")}\\n`;\n        result += \"Pros:\\n\";\n        slot.pros.forEach((pro)=>{\n            result += `- ${pro}\\n`;\n        });\n        result += \"Cons:\\n\";\n        slot.cons.forEach((con)=>{\n            result += `- ${con}\\n`;\n        });\n        if (index < slots.length - 1) {\n            result += \"\\n\";\n        }\n    });\n    return result;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBSztJQUN4QyxJQUFJLENBQUNBLFNBQVNBLE1BQU1vRCxNQUFNLEtBQUssR0FBRztRQUNoQyxPQUFPO0lBQ1Q7SUFFQSxJQUFJRSxTQUFTO0lBRWJ0RCxNQUFNdUQsT0FBTyxDQUFDLENBQUNyQixNQUFNc0I7UUFDbkIsTUFBTS9FLFFBQVFKLDJDQUFRQSxDQUFDZSxPQUFPLENBQUM4QyxLQUFLekQsS0FBSztRQUN6QyxNQUFNQyxNQUFNTCwyQ0FBUUEsQ0FBQ2UsT0FBTyxDQUFDOEMsS0FBS3hELEdBQUc7UUFFckM0RSxVQUFVLENBQUMsT0FBTyxFQUFFRSxRQUFRLEVBQUUsRUFBRSxFQUFFL0UsTUFBTWdGLFFBQVEsQ0FBQyxjQUFjLE1BQU0sRUFBRWhGLE1BQU1nRixRQUFRLENBQUMsVUFBVSxJQUFJLEVBQUUvRSxJQUFJK0UsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRWhJSCxVQUFVO1FBQ1ZwQixLQUFLRSxJQUFJLENBQUNtQixPQUFPLENBQUNHLENBQUFBO1lBQ2hCSixVQUFVLENBQUMsRUFBRSxFQUFFSSxJQUFJLEVBQUUsQ0FBQztRQUN4QjtRQUVBSixVQUFVO1FBQ1ZwQixLQUFLRyxJQUFJLENBQUNrQixPQUFPLENBQUNJLENBQUFBO1lBQ2hCTCxVQUFVLENBQUMsRUFBRSxFQUFFSyxJQUFJLEVBQUUsQ0FBQztRQUN4QjtRQUVBLElBQUlILFFBQVF4RCxNQUFNb0QsTUFBTSxHQUFHLEdBQUc7WUFDNUJFLFVBQVU7UUFDWjtJQUNGO0lBRUEsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi90b29scy9zY2hlZHVsaW5nVXRpbHMuanM/ZDBmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRlVGltZSwgSW50ZXJ2YWwsIER1cmF0aW9uIH0gZnJvbSAnbHV4b24nO1xuXG4vKipcbiAqIERlZmF1bHQgd29ya2luZyBob3VycyBjb25maWd1cmF0aW9uXG4gKiBDYW4gYmUgZXh0ZW5kZWQgdG8gZmV0Y2ggZnJvbSB1c2VyIHByZWZlcmVuY2VzIGluIHRoZSBmdXR1cmVcbiAqL1xuY29uc3QgREVGQVVMVF9XT1JLSU5HX0hPVVJTID0ge1xuICBzdGFydDogOSwgLy8gOSBBTVxuICBlbmQ6IDE3LCAgLy8gNSBQTVxuICB3b3JrRGF5czogWzEsIDIsIDMsIDQsIDVdLCAvLyBNb25kYXkgdG8gRnJpZGF5ICgxLTUpXG59O1xuXG4vKipcbiAqIEZpbmQgYXZhaWxhYmxlIHRpbWUgc2xvdHMgZm9yIGEgbmV3IGV2ZW50XG4gKiBAcGFyYW0ge0FycmF5fSBldmVudHMgLSBMaXN0IG9mIGNhbGVuZGFyIGV2ZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gRHVyYXRpb24gb2YgdGhlIGV2ZW50IGluIG1pbnV0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydERhdGUgLSBTdGFydCBkYXRlIHRvIHNlYXJjaCBmcm9tIGluIElTTyBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmREYXRlIC0gRW5kIGRhdGUgdG8gc2VhcmNoIHVudGlsIGluIElTTyBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpdml0eSAtIFR5cGUgb2YgYWN0aXZpdHkgYmVpbmcgc2NoZWR1bGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZVByZWZlcmVuY2UgLSBQcmVmZXJyZWQgdGltZSBvZiBkYXkgKG1vcm5pbmcsIGFmdGVybm9vbiwgZXZlbmluZywgYW55KVxuICogQHBhcmFtIHtPYmplY3R9IHdvcmtpbmdIb3VycyAtIE9wdGlvbmFsIHdvcmtpbmcgaG91cnMgY29uZmlndXJhdGlvblxuICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgYXZhaWxhYmxlIHRpbWUgc2xvdHMgd2l0aCBwcm9zIGFuZCBjb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQXZhaWxhYmxlU2xvdHMoXG4gIGV2ZW50cywgXG4gIGR1cmF0aW9uLCBcbiAgc3RhcnREYXRlLCBcbiAgZW5kRGF0ZSwgXG4gIGFjdGl2aXR5LCBcbiAgdGltZVByZWZlcmVuY2UgPSAnYW55JyxcbiAgd29ya2luZ0hvdXJzID0gREVGQVVMVF9XT1JLSU5HX0hPVVJTXG4pIHtcbiAgLy8gQ29udmVydCBpbnB1dHMgdG8gTHV4b24gb2JqZWN0c1xuICBjb25zdCBzdGFydCA9IERhdGVUaW1lLmZyb21JU08oc3RhcnREYXRlKTtcbiAgY29uc3QgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlbmREYXRlKTtcbiAgY29uc3QgZHVyYXRpb25NaW51dGVzID0gZHVyYXRpb247XG4gIFxuICAvLyBDcmVhdGUgYSBsaXN0IG9mIGJ1c3kgaW50ZXJ2YWxzIGZyb20gZXZlbnRzXG4gIGNvbnN0IGJ1c3lJbnRlcnZhbHMgPSBldmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICBjb25zdCBldmVudFN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5zdGFydC5kYXRlVGltZSB8fCBldmVudC5zdGFydC5kYXRlKTtcbiAgICBjb25zdCBldmVudEVuZCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kLmRhdGVUaW1lIHx8IGV2ZW50LmVuZC5kYXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJ2YWw6IEludGVydmFsLmZyb21EYXRlVGltZXMoZXZlbnRTdGFydCwgZXZlbnRFbmQpLFxuICAgICAgc3VtbWFyeTogZXZlbnQuc3VtbWFyeVxuICAgIH07XG4gIH0pO1xuICBcbiAgLy8gR2VuZXJhdGUgcG90ZW50aWFsIHNsb3RzXG4gIGNvbnN0IHNsb3RzID0gZ2VuZXJhdGVQb3RlbnRpYWxTbG90cyhcbiAgICBzdGFydCwgXG4gICAgZW5kLCBcbiAgICBkdXJhdGlvbk1pbnV0ZXMsIFxuICAgIGJ1c3lJbnRlcnZhbHMsIFxuICAgIHRpbWVQcmVmZXJlbmNlLFxuICAgIHdvcmtpbmdIb3Vyc1xuICApO1xuICBcbiAgLy8gRXZhbHVhdGUgYW5kIHJhbmsgc2xvdHNcbiAgY29uc3QgZXZhbHVhdGVkU2xvdHMgPSBldmFsdWF0ZVNsb3RzKFxuICAgIHNsb3RzLCBcbiAgICBidXN5SW50ZXJ2YWxzLCBcbiAgICBkdXJhdGlvbk1pbnV0ZXMsIFxuICAgIGFjdGl2aXR5LCBcbiAgICB0aW1lUHJlZmVyZW5jZVxuICApO1xuICBcbiAgLy8gUmV0dXJuIHRvcCBzbG90cyAobGltaXRlZCB0byAzKVxuICByZXR1cm4gZXZhbHVhdGVkU2xvdHMuc2xpY2UoMCwgMyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgcG90ZW50aWFsIHRpbWUgc2xvdHMgYmFzZWQgb24gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IHN0YXJ0IC0gU3RhcnQgZGF0ZS90aW1lIHRvIHNlYXJjaCBmcm9tXG4gKiBAcGFyYW0ge0RhdGVUaW1lfSBlbmQgLSBFbmQgZGF0ZS90aW1lIHRvIHNlYXJjaCB1bnRpbFxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uTWludXRlcyAtIER1cmF0aW9uIGluIG1pbnV0ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1c3lJbnRlcnZhbHMgLSBMaXN0IG9mIGJ1c3kgdGltZSBpbnRlcnZhbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lUHJlZmVyZW5jZSAtIFByZWZlcnJlZCB0aW1lIG9mIGRheVxuICogQHBhcmFtIHtPYmplY3R9IHdvcmtpbmdIb3VycyAtIFdvcmtpbmcgaG91cnMgY29uZmlndXJhdGlvblxuICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgcG90ZW50aWFsIHRpbWUgc2xvdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQb3RlbnRpYWxTbG90cyhcbiAgc3RhcnQsIFxuICBlbmQsIFxuICBkdXJhdGlvbk1pbnV0ZXMsIFxuICBidXN5SW50ZXJ2YWxzLCBcbiAgdGltZVByZWZlcmVuY2UsXG4gIHdvcmtpbmdIb3Vyc1xuKSB7XG4gIGNvbnN0IHNsb3RzID0gW107XG4gIGNvbnN0IHNsb3REdXJhdGlvbiA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiBkdXJhdGlvbk1pbnV0ZXMgfSk7XG4gIFxuICAvLyBTdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlYXJjaCBwZXJpb2RcbiAgbGV0IGN1cnJlbnRUaW1lID0gc3RhcnQ7XG4gIFxuICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBkYXkgaW4gdGhlIHNlYXJjaCBwZXJpb2RcbiAgd2hpbGUgKGN1cnJlbnRUaW1lIDwgZW5kKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHdvcmtpbmcgZGF5XG4gICAgY29uc3QgaXNXb3JraW5nRGF5ID0gd29ya2luZ0hvdXJzLndvcmtEYXlzLmluY2x1ZGVzKGN1cnJlbnRUaW1lLndlZWtkYXkpO1xuICAgIFxuICAgIGlmIChpc1dvcmtpbmdEYXkpIHtcbiAgICAgIC8vIFNldCBzdGFydCB0aW1lIHRvIGVpdGhlciBjdXJyZW50IHRpbWUgb3IgYmVnaW5uaW5nIG9mIHdvcmtpbmcgaG91cnNcbiAgICAgIGxldCBkYXlTdGFydCA9IGN1cnJlbnRUaW1lLnNldCh7IFxuICAgICAgICBob3VyOiB3b3JraW5nSG91cnMuc3RhcnQsIFxuICAgICAgICBtaW51dGU6IDAsIFxuICAgICAgICBzZWNvbmQ6IDAsIFxuICAgICAgICBtaWxsaXNlY29uZDogMCBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHBhc3QgdGhlIHdvcmtpbmcgaG91cnMgc3RhcnQgZm9yIHRvZGF5LCB1c2UgY3VycmVudCB0aW1lXG4gICAgICBpZiAoY3VycmVudFRpbWUgPiBkYXlTdGFydCkge1xuICAgICAgICBkYXlTdGFydCA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbmQgb2Ygd29ya2luZyBob3VycyBmb3IgdG9kYXlcbiAgICAgIGNvbnN0IGRheUVuZCA9IGN1cnJlbnRUaW1lLnNldCh7IFxuICAgICAgICBob3VyOiB3b3JraW5nSG91cnMuZW5kLCBcbiAgICAgICAgbWludXRlOiAwLCBcbiAgICAgICAgc2Vjb25kOiAwLCBcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDAgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgc2xvdHMgZm9yIHRoaXMgZGF5XG4gICAgICBsZXQgc2xvdFN0YXJ0ID0gZGF5U3RhcnQ7XG4gICAgICBcbiAgICAgIC8vIFVzZSAzMC1taW51dGUgaW5jcmVtZW50cyBmb3Igc2xvdCBnZW5lcmF0aW9uXG4gICAgICB3aGlsZSAoc2xvdFN0YXJ0LnBsdXMoc2xvdER1cmF0aW9uKSA8PSBkYXlFbmQpIHtcbiAgICAgICAgY29uc3Qgc2xvdEVuZCA9IHNsb3RTdGFydC5wbHVzKHNsb3REdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbG90ID0gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzbG90U3RhcnQsIHNsb3RFbmQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzbG90IG92ZXJsYXBzIHdpdGggYW55IGJ1c3kgaW50ZXJ2YWxzXG4gICAgICAgIGNvbnN0IGlzQXZhaWxhYmxlID0gIWJ1c3lJbnRlcnZhbHMuc29tZShidXN5ID0+IFxuICAgICAgICAgIGJ1c3kuaW50ZXJ2YWwub3ZlcmxhcHMoY3VycmVudFNsb3QpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHNsb3QgbWF0Y2hlcyB0aGUgdGltZSBwcmVmZXJlbmNlXG4gICAgICAgICAgY29uc3QgaG91ciA9IHNsb3RTdGFydC5ob3VyO1xuICAgICAgICAgIGxldCBtYXRjaGVzUHJlZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRpbWVQcmVmZXJlbmNlID09PSAnbW9ybmluZycgJiYgKGhvdXIgPCA4IHx8IGhvdXIgPj0gMTIpKSB7XG4gICAgICAgICAgICBtYXRjaGVzUHJlZmVyZW5jZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGltZVByZWZlcmVuY2UgPT09ICdhZnRlcm5vb24nICYmIChob3VyIDwgMTIgfHwgaG91ciA+PSAxNykpIHtcbiAgICAgICAgICAgIG1hdGNoZXNQcmVmZXJlbmNlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ2V2ZW5pbmcnICYmIChob3VyIDwgMTcgfHwgaG91ciA+PSAyMSkpIHtcbiAgICAgICAgICAgIG1hdGNoZXNQcmVmZXJlbmNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChtYXRjaGVzUHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgc2xvdHMucHVzaCh7XG4gICAgICAgICAgICAgIHN0YXJ0OiBzbG90U3RhcnQudG9JU08oKSxcbiAgICAgICAgICAgICAgZW5kOiBzbG90RW5kLnRvSVNPKCksXG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZVRpbWU6IHNsb3RTdGFydCxcbiAgICAgICAgICAgICAgZW5kRGF0ZVRpbWU6IHNsb3RFbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IHNsb3QgKDMwLW1pbnV0ZSBpbmNyZW1lbnRzKVxuICAgICAgICBzbG90U3RhcnQgPSBzbG90U3RhcnQucGx1cyh7IG1pbnV0ZXM6IDMwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBNb3ZlIHRvIG5leHQgZGF5XG4gICAgY3VycmVudFRpbWUgPSBjdXJyZW50VGltZS5wbHVzKHsgZGF5czogMSB9KS5zdGFydE9mKCdkYXknKTtcbiAgfVxuICBcbiAgcmV0dXJuIHNsb3RzO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIGFuZCByYW5rIGF2YWlsYWJsZSB0aW1lIHNsb3RzXG4gKiBAcGFyYW0ge0FycmF5fSBzbG90cyAtIExpc3Qgb2YgcG90ZW50aWFsIHRpbWUgc2xvdHNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1c3lJbnRlcnZhbHMgLSBMaXN0IG9mIGJ1c3kgdGltZSBpbnRlcnZhbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbk1pbnV0ZXMgLSBEdXJhdGlvbiBpbiBtaW51dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aXZpdHkgLSBUeXBlIG9mIGFjdGl2aXR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZVByZWZlcmVuY2UgLSBQcmVmZXJyZWQgdGltZSBvZiBkYXlcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBFdmFsdWF0ZWQgYW5kIHJhbmtlZCBzbG90cyB3aXRoIHByb3MgYW5kIGNvbnNcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVTbG90cyhzbG90cywgYnVzeUludGVydmFscywgZHVyYXRpb25NaW51dGVzLCBhY3Rpdml0eSwgdGltZVByZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHNsb3RzLm1hcChzbG90ID0+IHtcbiAgICBjb25zdCBzbG90U3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHNsb3Quc3RhcnQpO1xuICAgIGNvbnN0IHNsb3RFbmQgPSBEYXRlVGltZS5mcm9tSVNPKHNsb3QuZW5kKTtcbiAgICBjb25zdCBzbG90SW50ZXJ2YWwgPSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHNsb3RTdGFydCwgc2xvdEVuZCk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgcHJvcyBhbmQgY29uc1xuICAgIGNvbnN0IHsgcHJvcywgY29ucyB9ID0gZ2VuZXJhdGVQcm9zQW5kQ29ucyhcbiAgICAgIHNsb3RTdGFydCwgXG4gICAgICBzbG90RW5kLCBcbiAgICAgIGJ1c3lJbnRlcnZhbHMsIFxuICAgICAgYWN0aXZpdHksIFxuICAgICAgdGltZVByZWZlcmVuY2VcbiAgICApO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBhIHNjb3JlIGJhc2VkIG9uIHByb3MgYW5kIGNvbnNcbiAgICBjb25zdCBzY29yZSA9IGNhbGN1bGF0ZVNjb3JlKHNsb3RTdGFydCwgcHJvcywgY29ucywgdGltZVByZWZlcmVuY2UpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogc2xvdC5zdGFydCxcbiAgICAgIGVuZDogc2xvdC5lbmQsXG4gICAgICBwcm9zLFxuICAgICAgY29ucyxcbiAgICAgIHNjb3JlXG4gICAgfTtcbiAgfSlcbiAgLy8gU29ydCBieSBzY29yZSAoaGlnaGVzdCBmaXJzdClcbiAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBwcm9zIGFuZCBjb25zIGZvciBhIHRpbWUgc2xvdFxuICogQHBhcmFtIHtEYXRlVGltZX0gc2xvdFN0YXJ0IC0gU3RhcnQgdGltZSBvZiB0aGUgc2xvdFxuICogQHBhcmFtIHtEYXRlVGltZX0gc2xvdEVuZCAtIEVuZCB0aW1lIG9mIHRoZSBzbG90XG4gKiBAcGFyYW0ge0FycmF5fSBidXN5SW50ZXJ2YWxzIC0gTGlzdCBvZiBidXN5IHRpbWUgaW50ZXJ2YWxzXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aXZpdHkgLSBUeXBlIG9mIGFjdGl2aXR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZVByZWZlcmVuY2UgLSBQcmVmZXJyZWQgdGltZSBvZiBkYXlcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gT2JqZWN0IGNvbnRhaW5pbmcgcHJvcyBhbmQgY29ucyBhcnJheXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9zQW5kQ29ucyhzbG90U3RhcnQsIHNsb3RFbmQsIGJ1c3lJbnRlcnZhbHMsIGFjdGl2aXR5LCB0aW1lUHJlZmVyZW5jZSkge1xuICBjb25zdCBwcm9zID0gW107XG4gIGNvbnN0IGNvbnMgPSBbXTtcbiAgXG4gIC8vIFRpbWUgb2YgZGF5IGZhY3RvcnNcbiAgY29uc3QgaG91ciA9IHNsb3RTdGFydC5ob3VyO1xuICBcbiAgLy8gQ2hlY2sgaWYgc2xvdCBpcyBkdXJpbmcgcHJlZmVycmVkIHRpbWVcbiAgaWYgKHRpbWVQcmVmZXJlbmNlID09PSAnbW9ybmluZycgJiYgaG91ciA+PSA4ICYmIGhvdXIgPCAxMikge1xuICAgIHByb3MucHVzaCgnTWF0Y2hlcyB5b3VyIG1vcm5pbmcgdGltZSBwcmVmZXJlbmNlJyk7XG4gIH0gZWxzZSBpZiAodGltZVByZWZlcmVuY2UgPT09ICdhZnRlcm5vb24nICYmIGhvdXIgPj0gMTIgJiYgaG91ciA8IDE3KSB7XG4gICAgcHJvcy5wdXNoKCdNYXRjaGVzIHlvdXIgYWZ0ZXJub29uIHRpbWUgcHJlZmVyZW5jZScpO1xuICB9IGVsc2UgaWYgKHRpbWVQcmVmZXJlbmNlID09PSAnZXZlbmluZycgJiYgaG91ciA+PSAxNyAmJiBob3VyIDwgMjEpIHtcbiAgICBwcm9zLnB1c2goJ01hdGNoZXMgeW91ciBldmVuaW5nIHRpbWUgcHJlZmVyZW5jZScpO1xuICB9IGVsc2UgaWYgKHRpbWVQcmVmZXJlbmNlICE9PSAnYW55Jykge1xuICAgIGNvbnMucHVzaChgT3V0c2lkZSB5b3VyIHByZWZlcnJlZCAke3RpbWVQcmVmZXJlbmNlfSB0aW1lYCk7XG4gIH1cbiAgXG4gIC8vIEVhcmx5IG1vcm5pbmcvbGF0ZSBldmVuaW5nIGZhY3RvcnNcbiAgaWYgKGhvdXIgPCA4KSB7XG4gICAgY29ucy5wdXNoKCdFYXJseSBtb3JuaW5nIHNsb3QgbWF5IGJlIGRpZmZpY3VsdCB0byBhdHRlbmQnKTtcbiAgfSBlbHNlIGlmIChob3VyID49IDIwKSB7XG4gICAgY29ucy5wdXNoKCdMYXRlIGV2ZW5pbmcgc2xvdCBtYXkgaW50ZXJmZXJlIHdpdGggcGVyc29uYWwgdGltZScpO1xuICB9XG4gIFxuICAvLyBJZGVhbCB3b3JraW5nIGhvdXJzXG4gIGlmIChob3VyID49IDkgJiYgaG91ciA8IDE3KSB7XG4gICAgcHJvcy5wdXNoKCdEdXJpbmcgc3RhbmRhcmQgd29ya2luZyBob3VycycpO1xuICB9XG4gIFxuICAvLyBMdW5jaCB0aW1lXG4gIGlmIChob3VyID49IDEyICYmIGhvdXIgPCAxNCkge1xuICAgIGlmIChhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdsdW5jaCcpIHx8IFxuICAgICAgICBhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdtZWFsJykgfHwgXG4gICAgICAgIGFjdGl2aXR5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2VhdCcpKSB7XG4gICAgICBwcm9zLnB1c2goJ0lkZWFsIHRpbWUgZm9yIGEgbWVhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zLnB1c2goJ01heSBjb25mbGljdCB3aXRoIGx1bmNoIHRpbWUnKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFByb3hpbWl0eSB0byBvdGhlciBldmVudHNcbiAgY29uc3QgYnVmZmVyVGltZSA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAzMCB9KTtcbiAgbGV0IGhhc0V2ZW50QmVmb3JlID0gZmFsc2U7XG4gIGxldCBoYXNFdmVudEFmdGVyID0gZmFsc2U7XG4gIFxuICBmb3IgKGNvbnN0IGJ1c3kgb2YgYnVzeUludGVydmFscykge1xuICAgIGNvbnN0IGJ1c3lFbmQgPSBidXN5LmludGVydmFsLmVuZDtcbiAgICBjb25zdCBidXN5U3RhcnQgPSBidXN5LmludGVydmFsLnN0YXJ0O1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXZlbnQgZW5kaW5nIHJpZ2h0IGJlZm9yZSB0aGlzIHNsb3RcbiAgICBpZiAoYnVzeUVuZCA8PSBzbG90U3RhcnQgJiYgYnVzeUVuZC5wbHVzKGJ1ZmZlclRpbWUpID49IHNsb3RTdGFydCkge1xuICAgICAgaGFzRXZlbnRCZWZvcmUgPSB0cnVlO1xuICAgICAgcHJvcy5wdXNoKGBDb252ZW5pZW50IHRpbWluZyBhZnRlciBcIiR7YnVzeS5zdW1tYXJ5fVwiYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXZlbnQgc3RhcnRpbmcgcmlnaHQgYWZ0ZXIgdGhpcyBzbG90XG4gICAgaWYgKGJ1c3lTdGFydCA+PSBzbG90RW5kICYmIGJ1c3lTdGFydC5taW51cyhidWZmZXJUaW1lKSA8PSBzbG90RW5kKSB7XG4gICAgICBoYXNFdmVudEFmdGVyID0gdHJ1ZTtcbiAgICAgIHByb3MucHVzaChgQ29udmVuaWVudCB0aW1pbmcgYmVmb3JlIFwiJHtidXN5LnN1bW1hcnl9XCJgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIHRoZSBzbG90IGlzIHNhbmR3aWNoZWQgYmV0d2VlbiBldmVudHNcbiAgaWYgKGhhc0V2ZW50QmVmb3JlICYmIGhhc0V2ZW50QWZ0ZXIpIHtcbiAgICBwcm9zLnB1c2goJ0VmZmljaWVudGx5IHVzZXMgZ2FwIGJldHdlZW4gZXZlbnRzJyk7XG4gIH1cbiAgXG4gIC8vIERheSBvZiB3ZWVrIGZhY3RvcnNcbiAgY29uc3QgZGF5T2ZXZWVrID0gc2xvdFN0YXJ0LndlZWtkYXk7XG4gIFxuICBpZiAoZGF5T2ZXZWVrID09PSAxKSB7IC8vIE1vbmRheVxuICAgIGlmIChob3VyIDwgMTEpIHtcbiAgICAgIGNvbnMucHVzaCgnRWFybHkgTW9uZGF5IG1vcm5pbmcgbWF5IGJlIGJ1c3kgd2l0aCB3ZWVrbHkgcGxhbm5pbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcy5wdXNoKCdHb29kIGZvciBzZXR0aW5nIHRoZSB0b25lIGZvciB0aGUgd2VlaycpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXlPZldlZWsgPT09IDUpIHsgLy8gRnJpZGF5XG4gICAgaWYgKGhvdXIgPj0gMTUpIHtcbiAgICAgIGNvbnMucHVzaCgnTGF0ZSBGcmlkYXkgbWF5IGNvbmZsaWN0IHdpdGggd2Vla2VuZCBwbGFucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9zLnB1c2goJ0dvb2QgZm9yIHdyYXBwaW5nIHVwIHRoZSB3ZWVrJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRheU9mV2VlayA9PT0gNiB8fCBkYXlPZldlZWsgPT09IDcpIHsgLy8gV2Vla2VuZFxuICAgIGlmIChhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd3b3JrJykgfHwgXG4gICAgICAgIGFjdGl2aXR5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ21lZXRpbmcnKSB8fCBcbiAgICAgICAgYWN0aXZpdHkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY2FsbCcpKSB7XG4gICAgICBjb25zLnB1c2goJ1dlZWtlbmQgc2xvdCBmb3Igd29yay1yZWxhdGVkIGFjdGl2aXR5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3MucHVzaCgnV2Vla2VuZCBzbG90IGdvb2QgZm9yIHBlcnNvbmFsIGFjdGl2aXRpZXMnKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFjdGl2aXR5LXNwZWNpZmljIGZhY3RvcnNcbiAgaWYgKGFjdGl2aXR5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2V4ZXJjaXNlJykgfHwgXG4gICAgICBhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd3b3Jrb3V0JykgfHwgXG4gICAgICBhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdneW0nKSkge1xuICAgIGlmIChob3VyID49IDYgJiYgaG91ciA8IDkpIHtcbiAgICAgIHByb3MucHVzaCgnTW9ybmluZyBleGVyY2lzZSBjYW4gYm9vc3QgZW5lcmd5IGZvciB0aGUgZGF5Jyk7XG4gICAgfSBlbHNlIGlmIChob3VyID49IDE3ICYmIGhvdXIgPCAyMCkge1xuICAgICAgcHJvcy5wdXNoKCdFdmVuaW5nIGV4ZXJjaXNlIGNhbiBoZWxwIHVud2luZCBhZnRlciB3b3JrJyk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBFbnN1cmUgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgcHJvIGFuZCBjb25cbiAgaWYgKHByb3MubGVuZ3RoID09PSAwKSB7XG4gICAgcHJvcy5wdXNoKCdBdmFpbGFibGUgdGltZSBzbG90IHRoYXQgZml0cyB5b3VyIHNjaGVkdWxlJyk7XG4gIH1cbiAgXG4gIGlmIChjb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIExvb2sgZm9yIGFueSBtaW5vciBkcmF3YmFja1xuICAgIGlmIChzbG90U3RhcnQubWludXRlICE9PSAwICYmIHNsb3RTdGFydC5taW51dGUgIT09IDMwKSB7XG4gICAgICBjb25zLnB1c2goJ1N0YXJ0cyBhdCBhbiB1bnVzdWFsIHRpbWUnKTtcbiAgICB9IGVsc2UgaWYgKGRheU9mV2VlayA+PSAxICYmIGRheU9mV2VlayA8PSA1ICYmIChob3VyIDwgOSB8fCBob3VyID49IDE3KSkge1xuICAgICAgY29ucy5wdXNoKCdPdXRzaWRlIHN0YW5kYXJkIHdvcmtpbmcgaG91cnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29ucy5wdXNoKCdObyBzaWduaWZpY2FudCBkcmF3YmFja3MgaWRlbnRpZmllZCcpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHsgcHJvcywgY29ucyB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBhIHNjb3JlIGZvciByYW5raW5nIHRpbWUgc2xvdHNcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IHNsb3RTdGFydCAtIFN0YXJ0IHRpbWUgb2YgdGhlIHNsb3RcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3MgLSBMaXN0IG9mIHByb3NcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnMgLSBMaXN0IG9mIGNvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lUHJlZmVyZW5jZSAtIFByZWZlcnJlZCB0aW1lIG9mIGRheVxuICogQHJldHVybnMge251bWJlcn0gLSBTY29yZSBmb3IgcmFua2luZ1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTY29yZShzbG90U3RhcnQsIHByb3MsIGNvbnMsIHRpbWVQcmVmZXJlbmNlKSB7XG4gIGxldCBzY29yZSA9IDA7XG4gIFxuICAvLyBCYXNlIHNjb3JlIGZyb20gcHJvcyBhbmQgY29ucyBjb3VudFxuICBzY29yZSArPSBwcm9zLmxlbmd0aCAqIDEwO1xuICBzY29yZSAtPSBjb25zLmxlbmd0aCAqIDg7XG4gIFxuICAvLyBQcmVmZXJyZWQgdGltZSBib251c1xuICBjb25zdCBob3VyID0gc2xvdFN0YXJ0LmhvdXI7XG4gIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ21vcm5pbmcnICYmIGhvdXIgPj0gOCAmJiBob3VyIDwgMTIpIHtcbiAgICBzY29yZSArPSAxNTtcbiAgfSBlbHNlIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ2FmdGVybm9vbicgJiYgaG91ciA+PSAxMiAmJiBob3VyIDwgMTcpIHtcbiAgICBzY29yZSArPSAxNTtcbiAgfSBlbHNlIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ2V2ZW5pbmcnICYmIGhvdXIgPj0gMTcgJiYgaG91ciA8IDIxKSB7XG4gICAgc2NvcmUgKz0gMTU7XG4gIH1cbiAgXG4gIC8vIElkZWFsIHdvcmtpbmcgaG91cnMgYm9udXNcbiAgaWYgKGhvdXIgPj0gOSAmJiBob3VyIDwgMTcpIHtcbiAgICBzY29yZSArPSA1O1xuICB9XG4gIFxuICAvLyBQcmVmZXIgZWFybGllciBzbG90cyB3aGVuIGFsbCBlbHNlIGlzIGVxdWFsIChmb3IgY29uc2lzdGVudCBzb3J0aW5nKVxuICBzY29yZSAtPSBzbG90U3RhcnQuaG91ciAqIDAuMTtcbiAgXG4gIHJldHVybiBzY29yZTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYXZhaWxhYmxlIHNsb3RzIGZvciBkaXNwbGF5XG4gKiBAcGFyYW0ge0FycmF5fSBzbG90cyAtIExpc3Qgb2YgYXZhaWxhYmxlIHNsb3RzIHdpdGggcHJvcyBhbmQgY29uc1xuICogQHJldHVybnMge3N0cmluZ30gLSBGb3JtYXR0ZWQgc3RyaW5nIGZvciBkaXNwbGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBdmFpbGFibGVTbG90cyhzbG90cykge1xuICBpZiAoIXNsb3RzIHx8IHNsb3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIk5vIGF2YWlsYWJsZSBzbG90cyBmb3VuZC5cIjtcbiAgfVxuICBcbiAgbGV0IHJlc3VsdCA9IFwiQXZhaWxhYmxlIHRpbWUgc2xvdHM6XFxuXFxuXCI7XG4gIFxuICBzbG90cy5mb3JFYWNoKChzbG90LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzbG90LnN0YXJ0KTtcbiAgICBjb25zdCBlbmQgPSBEYXRlVGltZS5mcm9tSVNPKHNsb3QuZW5kKTtcbiAgICBcbiAgICByZXN1bHQgKz0gYE9wdGlvbiAke2luZGV4ICsgMX06ICR7c3RhcnQudG9Gb3JtYXQoJ2NjYywgTExMIGQnKX0gZnJvbSAke3N0YXJ0LnRvRm9ybWF0KCdoOm1tIGEnKX0gdG8gJHtlbmQudG9Gb3JtYXQoJ2g6bW0gYScpfVxcbmA7XG4gICAgXG4gICAgcmVzdWx0ICs9IFwiUHJvczpcXG5cIjtcbiAgICBzbG90LnByb3MuZm9yRWFjaChwcm8gPT4ge1xuICAgICAgcmVzdWx0ICs9IGAtICR7cHJvfVxcbmA7XG4gICAgfSk7XG4gICAgXG4gICAgcmVzdWx0ICs9IFwiQ29uczpcXG5cIjtcbiAgICBzbG90LmNvbnMuZm9yRWFjaChjb24gPT4ge1xuICAgICAgcmVzdWx0ICs9IGAtICR7Y29ufVxcbmA7XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKGluZGV4IDwgc2xvdHMubGVuZ3RoIC0gMSkge1xuICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiByZXN1bHQ7XG59Il0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiSW50ZXJ2YWwiLCJEdXJhdGlvbiIsIkRFRkFVTFRfV09SS0lOR19IT1VSUyIsInN0YXJ0IiwiZW5kIiwid29ya0RheXMiLCJmaW5kQXZhaWxhYmxlU2xvdHMiLCJldmVudHMiLCJkdXJhdGlvbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJhY3Rpdml0eSIsInRpbWVQcmVmZXJlbmNlIiwid29ya2luZ0hvdXJzIiwiZnJvbUlTTyIsImR1cmF0aW9uTWludXRlcyIsImJ1c3lJbnRlcnZhbHMiLCJtYXAiLCJldmVudCIsImV2ZW50U3RhcnQiLCJkYXRlVGltZSIsImRhdGUiLCJldmVudEVuZCIsImludGVydmFsIiwiZnJvbURhdGVUaW1lcyIsInN1bW1hcnkiLCJzbG90cyIsImdlbmVyYXRlUG90ZW50aWFsU2xvdHMiLCJldmFsdWF0ZWRTbG90cyIsImV2YWx1YXRlU2xvdHMiLCJzbGljZSIsInNsb3REdXJhdGlvbiIsImZyb21PYmplY3QiLCJtaW51dGVzIiwiY3VycmVudFRpbWUiLCJpc1dvcmtpbmdEYXkiLCJpbmNsdWRlcyIsIndlZWtkYXkiLCJkYXlTdGFydCIsInNldCIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsImRheUVuZCIsInNsb3RTdGFydCIsInBsdXMiLCJzbG90RW5kIiwiY3VycmVudFNsb3QiLCJpc0F2YWlsYWJsZSIsInNvbWUiLCJidXN5Iiwib3ZlcmxhcHMiLCJtYXRjaGVzUHJlZmVyZW5jZSIsInB1c2giLCJ0b0lTTyIsInN0YXJ0RGF0ZVRpbWUiLCJlbmREYXRlVGltZSIsImRheXMiLCJzdGFydE9mIiwic2xvdCIsInNsb3RJbnRlcnZhbCIsInByb3MiLCJjb25zIiwiZ2VuZXJhdGVQcm9zQW5kQ29ucyIsInNjb3JlIiwiY2FsY3VsYXRlU2NvcmUiLCJzb3J0IiwiYSIsImIiLCJ0b0xvd2VyQ2FzZSIsImJ1ZmZlclRpbWUiLCJoYXNFdmVudEJlZm9yZSIsImhhc0V2ZW50QWZ0ZXIiLCJidXN5RW5kIiwiYnVzeVN0YXJ0IiwibWludXMiLCJkYXlPZldlZWsiLCJsZW5ndGgiLCJmb3JtYXRBdmFpbGFibGVTbG90cyIsInJlc3VsdCIsImZvckVhY2giLCJpbmRleCIsInRvRm9ybWF0IiwicHJvIiwiY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/tools/schedulingUtils.js\n");

/***/ }),

/***/ "(api)/./lib/tools/toolIndex.js":
/*!********************************!*\
  !*** ./lib/tools/toolIndex.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toolFunctions: () => (/* binding */ toolFunctions),\n/* harmony export */   tools: () => (/* binding */ tools)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var googleapis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! googleapis */ \"googleapis\");\n/* harmony import */ var googleapis__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(googleapis__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../googleCalendar.js */ \"(api)/./googleCalendar.js\");\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _redisClient_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../redisClient.js */ \"(api)/./lib/redisClient.js\");\n/* harmony import */ var _services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../services/cacheService.js */ \"(api)/./lib/services/cacheService.js\");\n/* harmony import */ var _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\n/* harmony import */ var _checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./checkForConflicts.js */ \"(api)/./lib/tools/checkForConflicts.js\");\n/* harmony import */ var _formatters_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./formatters.js */ \"(api)/./lib/tools/formatters.js\");\n/* harmony import */ var _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../postgresClient.js */ \"(api)/./lib/postgresClient.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__, _formatters_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__]);\n([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__, _formatters_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// lib/tools/index.js\n// Purpose: Defines the tools (schema) available to the LLM and maps them\n//          to their corresponding implementation functions. Also includes\n//          helper functions for processing tool calls.\n// --- IMPORTS ---\n\n // Used for get/update event before calling specific functions\n// Import from googleCalendar.js\n\n// Import from redisClient.js\n\n// Import from cacheService.js\n\n// Import from schedulingUtils.js\n\n// Import from checkForConflicts.js\n\n// Import from formatters.js\n\n// Import from postgresClient.js\n\n// --- Tool Schema Definitions (for OpenAI) ---\nconst tools = [\n    {\n        type: \"function\",\n        function: {\n            name: \"saveUserPreference\",\n            description: \"Save a user preference for future reference. Use this when you identify important user preferences (like preferred meeting times, locations, activity types, scheduling constraints) that should be remembered long-term.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    category: {\n                        type: \"string\",\n                        description: \"The broad category of the preference (e.g., 'scheduling', 'location', 'activity').\"\n                    },\n                    key: {\n                        type: \"string\",\n                        description: \"The specific preference key within the category (e.g., 'preferredMeetingHours', 'defaultCity', 'favoriteWorkout').\"\n                    },\n                    value: {\n                        oneOf: [\n                            {\n                                type: \"string\"\n                            },\n                            {\n                                type: \"number\"\n                            },\n                            {\n                                type: \"boolean\"\n                            },\n                            {\n                                type: \"array\",\n                                items: {}\n                            },\n                            {\n                                type: \"object\"\n                            }\n                        ],\n                        description: \"The value of the preference (e.g., '9am-12pm', 'New York', 'running'). Can be string, number, boolean, array, or object.\"\n                    },\n                    context: {\n                        type: \"string\",\n                        description: \"Optional: Additional context about when or why this preference applies (e.g., 'work meetings', 'weekends').\"\n                    }\n                },\n                required: [\n                    \"category\",\n                    \"key\",\n                    \"value\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"addCalendarEvents\",\n            description: \"Creates one or more new events directly in the user's primary Google Calendar based on their request. Extracts details like title, location, and resolves start/end times (using current time context for relative references like 'tomorrow 4pm') into absolute ISO 8601 format. Assumes a 1-hour duration if not specified. Checks for conflicts before adding.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    events: {\n                        type: \"array\",\n                        description: \"An array of one or more event objects to create.\",\n                        items: {\n                            type: \"object\",\n                            properties: {\n                                summary: {\n                                    type: \"string\",\n                                    description: \"The title/summary of the event (e.g., 'Meeting with Clyde').\"\n                                },\n                                start: {\n                                    type: \"string\",\n                                    description: \"The start date and time of the event in STRICT ISO 8601 format including timezone offset (e.g., '2025-04-01T16:00:00-07:00'). Resolve relative times (like 'tomorrow 4pm') based on current time context before calling.\"\n                                },\n                                end: {\n                                    type: \"string\",\n                                    description: \"The end date and time of the event in STRICT ISO 8601 format including timezone offset (e.g., '2025-04-01T17:00:00-07:00'). Resolve relative times; assume 1hr duration from start if end time is not specified.\"\n                                },\n                                description: {\n                                    type: \"string\",\n                                    description: \"Optional description or notes for the event.\"\n                                },\n                                location: {\n                                    type: \"string\",\n                                    description: \"Optional location for the event (e.g., 'Starbucks Main St', 'Zoom Link').\"\n                                },\n                                reminders: {\n                                    type: \"array\",\n                                    items: {\n                                        type: \"number\"\n                                    },\n                                    description: \"Optional reminder times in minutes before the event start (e.g., [10, 30]).\"\n                                }\n                            },\n                            required: [\n                                \"summary\",\n                                \"start\",\n                                \"end\"\n                            ]\n                        }\n                    }\n                },\n                required: [\n                    \"events\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"getCalendarEvents\",\n            description: \"Retrieves events from the user's primary Google Calendar within a specified date range.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    start_date: {\n                        type: \"string\",\n                        description: \"The start date/time for the query range in ISO 8601 format (e.g., '2025-04-01T00:00:00Z' or '2025-04-01').\"\n                    },\n                    end_date: {\n                        type: \"string\",\n                        description: \"The end date/time for the query range in ISO 8601 format (e.g., '2025-04-02T00:00:00Z' or '2025-04-02').\"\n                    }\n                },\n                required: [\n                    \"start_date\",\n                    \"end_date\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"deleteCalendarEvent\",\n            description: \"Deletes a specific event from the user's primary Google Calendar using its unique event ID. Retrieves event details first to invalidate specific cache range.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    eventId: {\n                        type: \"string\",\n                        description: \"The unique ID of the event to delete (e.g., '8ut3a6eol1ov5ovv23v85osssg'). The user might provide the event title/time, use getCalendarEvents first if ID is unknown.\"\n                    }\n                },\n                required: [\n                    \"eventId\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"updateCalendarEvent\",\n            description: \"Updates details (like time, title, location, description) of an existing event in the user's primary Google Calendar using its ID.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    eventId: {\n                        type: \"string\",\n                        description: \"The unique ID of the event to update (e.g., '8ut3a6eol1ov5ovv23v85osssg'). The user might provide the event title/time, use getCalendarEvents first if ID is unknown.\"\n                    },\n                    updates: {\n                        type: \"object\",\n                        properties: {\n                            summary: {\n                                type: \"string\",\n                                description: \"New title/summary for the event.\"\n                            },\n                            description: {\n                                type: \"string\",\n                                description: \"New description for the event.\"\n                            },\n                            location: {\n                                type: \"string\",\n                                description: \"New location for the event.\"\n                            },\n                            start: {\n                                type: \"string\",\n                                description: \"New start time in ISO 8601 format (e.g., '2025-04-01T16:30:00-07:00').\"\n                            },\n                            end: {\n                                type: \"string\",\n                                description: \"New end time in ISO 8601 format (e.g., '2025-04-01T17:00:00-07:00').\"\n                            }\n                        },\n                        description: \"Object containing AT LEAST ONE field to update. Include only fields that are changing.\",\n                        minProperties: 1 // Ensure at least one update is provided\n                    }\n                },\n                required: [\n                    \"eventId\",\n                    \"updates\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"findAvailableSlots\",\n            description: \"Finds multiple available time slots in the user's calendar suitable for scheduling a new event. Considers existing events.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    duration: {\n                        type: \"number\",\n                        description: \"Required duration of the event in minutes (e.g., 30, 60).\"\n                    },\n                    startDate: {\n                        type: \"string\",\n                        description: \"The start date/time to search from, in ISO 8601 format. Defaults to the current time if not provided.\"\n                    },\n                    endDate: {\n                        type: \"string\",\n                        description: \"The end date/time to search until, in ISO 8601 format. Defaults to 7 days from startDate if not provided.\"\n                    },\n                    timePreference: {\n                        type: \"string\",\n                        enum: [\n                            \"morning\",\n                            \"afternoon\",\n                            \"evening\",\n                            \"any\"\n                        ],\n                        description: \"Optional preferred time of day (defaults to 'any'). Morning (~9am-12pm), Afternoon (~12pm-5pm), Evening (~5pm-9pm).\"\n                    },\n                    activity: {\n                        type: \"string\",\n                        description: \"Optional: The type of activity being scheduled (e.g., 'meeting', 'workout', 'call') to potentially influence suggestions or check constraints.\"\n                    }\n                },\n                required: [\n                    \"duration\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"getWeatherForecast\",\n            description: \"Gets the weather forecast for a specific location and date.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    location: {\n                        type: \"string\",\n                        description: \"The city and state, or zip code for the weather forecast (e.g., 'San Francisco, CA', '94107').\"\n                    },\n                    date: {\n                        type: \"string\",\n                        description: \"The date for the forecast in ISO 8601 format (YYYY-MM-DD). Defaults to today if not specified.\"\n                    }\n                },\n                required: [\n                    \"location\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"deleteCalendarEventsByQuery\",\n            description: \"Deletes multiple calendar events within a specified date range that match a search query in their title/summary. Use with caution.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    query: {\n                        type: \"string\",\n                        description: \"The search query to match against event summaries (e.g., 'gym', 'meeting with project X'). Case-insensitive.\"\n                    },\n                    start_date: {\n                        type: \"string\",\n                        description: \"The start date/time for the search range in ISO 8601 format (e.g., '2025-04-01'). Required.\"\n                    },\n                    end_date: {\n                        type: \"string\",\n                        description: \"The end date/time for the search range in ISO 8601 format (e.g., '2025-04-30'). Required.\"\n                    }\n                },\n                required: [\n                    \"query\",\n                    \"start_date\",\n                    \"end_date\"\n                ]\n            }\n        }\n    }\n];\n// --- Tool Function Implementations ---\n// Maps tool names (from schema) to the actual functions that execute them.\nconst toolFunctions = {\n    saveUserPreference: async (args, userId = \"default\", accessToken = null)=>{\n        // Accessing UserPreference model directly - ideally use databaseService\n        if (!userId || userId === \"default\") return {\n            success: false,\n            message: \"Error: User ID is missing.\"\n        };\n        try {\n            // **Requires UserPreference model to be imported**\n            let userPref = await _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.UserPreference.findOne({\n                where: {\n                    user_id: userId\n                }\n            });\n            if (!userPref) userPref = await _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.UserPreference.create({\n                user_id: userId,\n                preferences_data: {}\n            });\n            const { category, key, value, context } = args;\n            // Basic validation\n            if (!category || !key || value === undefined) {\n                return {\n                    success: false,\n                    message: \"Error: Missing required fields (category, key, value) for preference.\"\n                };\n            }\n            const prefsData = userPref.preferences_data || {};\n            if (!prefsData[category]) prefsData[category] = {};\n            prefsData[category][key] = value; // Overwrite existing value simply\n            // Handle context separately if provided\n            if (context !== undefined) {\n                const contextKey = `${category}_context`;\n                if (!prefsData[contextKey]) prefsData[contextKey] = {};\n                prefsData[contextKey][key] = context;\n            }\n            await userPref.update({\n                preferences_data: prefsData\n            });\n            console.log(`Preference saved for user ${userId}: ${category}.${key}`);\n            return {\n                success: true,\n                message: `Preference saved: ${category}.${key} = ${JSON.stringify(value)}`\n            };\n        } catch (error) {\n            console.error(`Error saving preference for user ${userId}:`, error);\n            return {\n                success: false,\n                message: `Failed to save preference: ${error.message}`\n            };\n        }\n    },\n    addCalendarEvents: async (args, userId = \"default\", accessToken = null)=>{\n        // Uses imported addGCalendarEventInternal, checkForConflicts, invalidateCache\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false\n        }; // Return error object\n        const tokens = {\n            access_token: accessToken\n        };\n        const { events } = args;\n        if (!Array.isArray(events) || events.length === 0) return {\n            message: \"No event data provided.\",\n            success: false\n        };\n        const results = [];\n        const affectedDateRanges = [];\n        for (const event of events){\n            if (!event.summary || !event.start || !event.end) {\n                results.push({\n                    summary: event.summary || \"?\",\n                    error: \"Missing required fields (summary, start, end).\",\n                    success: false\n                });\n                continue;\n            }\n            try {\n                const startDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start);\n                const endDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end);\n                if (!startDt.isValid || !endDt.isValid) throw new Error(\"Invalid date format\");\n                if (startDt >= endDt) throw new Error(\"Start time must be before end time\");\n            } catch (e) {\n                results.push({\n                    summary: event.summary,\n                    error: `Invalid date format or logic: ${e.message}. Use ISO 8601 format.`,\n                    success: false\n                });\n                continue;\n            }\n            try {\n                // **Requires checkForConflicts function to be available**\n                const conflictCheckResult = await (0,_checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__.checkForConflicts)(tokens, event.start, event.end);\n                if (conflictCheckResult.conflicts) {\n                    console.warn(`Conflict detected for event: ${event.summary}`);\n                    results.push({\n                        summary: event.summary,\n                        conflict: true,\n                        suggestions: conflictCheckResult.suggestions || [],\n                        error: conflictCheckResult.error || `Event conflicts with existing schedule.`,\n                        success: false\n                    });\n                } else {\n                    // **Requires addGCalendarEventInternal function**\n                    const addedEvent = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.addCalendarEvent)(tokens, event.summary, event.start, event.end, event.description, event.location, event.reminders);\n                    // Assuming addGCalendarEventInternal returns the created event object on success\n                    results.push({\n                        ...addedEvent,\n                        success: true\n                    }); // Add success flag\n                    affectedDateRanges.push({\n                        start: event.start,\n                        end: event.end\n                    });\n                    console.log(`Event added: ${event.summary}`);\n                }\n            } catch (addError) {\n                console.error(`Error adding event \"${event.summary}\" during conflict check or API call:`, addError);\n                results.push({\n                    summary: event.summary,\n                    error: `Failed to process event: ${addError.message}`,\n                    success: false\n                });\n            }\n        }\n        // Invalidate cache for all ranges where events were successfully added\n        // **Requires invalidateCache function**\n        for (const range of affectedDateRanges){\n            try {\n                await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, range.start, range.end);\n            } catch (cacheError) {\n                console.error(\"Error invalidating cache after add:\", cacheError);\n            }\n        }\n        return results; // Return array of result objects (with success flags/errors)\n    },\n    getCalendarEvents: async (args, userId = \"default\", accessToken = null)=>{\n        // Uses getCachedEventsForDateRange -> fetchGCalendarEventsInternal\n        if (!accessToken) return \"Error: User not authenticated.\"; // Return error string\n        const tokens = {\n            access_token: accessToken\n        };\n        const { start_date, end_date } = args;\n        // Validate dates\n        if (!start_date || !end_date) {\n            return \"Error: Both start_date and end_date are required.\";\n        }\n        const startDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(start_date);\n        const endDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(end_date);\n        if (!startDt.isValid || !endDt.isValid) {\n            return `Error: Invalid date format. Please use ISO 8601 (e.g., YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ). Received: start=${start_date}, end=${end_date}`;\n        }\n        if (startDt >= endDt) {\n            return \"Error: Start date must be before end date.\";\n        }\n        try {\n            // **Requires getCachedEventsForDateRange function** (which likely calls fetchGCalendarEventsInternal)\n            // Use the specific function for date range caching\n            const cacheKeyStart = startDt.toISODate();\n            const cacheKeyEnd = endDt.toISODate(); // Use consistent date-only keys for daily cache range\n            const tokenHash = accessToken.substring(accessToken.length - 10); // Simple hash for user separation\n            const userIdCachePrefix = `user_${tokenHash}`; // Or use actual stable userId if available\n            // Fetch from cache or API\n            let events = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n            if (events) {\n                console.log(`Cache HIT for events ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // Filter events based on the *exact* start/end time requested by the user, as cache might be broader (daily)\n                events = events.filter((event)=>{\n                    const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                    const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                    // Ensure valid dates before comparison\n                    if (!eventStart.isValid || !eventEnd.isValid) return false;\n                    // Event overlaps with the requested range [startDt, endDt)\n                    return eventStart < endDt && eventEnd > startDt;\n                });\n                return events; // Return potentially filtered events array\n            } else {\n                console.log(`Cache MISS for events ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // **Requires fetchGCalendarEventsInternal function**\n                const apiEvents = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.getCalendarEvents)(tokens, startDt.toJSDate(), endDt.toJSDate()); // Fetch exact range\n                if (apiEvents && Array.isArray(apiEvents)) {\n                    // Cache the result using the daily range key\n                    await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.cacheEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd, apiEvents, 300); // 5 min TTL\n                    console.log(`Stored events in Redis cache for ${cacheKeyStart} to ${cacheKeyEnd}`);\n                    return apiEvents; // Return the fetched events\n                } else {\n                    console.warn(`No events returned or non-array from fetchGCalendarEventsInternal for ${startDt.toISO()}-${endDt.toISO()}`);\n                    return []; // Return empty array on failure or non-array result\n                }\n            }\n        } catch (error) {\n            console.error(`Error in getCalendarEvents tool (${start_date} to ${end_date}):`, error);\n            // Provide a user-friendly error message\n            return `Error fetching calendar events: ${error.message}. Check connection or permissions.`;\n        }\n    },\n    deleteCalendarEvent: async (args, userId = \"default\", accessToken = null)=>{\n        // Uses google.calendar API directly for 'get', then deleteGCalendarEventInternal, invalidateCache\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false,\n            eventId: args.eventId\n        };\n        const tokens = {\n            access_token: accessToken\n        };\n        const { eventId } = args;\n        if (!eventId) return {\n            error: \"Event ID is required.\",\n            success: false\n        };\n        let originalStartDate, originalEndDate, eventSummary;\n        try {\n            // Need to GET the event first to know its date range for cache invalidation\n            // **Requires createOAuth2Client function**\n            const oauth2Client = (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.createOAuth2Client)(tokens);\n            const calendar = googleapis__WEBPACK_IMPORTED_MODULE_1__.google.calendar({\n                version: \"v3\",\n                auth: oauth2Client\n            });\n            try {\n                console.log(`Fetching event details for deletion: ${eventId}`);\n                const event = await calendar.events.get({\n                    calendarId: \"primary\",\n                    eventId: eventId\n                });\n                originalStartDate = event.data.start?.dateTime || event.data.start?.date;\n                originalEndDate = event.data.end?.dateTime || event.data.end?.date;\n                eventSummary = event.data.summary || eventId; // Use summary if available for result message\n                console.log(`Found event \"${eventSummary}\" starting ${originalStartDate}`);\n            } catch (getError) {\n                // Handle case where event doesn't exist (e.g., already deleted)\n                if (getError.code === 404) {\n                    console.log(`Event ${eventId} not found for deletion (may already be deleted).`);\n                    return {\n                        success: true,\n                        message: `Event ${eventId} not found (already deleted?).`,\n                        eventId: eventId,\n                        summary: eventId\n                    };\n                }\n                // Rethrow other errors during get\n                throw new Error(`Failed to retrieve event details before delete: ${getError.message}`);\n            }\n            // **Requires deleteGCalendarEventInternal function**\n            console.log(`Attempting to delete event: ${eventId}`);\n            await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.deleteCalendarEvent)(tokens, eventId); // Assume this throws on API error\n            console.log(`Successfully deleted event: ${eventId}`);\n            // Invalidate cache for the specific range if known\n            // **Requires invalidateCache function**\n            if (originalStartDate && originalEndDate) {\n                try {\n                    await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, originalStartDate, originalEndDate);\n                } catch (cacheError) {\n                    console.error(\"Error invalidating cache after delete:\", cacheError);\n                }\n            } else {\n                // Fallback: maybe invalidate a broader range or just memory cache if range unknown\n                console.warn(`Could not determine date range for event ${eventId}, broad cache invalidation might be needed.`);\n                try {\n                    await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens);\n                } catch (cacheError) {\n                    console.error(\"Error invalidating cache after delete (fallback):\", cacheError);\n                }\n            }\n            return {\n                success: true,\n                eventId: eventId,\n                summary: eventSummary\n            }; // Return success object\n        } catch (error) {\n            console.error(`Error deleting event ${eventId}:`, error);\n            // Don't invalidate cache on error here, as the state is uncertain\n            return {\n                success: false,\n                error: `Failed to delete event ${eventId}: ${error.message}`,\n                eventId: eventId\n            };\n        }\n    },\n    updateCalendarEvent: async (args, userId = \"default\", accessToken = null)=>{\n        // Uses google.calendar API directly for 'get', then updateGCalendarEventInternal, invalidateCache\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false,\n            eventId: args.eventId\n        };\n        const tokens = {\n            access_token: accessToken\n        };\n        const { eventId, updates } = args;\n        if (!eventId || !updates || typeof updates !== \"object\" || Object.keys(updates).length === 0) {\n            return {\n                error: \"Event ID and a non-empty updates object are required.\",\n                success: false,\n                eventId: eventId\n            };\n        }\n        // Validate update values (basic check for ISO dates if provided)\n        try {\n            if (updates.start && !luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(updates.start).isValid) throw new Error(\"Invalid start date format\");\n            if (updates.end && !luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(updates.end).isValid) throw new Error(\"Invalid end date format\");\n            if (updates.start && updates.end && luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(updates.start) >= luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(updates.end)) {\n                throw new Error(\"Start time must be before end time\");\n            }\n        } catch (validationError) {\n            return {\n                error: `Invalid update data: ${validationError.message}. Use ISO 8601 format.`,\n                success: false,\n                eventId: eventId\n            };\n        }\n        let originalStartDate, originalEndDate;\n        try {\n            // Get original event times for cache invalidation\n            // **Requires createOAuth2Client function**\n            const oauth2Client = (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.createOAuth2Client)(tokens);\n            const calendar = googleapis__WEBPACK_IMPORTED_MODULE_1__.google.calendar({\n                version: \"v3\",\n                auth: oauth2Client\n            });\n            try {\n                console.log(`Fetching event details for update: ${eventId}`);\n                const event = await calendar.events.get({\n                    calendarId: \"primary\",\n                    eventId: eventId\n                });\n                originalStartDate = event.data.start?.dateTime || event.data.start?.date;\n                originalEndDate = event.data.end?.dateTime || event.data.end?.date;\n                console.log(`Found event \"${event.data.summary}\" starting ${originalStartDate}`);\n            } catch (getError) {\n                if (getError.code === 404) {\n                    return {\n                        success: false,\n                        error: `Event ${eventId} not found for update.`,\n                        eventId: eventId\n                    };\n                }\n                throw new Error(`Failed to retrieve event details before update: ${getError.message}`);\n            }\n            // **Requires updateGCalendarEventInternal function**\n            console.log(`Attempting to update event: ${eventId} with updates:`, updates);\n            const updatedEvent = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.updateCalendarEvent)(tokens, eventId, updates); // Assume throws on API error\n            console.log(`Successfully updated event: ${eventId}`);\n            // Invalidate cache for both original and new ranges\n            // **Requires invalidateCache function**\n            const rangesToInvalidate = [];\n            if (originalStartDate && originalEndDate) rangesToInvalidate.push({\n                start: originalStartDate,\n                end: originalEndDate\n            });\n            // Use updated event data for new range\n            const newStartDate = updatedEvent.start?.dateTime || updatedEvent.start?.date;\n            const newEndDate = updatedEvent.end?.dateTime || updatedEvent.end?.date;\n            if (newStartDate && newEndDate) rangesToInvalidate.push({\n                start: newStartDate,\n                end: newEndDate\n            });\n            if (rangesToInvalidate.length > 0) {\n                const uniqueRanges = [\n                    ...new Set(rangesToInvalidate.map(JSON.stringify))\n                ].map(JSON.parse);\n                console.log(\"Invalidating cache ranges:\", uniqueRanges);\n                for (const range of uniqueRanges){\n                    try {\n                        await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, range.start, range.end);\n                    } catch (cacheError) {\n                        console.error(`Error invalidating cache range ${range.start}-${range.end}:`, cacheError);\n                    }\n                }\n            } else {\n                console.warn(`Could not determine date range(s) for event ${eventId} update, broad cache invalidation might be needed.`);\n                try {\n                    await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens);\n                } catch (cacheError) {\n                    console.error(\"Error invalidating cache after update (fallback):\", cacheError);\n                }\n            }\n            // Return the updated event object, adding a success flag\n            return {\n                ...updatedEvent,\n                success: true\n            };\n        } catch (error) {\n            console.error(`Error updating event ${eventId}:`, error);\n            return {\n                success: false,\n                error: `Failed to update event ${eventId}: ${error.message}`,\n                eventId: eventId\n            };\n        }\n    },\n    findAvailableSlots: async (args, userId = \"default\", accessToken = null)=>{\n        // Uses getCachedEventsForDateRange, findAvailableSlotsUtil\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            slots: []\n        };\n        const tokens = {\n            access_token: accessToken\n        };\n        const { duration, startDate: reqStartDate, endDate: reqEndDate, timePreference = \"any\", activity = \"event\" } = args;\n        if (!duration || typeof duration !== \"number\" || duration <= 0) {\n            return {\n                error: \"Valid duration (in minutes) is required.\",\n                slots: []\n            };\n        }\n        // Default search range: next 7 days from now\n        const now = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        const startDate = reqStartDate ? luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(reqStartDate) : now;\n        const endDate = reqEndDate ? luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(reqEndDate) : startDate.plus({\n            days: 7\n        });\n        if (!startDate.isValid || !endDate.isValid) {\n            return {\n                error: `Invalid date format. Use ISO 8601. Received start=${reqStartDate}, end=${reqEndDate}`,\n                slots: []\n            };\n        }\n        if (startDate >= endDate) {\n            return {\n                error: \"Start date must be before end date.\",\n                slots: []\n            };\n        }\n        try {\n            // Fetch events for the entire search range first (cache-aware)\n            // **Requires getCachedEventsForDateRange function**\n            const cacheKeyStart = startDate.startOf(\"day\").toISODate();\n            const cacheKeyEnd = endDate.endOf(\"day\").toISODate(); // Cache daily granularity\n            const tokenHash = accessToken.substring(accessToken.length - 10);\n            const userIdCachePrefix = `user_${tokenHash}`;\n            let events = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n            if (!events) {\n                console.log(`Cache MISS for slot search events ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // **Requires fetchGCalendarEventsInternal function**\n                const apiEvents = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.getCalendarEvents)(tokens, startDate.startOf(\"day\").toJSDate(), endDate.endOf(\"day\").toJSDate());\n                if (apiEvents && Array.isArray(apiEvents)) {\n                    events = apiEvents;\n                    await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.cacheEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd, events, 300);\n                } else {\n                    events = []; // Assume no events if fetch fails\n                }\n            } else {\n                console.log(`Cache HIT for slot search events ${cacheKeyStart} to ${cacheKeyEnd}`);\n            }\n            // Filter events to the precise requested time window *before* finding slots\n            const relevantEvents = events.filter((event)=>{\n                const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                return eventStart.isValid && eventEnd.isValid && eventStart < endDate && eventEnd > startDate;\n            });\n            // Use the imported findAvailableSlots function\n            const slots = await (0,_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__.findAvailableSlots)(relevantEvents, duration, startDate.toISO(), endDate.toISO(), activity, timePreference);\n            return slots; // Return raw slots array (formatToolResponse handles presentation)\n        } catch (error) {\n            console.error(`Error in findAvailableSlots tool (${duration}min, ${startDate.toISO()} to ${endDate.toISO()}):`, error);\n            // Return an error object instead of throwing\n            return {\n                error: `Failed to find available slots: ${error.message}`,\n                slots: []\n            };\n        }\n    },\n    getWeatherForecast: async (args, userId = \"default\", accessToken = null)=>{\n        // Placeholder - requires actual weather API integration\n        const { location, date: dateString } = args;\n        if (!location) return {\n            error: \"Location is required for weather forecast.\",\n            success: false\n        };\n        // Default to today if date is missing or invalid\n        let forecastDate = dateString ? luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(dateString) : luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        if (!forecastDate.isValid) {\n            console.warn(`Invalid date provided for weather forecast: ${dateString}. Defaulting to today.`);\n            forecastDate = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        }\n        const formattedDate = forecastDate.toISODate(); // YYYY-MM-DD\n        console.log(`Placeholder: Fetching weather for ${location} on ${formattedDate}`);\n        try {\n            // --- Replace with actual weather API call ---\n            // Example: const weatherData = await getWeatherData(location, formattedDate);\n            // return { ...weatherData, success: true };\n            // --- Placeholder response ---\n            return {\n                location: location,\n                date: formattedDate,\n                forecast: `Weather data for ${location} on ${formattedDate} is currently unavailable.`,\n                success: false // Indicate data is not actual\n            };\n        } catch (error) {\n            console.error(`Error fetching weather for ${location}, ${formattedDate}:`, error);\n            return {\n                location: location,\n                date: formattedDate,\n                error: `Failed to get weather forecast: ${error.message}`,\n                success: false\n            };\n        }\n    },\n    deleteCalendarEventsByQuery: async (args, userId = \"default\", accessToken = null)=>{\n        // Uses getCachedEventsForDateRange, deleteGCalendarEventInternal, invalidateCache\n        if (!accessToken) {\n            return {\n                error: \"User not authenticated.\",\n                success: false,\n                deletedCount: 0\n            };\n        }\n        const tokens = {\n            access_token: accessToken\n        };\n        const { query, start_date, end_date } = args;\n        if (!query || !start_date || !end_date) {\n            return {\n                error: \"Query, start date, and end date are required.\",\n                success: false,\n                deletedCount: 0\n            };\n        }\n        const startDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(start_date);\n        const endDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(end_date);\n        if (!startDt.isValid || !endDt.isValid) {\n            return {\n                error: `Invalid date format. Use ISO 8601.`,\n                success: false,\n                deletedCount: 0\n            };\n        }\n        if (startDt >= endDt) {\n            return {\n                error: \"Start date must be before end date.\",\n                success: false,\n                deletedCount: 0\n            };\n        }\n        console.log(`Attempting to delete events matching \"${query}\" between ${startDt.toISO()} and ${endDt.toISO()}`);\n        try {\n            // 1. Get all events in the range (use cache)\n            // **Requires getCachedEventsForDateRange function**\n            const cacheKeyStart = startDt.startOf(\"day\").toISODate();\n            const cacheKeyEnd = endDt.endOf(\"day\").toISODate();\n            const tokenHash = accessToken.substring(accessToken.length - 10);\n            const userIdCachePrefix = `user_${tokenHash}`;\n            let events = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n            if (!events) {\n                console.log(`Cache MISS for bulk delete search ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // **Requires fetchGCalendarEventsInternal function**\n                const apiEvents = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.getCalendarEvents)(tokens, startDt.startOf(\"day\").toJSDate(), endDt.endOf(\"day\").toJSDate());\n                events = Array.isArray(apiEvents) ? apiEvents : [];\n            // No need to cache here as we are about to delete potentially many events\n            } else {\n                console.log(`Cache HIT for bulk delete search ${cacheKeyStart} to ${cacheKeyEnd}`);\n            }\n            // Filter events precisely by requested time *and* query\n            const queryLower = query.toLowerCase();\n            const matchingEvents = events.filter((event)=>{\n                const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                const summaryLower = event.summary?.toLowerCase() || \"\";\n                return eventStart.isValid && eventEnd.isValid && eventStart < endDt && eventEnd > startDt && // Check time overlap\n                summaryLower.includes(queryLower); // Check summary match\n            });\n            if (matchingEvents.length === 0) {\n                console.log(`No events matching \"${query}\" found in the specified range.`);\n                return {\n                    success: true,\n                    message: `No events matching \"${query}\" found.`,\n                    deletedCount: 0\n                };\n            }\n            console.log(`Found ${matchingEvents.length} events matching query. Proceeding with deletion...`);\n            // 2. Delete each matching event\n            const deleteResults = [];\n            const failedDeletes = [];\n            for (const event of matchingEvents){\n                try {\n                    // **Requires deleteGCalendarEventInternal function**\n                    const result = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.deleteCalendarEvent)(tokens, event.id); // Assume returns minimal info or throws\n                    deleteResults.push({\n                        id: event.id,\n                        summary: event.summary\n                    });\n                    // **Requires invalidateCache function** - Invalidate immediately after successful delete\n                    try {\n                        const eventStartIso = event.start?.dateTime || event.start?.date;\n                        const eventEndIso = event.end?.dateTime || event.end?.date;\n                        if (eventStartIso && eventEndIso) {\n                            await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, eventStartIso, eventEndIso);\n                        } else {\n                            await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens); // Fallback\n                        }\n                    } catch (cacheError) {\n                        console.error(`Cache invalidation error during bulk delete for ${event.id}:`, cacheError);\n                    }\n                } catch (deleteError) {\n                    console.error(`Failed to delete event ${event.id} (\"${event.summary}\") during bulk operation:`, deleteError);\n                    failedDeletes.push({\n                        id: event.id,\n                        summary: event.summary,\n                        error: deleteError.message\n                    });\n                }\n            }\n            // 3. Compile and return result\n            const successCount = deleteResults.length;\n            let message = `Successfully deleted ${successCount} event(s) matching \"${query}\".`;\n            if (failedDeletes.length > 0) {\n                message += ` Failed to delete ${failedDeletes.length} event(s).`;\n                console.warn(\"Failures during bulk delete:\", failedDeletes);\n            }\n            return {\n                success: failedDeletes.length === 0,\n                message: message,\n                deletedCount: successCount,\n                deletedItems: deleteResults,\n                failedItems: failedDeletes // List failures\n            };\n        } catch (error) {\n            console.error(`Error during deleteCalendarEventsByQuery (${query}, ${start_date}-${end_date}):`, error);\n            return {\n                success: false,\n                error: `An error occurred during the bulk delete operation: ${error.message}`,\n                deletedCount: 0\n            };\n        }\n    }\n};\n// --- Exports ---\n// Export the schema and the implementation map\n // processToolCalls is not typically exported from here, but kept for reference\n // export { processToolCalls };\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMsQ0FBQztnQkFDN0U0RixjQUFjO1lBQ2xCO1FBQ0w7SUFDSjtBQUNKO0FBT0Esa0JBQWtCO0FBQ2xCLCtDQUErQztBQUNmLENBR2hDLCtFQUErRTtDQUMvRSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nY2FsZW5kYXJhcHAvLi9saWIvdG9vbHMvdG9vbEluZGV4LmpzPzFhNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL3Rvb2xzL2luZGV4LmpzXG4vLyBQdXJwb3NlOiBEZWZpbmVzIHRoZSB0b29scyAoc2NoZW1hKSBhdmFpbGFibGUgdG8gdGhlIExMTSBhbmQgbWFwcyB0aGVtXG4vLyAgICAgICAgICB0byB0aGVpciBjb3JyZXNwb25kaW5nIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9ucy4gQWxzbyBpbmNsdWRlc1xuLy8gICAgICAgICAgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcHJvY2Vzc2luZyB0b29sIGNhbGxzLlxuXG4vLyAtLS0gSU1QT1JUUyAtLS1cbmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSAnbHV4b24nO1xuaW1wb3J0IHsgZ29vZ2xlIH0gZnJvbSAnZ29vZ2xlYXBpcyc7IC8vIFVzZWQgZm9yIGdldC91cGRhdGUgZXZlbnQgYmVmb3JlIGNhbGxpbmcgc3BlY2lmaWMgZnVuY3Rpb25zXG5cbi8vIEltcG9ydCBmcm9tIGdvb2dsZUNhbGVuZGFyLmpzXG5pbXBvcnQge1xuICAgIGNyZWF0ZU9BdXRoMkNsaWVudCxcbiAgICBnZXRDYWxlbmRhckV2ZW50cyBhcyBmZXRjaEdDYWxlbmRhckV2ZW50c0ludGVybmFsLCAvLyBSZW5hbWVkIHRvIGF2b2lkIGNvbmZsaWN0XG4gICAgYWRkQ2FsZW5kYXJFdmVudCBhcyBhZGRHQ2FsZW5kYXJFdmVudEludGVybmFsLFxuICAgIGRlbGV0ZUNhbGVuZGFyRXZlbnQgYXMgZGVsZXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCxcbiAgICB1cGRhdGVDYWxlbmRhckV2ZW50IGFzIHVwZGF0ZUdDYWxlbmRhckV2ZW50SW50ZXJuYWxcbn0gZnJvbSAnLi4vLi4vZ29vZ2xlQ2FsZW5kYXIuanMnO1xuXG4vLyBJbXBvcnQgZnJvbSByZWRpc0NsaWVudC5qc1xuaW1wb3J0IHtcbiAgICBnZXRDYWNoZWRFdmVudHNGb3JEYXRlUmFuZ2UsXG4gICAgY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UsXG4gICAgaW52YWxpZGF0ZURhdGVSYW5nZUNhY2hlLFxufSBmcm9tICcuLi9yZWRpc0NsaWVudC5qcyc7XG5cbi8vIEltcG9ydCBmcm9tIGNhY2hlU2VydmljZS5qc1xuaW1wb3J0IHtcbiAgICBnZXRDYWNoZWRFdmVudHMsXG4gICAgaW52YWxpZGF0ZUNhY2hlXG59IGZyb20gJy4uL3NlcnZpY2VzL2NhY2hlU2VydmljZS5qcyc7XG5cbi8vIEltcG9ydCBmcm9tIHNjaGVkdWxpbmdVdGlscy5qc1xuaW1wb3J0IHsgZmluZEF2YWlsYWJsZVNsb3RzIH0gZnJvbSAnLi9zY2hlZHVsaW5nVXRpbHMuanMnO1xuXG4vLyBJbXBvcnQgZnJvbSBjaGVja0ZvckNvbmZsaWN0cy5qc1xuaW1wb3J0IHsgY2hlY2tGb3JDb25mbGljdHMgfSBmcm9tICcuL2NoZWNrRm9yQ29uZmxpY3RzLmpzJztcblxuLy8gSW1wb3J0IGZyb20gZm9ybWF0dGVycy5qc1xuaW1wb3J0IHsgZm9ybWF0RXZlbnRUaW1lLCBmb3JtYXRDYWxlbmRhckV2ZW50cywgZm9ybWF0VG9vbFJlc3BvbnNlIH0gZnJvbSAnLi9mb3JtYXR0ZXJzLmpzJztcblxuLy8gSW1wb3J0IGZyb20gcG9zdGdyZXNDbGllbnQuanNcbmltcG9ydCB7XG4gICAgVXNlclByZWZlcmVuY2UsIC8vIEFzc3VtaW5nIG1vZGVscyBhcmUgZXhwb3J0ZWQgZnJvbSBwb3N0Z3Jlc0NsaWVudFxuICAgIGFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbiAvLyBOZWVkZWQgYnkgcHJvY2Vzc1Rvb2xDYWxscyAtICpUaGlzIGlkZWFsbHkgYmVsb25ncyBpbiBkYXRhYmFzZVNlcnZpY2UqXG59IGZyb20gJy4uL3Bvc3RncmVzQ2xpZW50LmpzJztcblxuXG5cbi8vIC0tLSBUb29sIFNjaGVtYSBEZWZpbml0aW9ucyAoZm9yIE9wZW5BSSkgLS0tXG5jb25zdCB0b29scyA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwic2F2ZVVzZXJQcmVmZXJlbmNlXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTYXZlIGEgdXNlciBwcmVmZXJlbmNlIGZvciBmdXR1cmUgcmVmZXJlbmNlLiBVc2UgdGhpcyB3aGVuIHlvdSBpZGVudGlmeSBpbXBvcnRhbnQgdXNlciBwcmVmZXJlbmNlcyAobGlrZSBwcmVmZXJyZWQgbWVldGluZyB0aW1lcywgbG9jYXRpb25zLCBhY3Rpdml0eSB0eXBlcywgc2NoZWR1bGluZyBjb25zdHJhaW50cykgdGhhdCBzaG91bGQgYmUgcmVtZW1iZXJlZCBsb25nLXRlcm0uXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBicm9hZCBjYXRlZ29yeSBvZiB0aGUgcHJlZmVyZW5jZSAoZS5nLiwgJ3NjaGVkdWxpbmcnLCAnbG9jYXRpb24nLCAnYWN0aXZpdHknKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICBrZXk6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIHNwZWNpZmljIHByZWZlcmVuY2Uga2V5IHdpdGhpbiB0aGUgY2F0ZWdvcnkgKGUuZy4sICdwcmVmZXJyZWRNZWV0aW5nSG91cnMnLCAnZGVmYXVsdENpdHknLCAnZmF2b3JpdGVXb3Jrb3V0JykuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVPZjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJudW1iZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHt9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcIm9iamVjdFwiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgdmFsdWUgb2YgdGhlIHByZWZlcmVuY2UgKGUuZy4sICc5YW0tMTJwbScsICdOZXcgWW9yaycsICdydW5uaW5nJykuIENhbiBiZSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgYXJyYXksIG9yIG9iamVjdC5cIiBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbDogQWRkaXRpb25hbCBjb250ZXh0IGFib3V0IHdoZW4gb3Igd2h5IHRoaXMgcHJlZmVyZW5jZSBhcHBsaWVzIChlLmcuLCAnd29yayBtZWV0aW5ncycsICd3ZWVrZW5kcycpLlwiIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogW1wiY2F0ZWdvcnlcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWRkQ2FsZW5kYXJFdmVudHNcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkNyZWF0ZXMgb25lIG9yIG1vcmUgbmV3IGV2ZW50cyBkaXJlY3RseSBpbiB0aGUgdXNlcidzIHByaW1hcnkgR29vZ2xlIENhbGVuZGFyIGJhc2VkIG9uIHRoZWlyIHJlcXVlc3QuIEV4dHJhY3RzIGRldGFpbHMgbGlrZSB0aXRsZSwgbG9jYXRpb24sIGFuZCByZXNvbHZlcyBzdGFydC9lbmQgdGltZXMgKHVzaW5nIGN1cnJlbnQgdGltZSBjb250ZXh0IGZvciByZWxhdGl2ZSByZWZlcmVuY2VzIGxpa2UgJ3RvbW9ycm93IDRwbScpIGludG8gYWJzb2x1dGUgSVNPIDg2MDEgZm9ybWF0LiBBc3N1bWVzIGEgMS1ob3VyIGR1cmF0aW9uIGlmIG5vdCBzcGVjaWZpZWQuIENoZWNrcyBmb3IgY29uZmxpY3RzIGJlZm9yZSBhZGRpbmcuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgZXZlbnQgb2JqZWN0cyB0byBjcmVhdGUuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSB0aXRsZS9zdW1tYXJ5IG9mIHRoZSBldmVudCAoZS5nLiwgJ01lZXRpbmcgd2l0aCBDbHlkZScpLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBzdGFydCBkYXRlIGFuZCB0aW1lIG9mIHRoZSBldmVudCBpbiBTVFJJQ1QgSVNPIDg2MDEgZm9ybWF0IGluY2x1ZGluZyB0aW1lem9uZSBvZmZzZXQgKGUuZy4sICcyMDI1LTA0LTAxVDE2OjAwOjAwLTA3OjAwJykuIFJlc29sdmUgcmVsYXRpdmUgdGltZXMgKGxpa2UgJ3RvbW9ycm93IDRwbScpIGJhc2VkIG9uIGN1cnJlbnQgdGltZSBjb250ZXh0IGJlZm9yZSBjYWxsaW5nLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgZW5kIGRhdGUgYW5kIHRpbWUgb2YgdGhlIGV2ZW50IGluIFNUUklDVCBJU08gODYwMSBmb3JtYXQgaW5jbHVkaW5nIHRpbWV6b25lIG9mZnNldCAoZS5nLiwgJzIwMjUtMDQtMDFUMTc6MDA6MDAtMDc6MDAnKS4gUmVzb2x2ZSByZWxhdGl2ZSB0aW1lczsgYXNzdW1lIDFociBkdXJhdGlvbiBmcm9tIHN0YXJ0IGlmIGVuZCB0aW1lIGlzIG5vdCBzcGVjaWZpZWQuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiT3B0aW9uYWwgZGVzY3JpcHRpb24gb3Igbm90ZXMgZm9yIHRoZSBldmVudC5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbCBsb2NhdGlvbiBmb3IgdGhlIGV2ZW50IChlLmcuLCAnU3RhcmJ1Y2tzIE1haW4gU3QnLCAnWm9vbSBMaW5rJykuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtaW5kZXJzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJudW1iZXJcIiB9LCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbCByZW1pbmRlciB0aW1lcyBpbiBtaW51dGVzIGJlZm9yZSB0aGUgZXZlbnQgc3RhcnQgKGUuZy4sIFsxMCwgMzBdKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFtcInN1bW1hcnlcIiwgXCJzdGFydFwiLCBcImVuZFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogW1wiZXZlbnRzXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogXCJnZXRDYWxlbmRhckV2ZW50c1wiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmV0cmlldmVzIGV2ZW50cyBmcm9tIHRoZSB1c2VyJ3MgcHJpbWFyeSBHb29nbGUgQ2FsZW5kYXIgd2l0aGluIGEgc3BlY2lmaWVkIGRhdGUgcmFuZ2UuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RhdGU6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIHN0YXJ0IGRhdGUvdGltZSBmb3IgdGhlIHF1ZXJ5IHJhbmdlIGluIElTTyA4NjAxIGZvcm1hdCAoZS5nLiwgJzIwMjUtMDQtMDFUMDA6MDA6MDBaJyBvciAnMjAyNS0wNC0wMScpLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZF9kYXRlOiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBlbmQgZGF0ZS90aW1lIGZvciB0aGUgcXVlcnkgcmFuZ2UgaW4gSVNPIDg2MDEgZm9ybWF0IChlLmcuLCAnMjAyNS0wNC0wMlQwMDowMDowMFonIG9yICcyMDI1LTA0LTAyJykuXCIgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJzdGFydF9kYXRlXCIsIFwiZW5kX2RhdGVcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiBcImRlbGV0ZUNhbGVuZGFyRXZlbnRcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkRlbGV0ZXMgYSBzcGVjaWZpYyBldmVudCBmcm9tIHRoZSB1c2VyJ3MgcHJpbWFyeSBHb29nbGUgQ2FsZW5kYXIgdXNpbmcgaXRzIHVuaXF1ZSBldmVudCBJRC4gUmV0cmlldmVzIGV2ZW50IGRldGFpbHMgZmlyc3QgdG8gaW52YWxpZGF0ZSBzcGVjaWZpYyBjYWNoZSByYW5nZS5cIixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRJZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSB1bmlxdWUgSUQgb2YgdGhlIGV2ZW50IHRvIGRlbGV0ZSAoZS5nLiwgJzh1dDNhNmVvbDFvdjVvdnYyM3Y4NW9zc3NnJykuIFRoZSB1c2VyIG1pZ2h0IHByb3ZpZGUgdGhlIGV2ZW50IHRpdGxlL3RpbWUsIHVzZSBnZXRDYWxlbmRhckV2ZW50cyBmaXJzdCBpZiBJRCBpcyB1bmtub3duLlwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJldmVudElkXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogXCJ1cGRhdGVDYWxlbmRhckV2ZW50XCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJVcGRhdGVzIGRldGFpbHMgKGxpa2UgdGltZSwgdGl0bGUsIGxvY2F0aW9uLCBkZXNjcmlwdGlvbikgb2YgYW4gZXhpc3RpbmcgZXZlbnQgaW4gdGhlIHVzZXIncyBwcmltYXJ5IEdvb2dsZSBDYWxlbmRhciB1c2luZyBpdHMgSUQuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgdW5pcXVlIElEIG9mIHRoZSBldmVudCB0byB1cGRhdGUgKGUuZy4sICc4dXQzYTZlb2wxb3Y1b3Z2MjN2ODVvc3NzZycpLiBUaGUgdXNlciBtaWdodCBwcm92aWRlIHRoZSBldmVudCB0aXRsZS90aW1lLCB1c2UgZ2V0Q2FsZW5kYXJFdmVudHMgZmlyc3QgaWYgSUQgaXMgdW5rbm93bi5cIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiTmV3IHRpdGxlL3N1bW1hcnkgZm9yIHRoZSBldmVudC5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIk5ldyBkZXNjcmlwdGlvbiBmb3IgdGhlIGV2ZW50LlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiTmV3IGxvY2F0aW9uIGZvciB0aGUgZXZlbnQuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJOZXcgc3RhcnQgdGltZSBpbiBJU08gODYwMSBmb3JtYXQgKGUuZy4sICcyMDI1LTA0LTAxVDE2OjMwOjAwLTA3OjAwJykuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiTmV3IGVuZCB0aW1lIGluIElTTyA4NjAxIGZvcm1hdCAoZS5nLiwgJzIwMjUtMDQtMDFUMTc6MDA6MDAtMDc6MDAnKS5cIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogQWRkIHJlbWluZGVycyB1cGRhdGUgaWYgbmVlZGVkL2ltcGxlbWVudGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiT2JqZWN0IGNvbnRhaW5pbmcgQVQgTEVBU1QgT05FIGZpZWxkIHRvIHVwZGF0ZS4gSW5jbHVkZSBvbmx5IGZpZWxkcyB0aGF0IGFyZSBjaGFuZ2luZy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblByb3BlcnRpZXM6IDEgLy8gRW5zdXJlIGF0IGxlYXN0IG9uZSB1cGRhdGUgaXMgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFtcImV2ZW50SWRcIiwgXCJ1cGRhdGVzXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogXCJmaW5kQXZhaWxhYmxlU2xvdHNcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbmRzIG11bHRpcGxlIGF2YWlsYWJsZSB0aW1lIHNsb3RzIGluIHRoZSB1c2VyJ3MgY2FsZW5kYXIgc3VpdGFibGUgZm9yIHNjaGVkdWxpbmcgYSBuZXcgZXZlbnQuIENvbnNpZGVycyBleGlzdGluZyBldmVudHMuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IHR5cGU6IFwibnVtYmVyXCIsIGRlc2NyaXB0aW9uOiBcIlJlcXVpcmVkIGR1cmF0aW9uIG9mIHRoZSBldmVudCBpbiBtaW51dGVzIChlLmcuLCAzMCwgNjApLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgc3RhcnQgZGF0ZS90aW1lIHRvIHNlYXJjaCBmcm9tLCBpbiBJU08gODYwMSBmb3JtYXQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHRpbWUgaWYgbm90IHByb3ZpZGVkLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZERhdGU6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIGVuZCBkYXRlL3RpbWUgdG8gc2VhcmNoIHVudGlsLCBpbiBJU08gODYwMSBmb3JtYXQuIERlZmF1bHRzIHRvIDcgZGF5cyBmcm9tIHN0YXJ0RGF0ZSBpZiBub3QgcHJvdmlkZWQuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVByZWZlcmVuY2U6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogW1wibW9ybmluZ1wiLCBcImFmdGVybm9vblwiLCBcImV2ZW5pbmdcIiwgXCJhbnlcIl0sIGRlc2NyaXB0aW9uOiBcIk9wdGlvbmFsIHByZWZlcnJlZCB0aW1lIG9mIGRheSAoZGVmYXVsdHMgdG8gJ2FueScpLiBNb3JuaW5nICh+OWFtLTEycG0pLCBBZnRlcm5vb24gKH4xMnBtLTVwbSksIEV2ZW5pbmcgKH41cG0tOXBtKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICBhY3Rpdml0eTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbDogVGhlIHR5cGUgb2YgYWN0aXZpdHkgYmVpbmcgc2NoZWR1bGVkIChlLmcuLCAnbWVldGluZycsICd3b3Jrb3V0JywgJ2NhbGwnKSB0byBwb3RlbnRpYWxseSBpbmZsdWVuY2Ugc3VnZ2VzdGlvbnMgb3IgY2hlY2sgY29uc3RyYWludHMuXCIgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJkdXJhdGlvblwiXSwgLy8gT25seSBkdXJhdGlvbiBpcyBzdHJpY3RseSByZXF1aXJlZCwgb3RoZXJzIGNhbiBoYXZlIGRlZmF1bHRzLlxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogXCJnZXRXZWF0aGVyRm9yZWNhc3RcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkdldHMgdGhlIHdlYXRoZXIgZm9yZWNhc3QgZm9yIGEgc3BlY2lmaWMgbG9jYXRpb24gYW5kIGRhdGUuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBjaXR5IGFuZCBzdGF0ZSwgb3IgemlwIGNvZGUgZm9yIHRoZSB3ZWF0aGVyIGZvcmVjYXN0IChlLmcuLCAnU2FuIEZyYW5jaXNjbywgQ0EnLCAnOTQxMDcnKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICBkYXRlOiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBkYXRlIGZvciB0aGUgZm9yZWNhc3QgaW4gSVNPIDg2MDEgZm9ybWF0IChZWVlZLU1NLUREKS4gRGVmYXVsdHMgdG8gdG9kYXkgaWYgbm90IHNwZWNpZmllZC5cIiB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogW1wibG9jYXRpb25cIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwiZGVsZXRlQ2FsZW5kYXJFdmVudHNCeVF1ZXJ5XCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWxldGVzIG11bHRpcGxlIGNhbGVuZGFyIGV2ZW50cyB3aXRoaW4gYSBzcGVjaWZpZWQgZGF0ZSByYW5nZSB0aGF0IG1hdGNoIGEgc2VhcmNoIHF1ZXJ5IGluIHRoZWlyIHRpdGxlL3N1bW1hcnkuIFVzZSB3aXRoIGNhdXRpb24uXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHNlYXJjaCBxdWVyeSB0byBtYXRjaCBhZ2FpbnN0IGV2ZW50IHN1bW1hcmllcyAoZS5nLiwgJ2d5bScsICdtZWV0aW5nIHdpdGggcHJvamVjdCBYJykuIENhc2UtaW5zZW5zaXRpdmUuXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGF0ZTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgc3RhcnQgZGF0ZS90aW1lIGZvciB0aGUgc2VhcmNoIHJhbmdlIGluIElTTyA4NjAxIGZvcm1hdCAoZS5nLiwgJzIwMjUtMDQtMDEnKS4gUmVxdWlyZWQuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RhdGU6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIGVuZCBkYXRlL3RpbWUgZm9yIHRoZSBzZWFyY2ggcmFuZ2UgaW4gSVNPIDg2MDEgZm9ybWF0IChlLmcuLCAnMjAyNS0wNC0zMCcpLiBSZXF1aXJlZC5cIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFtcInF1ZXJ5XCIsIFwic3RhcnRfZGF0ZVwiLCBcImVuZF9kYXRlXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuXTtcblxuXG4vLyAtLS0gVG9vbCBGdW5jdGlvbiBJbXBsZW1lbnRhdGlvbnMgLS0tXG4vLyBNYXBzIHRvb2wgbmFtZXMgKGZyb20gc2NoZW1hKSB0byB0aGUgYWN0dWFsIGZ1bmN0aW9ucyB0aGF0IGV4ZWN1dGUgdGhlbS5cbmNvbnN0IHRvb2xGdW5jdGlvbnMgPSB7XG4gICAgc2F2ZVVzZXJQcmVmZXJlbmNlOiBhc3luYyAoYXJncywgdXNlcklkID0gJ2RlZmF1bHQnLCBhY2Nlc3NUb2tlbiA9IG51bGwpID0+IHtcbiAgICAgICAgLy8gQWNjZXNzaW5nIFVzZXJQcmVmZXJlbmNlIG1vZGVsIGRpcmVjdGx5IC0gaWRlYWxseSB1c2UgZGF0YWJhc2VTZXJ2aWNlXG4gICAgICAgIGlmICghdXNlcklkIHx8IHVzZXJJZCA9PT0gJ2RlZmF1bHQnKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogXCJFcnJvcjogVXNlciBJRCBpcyBtaXNzaW5nLlwiIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAqKlJlcXVpcmVzIFVzZXJQcmVmZXJlbmNlIG1vZGVsIHRvIGJlIGltcG9ydGVkKipcbiAgICAgICAgICAgIGxldCB1c2VyUHJlZiA9IGF3YWl0IFVzZXJQcmVmZXJlbmNlLmZpbmRPbmUoeyB3aGVyZTogeyB1c2VyX2lkOiB1c2VySWQgfSB9KTtcbiAgICAgICAgICAgIGlmICghdXNlclByZWYpIHVzZXJQcmVmID0gYXdhaXQgVXNlclByZWZlcmVuY2UuY3JlYXRlKHsgdXNlcl9pZDogdXNlcklkLCBwcmVmZXJlbmNlc19kYXRhOiB7fSB9KTtcblxuICAgICAgICAgICAgY29uc3QgeyBjYXRlZ29yeSwga2V5LCB2YWx1ZSwgY29udGV4dCB9ID0gYXJncztcbiAgICAgICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGlmICghY2F0ZWdvcnkgfHwgIWtleSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBcIkVycm9yOiBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkcyAoY2F0ZWdvcnksIGtleSwgdmFsdWUpIGZvciBwcmVmZXJlbmNlLlwiIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHByZWZzRGF0YSA9IHVzZXJQcmVmLnByZWZlcmVuY2VzX2RhdGEgfHwge307XG4gICAgICAgICAgICBpZiAoIXByZWZzRGF0YVtjYXRlZ29yeV0pIHByZWZzRGF0YVtjYXRlZ29yeV0gPSB7fTtcbiAgICAgICAgICAgIHByZWZzRGF0YVtjYXRlZ29yeV1ba2V5XSA9IHZhbHVlOyAvLyBPdmVyd3JpdGUgZXhpc3RpbmcgdmFsdWUgc2ltcGx5XG4gICAgICAgICAgICAvLyBIYW5kbGUgY29udGV4dCBzZXBhcmF0ZWx5IGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7IC8vIEFsbG93IGVtcHR5IHN0cmluZyBmb3IgY29udGV4dFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBgJHtjYXRlZ29yeX1fY29udGV4dGA7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVmc0RhdGFbY29udGV4dEtleV0pIHByZWZzRGF0YVtjb250ZXh0S2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIHByZWZzRGF0YVtjb250ZXh0S2V5XVtrZXldID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdXNlclByZWYudXBkYXRlKHsgcHJlZmVyZW5jZXNfZGF0YTogcHJlZnNEYXRhIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFByZWZlcmVuY2Ugc2F2ZWQgZm9yIHVzZXIgJHt1c2VySWR9OiAke2NhdGVnb3J5fS4ke2tleX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6IGBQcmVmZXJlbmNlIHNhdmVkOiAke2NhdGVnb3J5fS4ke2tleX0gPSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgcHJlZmVyZW5jZSBmb3IgdXNlciAke3VzZXJJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IGBGYWlsZWQgdG8gc2F2ZSBwcmVmZXJlbmNlOiAke2Vycm9yLm1lc3NhZ2V9YCB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZENhbGVuZGFyRXZlbnRzOiBhc3luYyAoYXJncywgdXNlcklkID0gJ2RlZmF1bHQnLCBhY2Nlc3NUb2tlbiA9IG51bGwpID0+IHtcbiAgICAgICAgLy8gVXNlcyBpbXBvcnRlZCBhZGRHQ2FsZW5kYXJFdmVudEludGVybmFsLCBjaGVja0ZvckNvbmZsaWN0cywgaW52YWxpZGF0ZUNhY2hlXG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlIH07IC8vIFJldHVybiBlcnJvciBvYmplY3RcbiAgICAgICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBhcmdzO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSB8fCBldmVudHMubGVuZ3RoID09PSAwKSByZXR1cm4geyBtZXNzYWdlOiBcIk5vIGV2ZW50IGRhdGEgcHJvdmlkZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBhZmZlY3RlZERhdGVSYW5nZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgaWYgKCFldmVudC5zdW1tYXJ5IHx8ICFldmVudC5zdGFydCB8fCAhZXZlbnQuZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgc3VtbWFyeTogZXZlbnQuc3VtbWFyeSB8fCAnPycsIGVycm9yOiBcIk1pc3NpbmcgcmVxdWlyZWQgZmllbGRzIChzdW1tYXJ5LCBzdGFydCwgZW5kKS5cIiwgc3VjY2VzczogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0RHQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmREdCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0RHQuaXNWYWxpZCB8fCAhZW5kRHQuaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGUgZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RHQgPj0gZW5kRHQpIHRocm93IG5ldyBFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIGJlZm9yZSBlbmQgdGltZScpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IHN1bW1hcnk6IGV2ZW50LnN1bW1hcnksIGVycm9yOiBgSW52YWxpZCBkYXRlIGZvcm1hdCBvciBsb2dpYzogJHtlLm1lc3NhZ2V9LiBVc2UgSVNPIDg2MDEgZm9ybWF0LmAsIHN1Y2Nlc3M6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAvLyAqKlJlcXVpcmVzIGNoZWNrRm9yQ29uZmxpY3RzIGZ1bmN0aW9uIHRvIGJlIGF2YWlsYWJsZSoqXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmxpY3RDaGVja1Jlc3VsdCA9IGF3YWl0IGNoZWNrRm9yQ29uZmxpY3RzKHRva2VucywgZXZlbnQuc3RhcnQsIGV2ZW50LmVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0Q2hlY2tSZXN1bHQuY29uZmxpY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ29uZmxpY3QgZGV0ZWN0ZWQgZm9yIGV2ZW50OiAke2V2ZW50LnN1bW1hcnl9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBldmVudC5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogY29uZmxpY3RDaGVja1Jlc3VsdC5zdWdnZXN0aW9ucyB8fCBbXSwgLy8gUGFzcyBzdWdnZXN0aW9ucyBiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY29uZmxpY3RDaGVja1Jlc3VsdC5lcnJvciB8fCBgRXZlbnQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcgc2NoZWR1bGUuYCwgLy8gSW5jbHVkZSBlcnJvciBpZiBhbnkgZnJvbSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gKipSZXF1aXJlcyBhZGRHQ2FsZW5kYXJFdmVudEludGVybmFsIGZ1bmN0aW9uKipcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkZWRFdmVudCA9IGF3YWl0IGFkZEdDYWxlbmRhckV2ZW50SW50ZXJuYWwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVtaW5kZXJzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtaW5nIGFkZEdDYWxlbmRhckV2ZW50SW50ZXJuYWwgcmV0dXJucyB0aGUgY3JlYXRlZCBldmVudCBvYmplY3Qgb24gc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyAuLi5hZGRlZEV2ZW50LCBzdWNjZXNzOiB0cnVlIH0pOyAvLyBBZGQgc3VjY2VzcyBmbGFnXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRGF0ZVJhbmdlcy5wdXNoKHsgc3RhcnQ6IGV2ZW50LnN0YXJ0LCBlbmQ6IGV2ZW50LmVuZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV2ZW50IGFkZGVkOiAke2V2ZW50LnN1bW1hcnl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoYWRkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgZXZlbnQgXCIke2V2ZW50LnN1bW1hcnl9XCIgZHVyaW5nIGNvbmZsaWN0IGNoZWNrIG9yIEFQSSBjYWxsOmAsIGFkZEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyBzdW1tYXJ5OiBldmVudC5zdW1tYXJ5LCBlcnJvcjogYEZhaWxlZCB0byBwcm9jZXNzIGV2ZW50OiAke2FkZEVycm9yLm1lc3NhZ2V9YCwgc3VjY2VzczogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIGZvciBhbGwgcmFuZ2VzIHdoZXJlIGV2ZW50cyB3ZXJlIHN1Y2Nlc3NmdWxseSBhZGRlZFxuICAgICAgICAvLyAqKlJlcXVpcmVzIGludmFsaWRhdGVDYWNoZSBmdW5jdGlvbioqXG4gICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgYWZmZWN0ZWREYXRlUmFuZ2VzKSB7XG4gICAgICAgICAgICB0cnkgeyBhd2FpdCBpbnZhbGlkYXRlQ2FjaGUodG9rZW5zLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTsgfVxuICAgICAgICAgICAgY2F0Y2ggKGNhY2hlRXJyb3IpIHsgY29uc29sZS5lcnJvcihcIkVycm9yIGludmFsaWRhdGluZyBjYWNoZSBhZnRlciBhZGQ6XCIsIGNhY2hlRXJyb3IpOyB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0czsgLy8gUmV0dXJuIGFycmF5IG9mIHJlc3VsdCBvYmplY3RzICh3aXRoIHN1Y2Nlc3MgZmxhZ3MvZXJyb3JzKVxuICAgIH0sXG5cbiAgICBnZXRDYWxlbmRhckV2ZW50czogYXN5bmMgKGFyZ3MsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsKSA9PiB7XG4gICAgICAgIC8vIFVzZXMgZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlIC0+IGZldGNoR0NhbGVuZGFyRXZlbnRzSW50ZXJuYWxcbiAgICAgICAgaWYgKCFhY2Nlc3NUb2tlbikgcmV0dXJuIFwiRXJyb3I6IFVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCI7IC8vIFJldHVybiBlcnJvciBzdHJpbmdcbiAgICAgICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgICAgIGNvbnN0IHsgc3RhcnRfZGF0ZSwgZW5kX2RhdGUgfSA9IGFyZ3M7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZGF0ZXNcbiAgICAgICAgaWYgKCFzdGFydF9kYXRlIHx8ICFlbmRfZGF0ZSkge1xuICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBCb3RoIHN0YXJ0X2RhdGUgYW5kIGVuZF9kYXRlIGFyZSByZXF1aXJlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydER0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzdGFydF9kYXRlKTtcbiAgICAgICAgY29uc3QgZW5kRHQgPSBEYXRlVGltZS5mcm9tSVNPKGVuZF9kYXRlKTtcbiAgICAgICAgaWYgKCFzdGFydER0LmlzVmFsaWQgfHwgIWVuZER0LmlzVmFsaWQpIHtcbiAgICAgICAgICAgICByZXR1cm4gYEVycm9yOiBJbnZhbGlkIGRhdGUgZm9ybWF0LiBQbGVhc2UgdXNlIElTTyA4NjAxIChlLmcuLCBZWVlZLU1NLUREIG9yIFlZWVktTU0tRERUSEg6bW06c3NaKS4gUmVjZWl2ZWQ6IHN0YXJ0PSR7c3RhcnRfZGF0ZX0sIGVuZD0ke2VuZF9kYXRlfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RHQgPj0gZW5kRHQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBTdGFydCBkYXRlIG11c3QgYmUgYmVmb3JlIGVuZCBkYXRlLlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAvLyAqKlJlcXVpcmVzIGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSBmdW5jdGlvbioqICh3aGljaCBsaWtlbHkgY2FsbHMgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbClcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgc3BlY2lmaWMgZnVuY3Rpb24gZm9yIGRhdGUgcmFuZ2UgY2FjaGluZ1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXlTdGFydCA9IHN0YXJ0RHQudG9JU09EYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleUVuZCA9IGVuZER0LnRvSVNPRGF0ZSgpOyAvLyBVc2UgY29uc2lzdGVudCBkYXRlLW9ubHkga2V5cyBmb3IgZGFpbHkgY2FjaGUgcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IHRva2VuSGFzaCA9IGFjY2Vzc1Rva2VuLnN1YnN0cmluZyhhY2Nlc3NUb2tlbi5sZW5ndGggLSAxMCk7IC8vIFNpbXBsZSBoYXNoIGZvciB1c2VyIHNlcGFyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZENhY2hlUHJlZml4ID0gYHVzZXJfJHt0b2tlbkhhc2h9YDsgLy8gT3IgdXNlIGFjdHVhbCBzdGFibGUgdXNlcklkIGlmIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAvLyBGZXRjaCBmcm9tIGNhY2hlIG9yIEFQSVxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWRDYWNoZVByZWZpeCwgY2FjaGVLZXlTdGFydCwgY2FjaGVLZXlFbmQpO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENhY2hlIEhJVCBmb3IgZXZlbnRzICR7Y2FjaGVLZXlTdGFydH0gdG8gJHtjYWNoZUtleUVuZH1gKTtcbiAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGV2ZW50cyBiYXNlZCBvbiB0aGUgKmV4YWN0KiBzdGFydC9lbmQgdGltZSByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIsIGFzIGNhY2hlIG1pZ2h0IGJlIGJyb2FkZXIgKGRhaWx5KVxuICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50LnN0YXJ0Py5kYXRlVGltZSB8fCBldmVudC5zdGFydD8uZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudEVuZCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kPy5kYXRlVGltZSB8fCBldmVudC5lbmQ/LmRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHZhbGlkIGRhdGVzIGJlZm9yZSBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50U3RhcnQuaXNWYWxpZCB8fCAhZXZlbnRFbmQuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnQgb3ZlcmxhcHMgd2l0aCB0aGUgcmVxdWVzdGVkIHJhbmdlIFtzdGFydER0LCBlbmREdClcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudFN0YXJ0IDwgZW5kRHQgJiYgZXZlbnRFbmQgPiBzdGFydER0O1xuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRzOyAvLyBSZXR1cm4gcG90ZW50aWFsbHkgZmlsdGVyZWQgZXZlbnRzIGFycmF5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBNSVNTIGZvciBldmVudHMgJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgICAgIC8vICoqUmVxdWlyZXMgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCBmdW5jdGlvbioqXG4gICAgICAgICAgICAgICAgY29uc3QgYXBpRXZlbnRzID0gYXdhaXQgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCh0b2tlbnMsIHN0YXJ0RHQudG9KU0RhdGUoKSwgZW5kRHQudG9KU0RhdGUoKSk7IC8vIEZldGNoIGV4YWN0IHJhbmdlXG4gICAgICAgICAgICAgICAgIGlmIChhcGlFdmVudHMgJiYgQXJyYXkuaXNBcnJheShhcGlFdmVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdCB1c2luZyB0aGUgZGFpbHkgcmFuZ2Uga2V5XG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UodXNlcklkQ2FjaGVQcmVmaXgsIGNhY2hlS2V5U3RhcnQsIGNhY2hlS2V5RW5kLCBhcGlFdmVudHMsIDMwMCk7IC8vIDUgbWluIFRUTFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdG9yZWQgZXZlbnRzIGluIFJlZGlzIGNhY2hlIGZvciAke2NhY2hlS2V5U3RhcnR9IHRvICR7Y2FjaGVLZXlFbmR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaUV2ZW50czsgLy8gUmV0dXJuIHRoZSBmZXRjaGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgTm8gZXZlbnRzIHJldHVybmVkIG9yIG5vbi1hcnJheSBmcm9tIGZldGNoR0NhbGVuZGFyRXZlbnRzSW50ZXJuYWwgZm9yICR7c3RhcnREdC50b0lTTygpfS0ke2VuZER0LnRvSVNPKCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgb24gZmFpbHVyZSBvciBub24tYXJyYXkgcmVzdWx0XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGdldENhbGVuZGFyRXZlbnRzIHRvb2wgKCR7c3RhcnRfZGF0ZX0gdG8gJHtlbmRfZGF0ZX0pOmAsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSB1c2VyLWZyaWVuZGx5IGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZmV0Y2hpbmcgY2FsZW5kYXIgZXZlbnRzOiAke2Vycm9yLm1lc3NhZ2V9LiBDaGVjayBjb25uZWN0aW9uIG9yIHBlcm1pc3Npb25zLmA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlQ2FsZW5kYXJFdmVudDogYXN5bmMgKGFyZ3MsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsKSA9PiB7XG4gICAgICAgIC8vIFVzZXMgZ29vZ2xlLmNhbGVuZGFyIEFQSSBkaXJlY3RseSBmb3IgJ2dldCcsIHRoZW4gZGVsZXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCwgaW52YWxpZGF0ZUNhY2hlXG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBldmVudElkOiBhcmdzLmV2ZW50SWQgfTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgICAgIGNvbnN0IHsgZXZlbnRJZCB9ID0gYXJncztcbiAgICAgICAgaWYgKCFldmVudElkKSByZXR1cm4geyBlcnJvcjogXCJFdmVudCBJRCBpcyByZXF1aXJlZC5cIiwgc3VjY2VzczogZmFsc2UgfTtcblxuICAgICAgICBsZXQgb3JpZ2luYWxTdGFydERhdGUsIG9yaWdpbmFsRW5kRGF0ZSwgZXZlbnRTdW1tYXJ5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBHRVQgdGhlIGV2ZW50IGZpcnN0IHRvIGtub3cgaXRzIGRhdGUgcmFuZ2UgZm9yIGNhY2hlIGludmFsaWRhdGlvblxuICAgICAgICAgICAgLy8gKipSZXF1aXJlcyBjcmVhdGVPQXV0aDJDbGllbnQgZnVuY3Rpb24qKlxuICAgICAgICAgICAgY29uc3Qgb2F1dGgyQ2xpZW50ID0gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucyk7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IGdvb2dsZS5jYWxlbmRhcih7IHZlcnNpb246ICd2MycsIGF1dGg6IG9hdXRoMkNsaWVudCB9KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZXZlbnQgZGV0YWlscyBmb3IgZGVsZXRpb246ICR7ZXZlbnRJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGF3YWl0IGNhbGVuZGFyLmV2ZW50cy5nZXQoeyBjYWxlbmRhcklkOiAncHJpbWFyeScsIGV2ZW50SWQ6IGV2ZW50SWQgfSk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydERhdGUgPSBldmVudC5kYXRhLnN0YXJ0Py5kYXRlVGltZSB8fCBldmVudC5kYXRhLnN0YXJ0Py5kYXRlO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kRGF0ZSA9IGV2ZW50LmRhdGEuZW5kPy5kYXRlVGltZSB8fCBldmVudC5kYXRhLmVuZD8uZGF0ZTtcbiAgICAgICAgICAgICAgICBldmVudFN1bW1hcnkgPSBldmVudC5kYXRhLnN1bW1hcnkgfHwgZXZlbnRJZDsgLy8gVXNlIHN1bW1hcnkgaWYgYXZhaWxhYmxlIGZvciByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBldmVudCBcIiR7ZXZlbnRTdW1tYXJ5fVwiIHN0YXJ0aW5nICR7b3JpZ2luYWxTdGFydERhdGV9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChnZXRFcnJvcikge1xuICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBldmVudCBkb2Vzbid0IGV4aXN0IChlLmcuLCBhbHJlYWR5IGRlbGV0ZWQpXG4gICAgICAgICAgICAgICAgIGlmIChnZXRFcnJvci5jb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFdmVudCAke2V2ZW50SWR9IG5vdCBmb3VuZCBmb3IgZGVsZXRpb24gKG1heSBhbHJlYWR5IGJlIGRlbGV0ZWQpLmApO1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogYEV2ZW50ICR7ZXZlbnRJZH0gbm90IGZvdW5kIChhbHJlYWR5IGRlbGV0ZWQ/KS5gLCBldmVudElkOiBldmVudElkLCBzdW1tYXJ5OiBldmVudElkIH07XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgLy8gUmV0aHJvdyBvdGhlciBlcnJvcnMgZHVyaW5nIGdldFxuICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXRyaWV2ZSBldmVudCBkZXRhaWxzIGJlZm9yZSBkZWxldGU6ICR7Z2V0RXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKipSZXF1aXJlcyBkZWxldGVHQ2FsZW5kYXJFdmVudEludGVybmFsIGZ1bmN0aW9uKipcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIGRlbGV0ZSBldmVudDogJHtldmVudElkfWApO1xuICAgICAgICAgICAgYXdhaXQgZGVsZXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCh0b2tlbnMsIGV2ZW50SWQpOyAvLyBBc3N1bWUgdGhpcyB0aHJvd3Mgb24gQVBJIGVycm9yXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgZXZlbnQ6ICR7ZXZlbnRJZH1gKTtcblxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZSBmb3IgdGhlIHNwZWNpZmljIHJhbmdlIGlmIGtub3duXG4gICAgICAgICAgICAvLyAqKlJlcXVpcmVzIGludmFsaWRhdGVDYWNoZSBmdW5jdGlvbioqXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGFydERhdGUgJiYgb3JpZ2luYWxFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHsgYXdhaXQgaW52YWxpZGF0ZUNhY2hlKHRva2Vucywgb3JpZ2luYWxTdGFydERhdGUsIG9yaWdpbmFsRW5kRGF0ZSk7IH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoY2FjaGVFcnJvcikgeyBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW52YWxpZGF0aW5nIGNhY2hlIGFmdGVyIGRlbGV0ZTpcIiwgY2FjaGVFcnJvcik7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IG1heWJlIGludmFsaWRhdGUgYSBicm9hZGVyIHJhbmdlIG9yIGp1c3QgbWVtb3J5IGNhY2hlIGlmIHJhbmdlIHVua25vd25cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBkZXRlcm1pbmUgZGF0ZSByYW5nZSBmb3IgZXZlbnQgJHtldmVudElkfSwgYnJvYWQgY2FjaGUgaW52YWxpZGF0aW9uIG1pZ2h0IGJlIG5lZWRlZC5gKTtcbiAgICAgICAgICAgICAgICB0cnkgeyBhd2FpdCBpbnZhbGlkYXRlQ2FjaGUodG9rZW5zKTsgfSAvLyBDYWxsIGludmFsaWRhdGUgd2l0aG91dCBzcGVjaWZpYyByYW5nZVxuICAgICAgICAgICAgICAgIGNhdGNoIChjYWNoZUVycm9yKSB7IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbnZhbGlkYXRpbmcgY2FjaGUgYWZ0ZXIgZGVsZXRlIChmYWxsYmFjayk6XCIsIGNhY2hlRXJyb3IpOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGV2ZW50SWQ6IGV2ZW50SWQsIHN1bW1hcnk6IGV2ZW50U3VtbWFyeSB9OyAvLyBSZXR1cm4gc3VjY2VzcyBvYmplY3RcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGV2ZW50ICR7ZXZlbnRJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gRG9uJ3QgaW52YWxpZGF0ZSBjYWNoZSBvbiBlcnJvciBoZXJlLCBhcyB0aGUgc3RhdGUgaXMgdW5jZXJ0YWluXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIGRlbGV0ZSBldmVudCAke2V2ZW50SWR9OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICBldmVudElkOiBldmVudElkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUNhbGVuZGFyRXZlbnQ6IGFzeW5jIChhcmdzLCB1c2VySWQgPSAnZGVmYXVsdCcsIGFjY2Vzc1Rva2VuID0gbnVsbCkgPT4ge1xuICAgICAgICAvLyBVc2VzIGdvb2dsZS5jYWxlbmRhciBBUEkgZGlyZWN0bHkgZm9yICdnZXQnLCB0aGVuIHVwZGF0ZUdDYWxlbmRhckV2ZW50SW50ZXJuYWwsIGludmFsaWRhdGVDYWNoZVxuICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBldmVudElkOiBhcmdzLmV2ZW50SWQgfTtcbiAgICAgICBjb25zdCB0b2tlbnMgPSB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfTtcbiAgICAgICBjb25zdCB7IGV2ZW50SWQsIHVwZGF0ZXMgfSA9IGFyZ3M7XG5cbiAgICAgICBpZiAoIWV2ZW50SWQgfHwgIXVwZGF0ZXMgfHwgdHlwZW9mIHVwZGF0ZXMgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICByZXR1cm4geyBlcnJvcjogXCJFdmVudCBJRCBhbmQgYSBub24tZW1wdHkgdXBkYXRlcyBvYmplY3QgYXJlIHJlcXVpcmVkLlwiLCBzdWNjZXNzOiBmYWxzZSwgZXZlbnRJZDogZXZlbnRJZCB9O1xuICAgICAgIH1cblxuICAgICAgIC8vIFZhbGlkYXRlIHVwZGF0ZSB2YWx1ZXMgKGJhc2ljIGNoZWNrIGZvciBJU08gZGF0ZXMgaWYgcHJvdmlkZWQpXG4gICAgICAgdHJ5IHtcbiAgICAgICAgICAgaWYgKHVwZGF0ZXMuc3RhcnQgJiYgIURhdGVUaW1lLmZyb21JU08odXBkYXRlcy5zdGFydCkuaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGFydCBkYXRlIGZvcm1hdFwiKTtcbiAgICAgICAgICAgaWYgKHVwZGF0ZXMuZW5kICYmICFEYXRlVGltZS5mcm9tSVNPKHVwZGF0ZXMuZW5kKS5pc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVuZCBkYXRlIGZvcm1hdFwiKTtcbiAgICAgICAgICAgaWYgKHVwZGF0ZXMuc3RhcnQgJiYgdXBkYXRlcy5lbmQgJiYgRGF0ZVRpbWUuZnJvbUlTTyh1cGRhdGVzLnN0YXJ0KSA+PSBEYXRlVGltZS5mcm9tSVNPKHVwZGF0ZXMuZW5kKSkge1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcnQgdGltZSBtdXN0IGJlIGJlZm9yZSBlbmQgdGltZVwiKTtcbiAgICAgICAgICAgfVxuICAgICAgIH0gY2F0Y2ggKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGBJbnZhbGlkIHVwZGF0ZSBkYXRhOiAke3ZhbGlkYXRpb25FcnJvci5tZXNzYWdlfS4gVXNlIElTTyA4NjAxIGZvcm1hdC5gLCBzdWNjZXNzOiBmYWxzZSwgZXZlbnRJZDogZXZlbnRJZCB9O1xuICAgICAgIH1cblxuXG4gICAgICAgbGV0IG9yaWdpbmFsU3RhcnREYXRlLCBvcmlnaW5hbEVuZERhdGU7XG4gICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBvcmlnaW5hbCBldmVudCB0aW1lcyBmb3IgY2FjaGUgaW52YWxpZGF0aW9uXG4gICAgICAgICAgICAvLyAqKlJlcXVpcmVzIGNyZWF0ZU9BdXRoMkNsaWVudCBmdW5jdGlvbioqXG4gICAgICAgICAgIGNvbnN0IG9hdXRoMkNsaWVudCA9IGNyZWF0ZU9BdXRoMkNsaWVudCh0b2tlbnMpO1xuICAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IGdvb2dsZS5jYWxlbmRhcih7IHZlcnNpb246ICd2MycsIGF1dGg6IG9hdXRoMkNsaWVudCB9KTtcbiAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZXZlbnQgZGV0YWlscyBmb3IgdXBkYXRlOiAke2V2ZW50SWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBhd2FpdCBjYWxlbmRhci5ldmVudHMuZ2V0KHsgY2FsZW5kYXJJZDogJ3ByaW1hcnknLCBldmVudElkOiBldmVudElkIH0pO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnREYXRlID0gZXZlbnQuZGF0YS5zdGFydD8uZGF0ZVRpbWUgfHwgZXZlbnQuZGF0YS5zdGFydD8uZGF0ZTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZERhdGUgPSBldmVudC5kYXRhLmVuZD8uZGF0ZVRpbWUgfHwgZXZlbnQuZGF0YS5lbmQ/LmRhdGU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGV2ZW50IFwiJHtldmVudC5kYXRhLnN1bW1hcnl9XCIgc3RhcnRpbmcgJHtvcmlnaW5hbFN0YXJ0RGF0ZX1gKTtcbiAgICAgICAgICAgfSBjYXRjaCAoZ2V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgIGlmIChnZXRFcnJvci5jb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgRXZlbnQgJHtldmVudElkfSBub3QgZm91bmQgZm9yIHVwZGF0ZS5gLCBldmVudElkOiBldmVudElkIH07XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXRyaWV2ZSBldmVudCBkZXRhaWxzIGJlZm9yZSB1cGRhdGU6ICR7Z2V0RXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vICoqUmVxdWlyZXMgdXBkYXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCBmdW5jdGlvbioqXG4gICAgICAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHVwZGF0ZSBldmVudDogJHtldmVudElkfSB3aXRoIHVwZGF0ZXM6YCwgdXBkYXRlcyk7XG4gICAgICAgICAgIGNvbnN0IHVwZGF0ZWRFdmVudCA9IGF3YWl0IHVwZGF0ZUdDYWxlbmRhckV2ZW50SW50ZXJuYWwodG9rZW5zLCBldmVudElkLCB1cGRhdGVzKTsgLy8gQXNzdW1lIHRocm93cyBvbiBBUEkgZXJyb3JcbiAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSB1cGRhdGVkIGV2ZW50OiAke2V2ZW50SWR9YCk7XG5cbiAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZSBmb3IgYm90aCBvcmlnaW5hbCBhbmQgbmV3IHJhbmdlc1xuICAgICAgICAgICAvLyAqKlJlcXVpcmVzIGludmFsaWRhdGVDYWNoZSBmdW5jdGlvbioqXG4gICAgICAgICAgIGNvbnN0IHJhbmdlc1RvSW52YWxpZGF0ZSA9IFtdO1xuICAgICAgICAgICBpZiAob3JpZ2luYWxTdGFydERhdGUgJiYgb3JpZ2luYWxFbmREYXRlKSByYW5nZXNUb0ludmFsaWRhdGUucHVzaCh7c3RhcnQ6IG9yaWdpbmFsU3RhcnREYXRlLCBlbmQ6IG9yaWdpbmFsRW5kRGF0ZX0pO1xuICAgICAgICAgICAvLyBVc2UgdXBkYXRlZCBldmVudCBkYXRhIGZvciBuZXcgcmFuZ2VcbiAgICAgICAgICAgY29uc3QgbmV3U3RhcnREYXRlID0gdXBkYXRlZEV2ZW50LnN0YXJ0Py5kYXRlVGltZSB8fCB1cGRhdGVkRXZlbnQuc3RhcnQ/LmRhdGU7XG4gICAgICAgICAgIGNvbnN0IG5ld0VuZERhdGUgPSB1cGRhdGVkRXZlbnQuZW5kPy5kYXRlVGltZSB8fCB1cGRhdGVkRXZlbnQuZW5kPy5kYXRlO1xuICAgICAgICAgICBpZiAobmV3U3RhcnREYXRlICYmIG5ld0VuZERhdGUpIHJhbmdlc1RvSW52YWxpZGF0ZS5wdXNoKHtzdGFydDogbmV3U3RhcnREYXRlLCBlbmQ6IG5ld0VuZERhdGV9KTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlc1RvSW52YWxpZGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVJhbmdlcyA9IFsuLi5uZXcgU2V0KHJhbmdlc1RvSW52YWxpZGF0ZS5tYXAoSlNPTi5zdHJpbmdpZnkpKV0ubWFwKEpTT04ucGFyc2UpO1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkludmFsaWRhdGluZyBjYWNoZSByYW5nZXM6XCIsIHVuaXF1ZVJhbmdlcyk7XG4gICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgdW5pcXVlUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7IGF3YWl0IGludmFsaWRhdGVDYWNoZSh0b2tlbnMsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpOyB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChjYWNoZUVycm9yKSB7IGNvbnNvbGUuZXJyb3IoYEVycm9yIGludmFsaWRhdGluZyBjYWNoZSByYW5nZSAke3JhbmdlLnN0YXJ0fS0ke3JhbmdlLmVuZH06YCwgY2FjaGVFcnJvcik7IH1cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGRldGVybWluZSBkYXRlIHJhbmdlKHMpIGZvciBldmVudCAke2V2ZW50SWR9IHVwZGF0ZSwgYnJvYWQgY2FjaGUgaW52YWxpZGF0aW9uIG1pZ2h0IGJlIG5lZWRlZC5gKTtcbiAgICAgICAgICAgICAgICAgdHJ5IHsgYXdhaXQgaW52YWxpZGF0ZUNhY2hlKHRva2Vucyk7IH0gLy8gRmFsbGJhY2sgaW52YWxpZGF0ZVxuICAgICAgICAgICAgICAgICBjYXRjaCAoY2FjaGVFcnJvcikgeyBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW52YWxpZGF0aW5nIGNhY2hlIGFmdGVyIHVwZGF0ZSAoZmFsbGJhY2spOlwiLCBjYWNoZUVycm9yKTsgfVxuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHVwZGF0ZWQgZXZlbnQgb2JqZWN0LCBhZGRpbmcgYSBzdWNjZXNzIGZsYWdcbiAgICAgICAgICAgcmV0dXJuIHsgLi4udXBkYXRlZEV2ZW50LCBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgZXZlbnQgJHtldmVudElkfTpgLCBlcnJvcik7XG4gICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gdXBkYXRlIGV2ZW50ICR7ZXZlbnRJZH06ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIGV2ZW50SWQ6IGV2ZW50SWRcbiAgICAgICAgICAgfTtcbiAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRBdmFpbGFibGVTbG90czogYXN5bmMgKGFyZ3MsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsKSA9PiB7XG4gICAgICAgIC8vIFVzZXMgZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlLCBmaW5kQXZhaWxhYmxlU2xvdHNVdGlsXG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHNsb3RzOiBbXSB9O1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfTtcbiAgICAgICAgY29uc3QgeyBkdXJhdGlvbiwgc3RhcnREYXRlOiByZXFTdGFydERhdGUsIGVuZERhdGU6IHJlcUVuZERhdGUsIHRpbWVQcmVmZXJlbmNlID0gJ2FueScsIGFjdGl2aXR5ID0gJ2V2ZW50JyB9ID0gYXJncztcblxuICAgICAgICBpZiAoIWR1cmF0aW9uIHx8IHR5cGVvZiBkdXJhdGlvbiAhPT0gJ251bWJlcicgfHwgZHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiVmFsaWQgZHVyYXRpb24gKGluIG1pbnV0ZXMpIGlzIHJlcXVpcmVkLlwiLCBzbG90czogW10gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgc2VhcmNoIHJhbmdlOiBuZXh0IDcgZGF5cyBmcm9tIG5vd1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlVGltZS5ub3coKTtcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gcmVxU3RhcnREYXRlID8gRGF0ZVRpbWUuZnJvbUlTTyhyZXFTdGFydERhdGUpIDogbm93O1xuICAgICAgICBjb25zdCBlbmREYXRlID0gcmVxRW5kRGF0ZSA/IERhdGVUaW1lLmZyb21JU08ocmVxRW5kRGF0ZSkgOiBzdGFydERhdGUucGx1cyh7IGRheXM6IDcgfSk7XG5cbiAgICAgICAgaWYgKCFzdGFydERhdGUuaXNWYWxpZCB8fCAhZW5kRGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGBJbnZhbGlkIGRhdGUgZm9ybWF0LiBVc2UgSVNPIDg2MDEuIFJlY2VpdmVkIHN0YXJ0PSR7cmVxU3RhcnREYXRlfSwgZW5kPSR7cmVxRW5kRGF0ZX1gLCBzbG90czogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnREYXRlID49IGVuZERhdGUpIHtcbiAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogXCJTdGFydCBkYXRlIG11c3QgYmUgYmVmb3JlIGVuZCBkYXRlLlwiLCBzbG90czogW10gfTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZldGNoIGV2ZW50cyBmb3IgdGhlIGVudGlyZSBzZWFyY2ggcmFuZ2UgZmlyc3QgKGNhY2hlLWF3YXJlKVxuICAgICAgICAgICAgIC8vICoqUmVxdWlyZXMgZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlIGZ1bmN0aW9uKipcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5U3RhcnQgPSBzdGFydERhdGUuc3RhcnRPZignZGF5JykudG9JU09EYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleUVuZCA9IGVuZERhdGUuZW5kT2YoJ2RheScpLnRvSVNPRGF0ZSgpOyAvLyBDYWNoZSBkYWlseSBncmFudWxhcml0eVxuICAgICAgICAgICAgY29uc3QgdG9rZW5IYXNoID0gYWNjZXNzVG9rZW4uc3Vic3RyaW5nKGFjY2Vzc1Rva2VuLmxlbmd0aCAtIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZENhY2hlUHJlZml4ID0gYHVzZXJfJHt0b2tlbkhhc2h9YDtcblxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWRDYWNoZVByZWZpeCwgY2FjaGVLZXlTdGFydCwgY2FjaGVLZXlFbmQpO1xuICAgICAgICAgICAgaWYgKCFldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENhY2hlIE1JU1MgZm9yIHNsb3Qgc2VhcmNoIGV2ZW50cyAke2NhY2hlS2V5U3RhcnR9IHRvICR7Y2FjaGVLZXlFbmR9YCk7XG4gICAgICAgICAgICAgICAgIC8vICoqUmVxdWlyZXMgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCBmdW5jdGlvbioqXG4gICAgICAgICAgICAgICAgIGNvbnN0IGFwaUV2ZW50cyA9IGF3YWl0IGZldGNoR0NhbGVuZGFyRXZlbnRzSW50ZXJuYWwodG9rZW5zLCBzdGFydERhdGUuc3RhcnRPZignZGF5JykudG9KU0RhdGUoKSwgZW5kRGF0ZS5lbmRPZignZGF5JykudG9KU0RhdGUoKSk7XG4gICAgICAgICAgICAgICAgIGlmIChhcGlFdmVudHMgJiYgQXJyYXkuaXNBcnJheShhcGlFdmVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGFwaUV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UodXNlcklkQ2FjaGVQcmVmaXgsIGNhY2hlS2V5U3RhcnQsIGNhY2hlS2V5RW5kLCBldmVudHMsIDMwMCk7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IFtdOyAvLyBBc3N1bWUgbm8gZXZlbnRzIGlmIGZldGNoIGZhaWxzXG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENhY2hlIEhJVCBmb3Igc2xvdCBzZWFyY2ggZXZlbnRzICR7Y2FjaGVLZXlTdGFydH0gdG8gJHtjYWNoZUtleUVuZH1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsdGVyIGV2ZW50cyB0byB0aGUgcHJlY2lzZSByZXF1ZXN0ZWQgdGltZSB3aW5kb3cgKmJlZm9yZSogZmluZGluZyBzbG90c1xuICAgICAgICAgICAgIGNvbnN0IHJlbGV2YW50RXZlbnRzID0gZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50LnN0YXJ0Py5kYXRlVGltZSB8fCBldmVudC5zdGFydD8uZGF0ZSk7XG4gICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50RW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5lbmQ/LmRhdGVUaW1lIHx8IGV2ZW50LmVuZD8uZGF0ZSk7XG4gICAgICAgICAgICAgICAgIHJldHVybiBldmVudFN0YXJ0LmlzVmFsaWQgJiYgZXZlbnRFbmQuaXNWYWxpZCAmJiBldmVudFN0YXJ0IDwgZW5kRGF0ZSAmJiBldmVudEVuZCA+IHN0YXJ0RGF0ZTtcbiAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGltcG9ydGVkIGZpbmRBdmFpbGFibGVTbG90cyBmdW5jdGlvblxuICAgICAgICAgICAgY29uc3Qgc2xvdHMgPSBhd2FpdCBmaW5kQXZhaWxhYmxlU2xvdHMoXG4gICAgICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMsIC8vIFVzZSBwcmVjaXNlbHkgZmlsdGVyZWQgZXZlbnRzXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLnRvSVNPKCksIC8vIFBhc3MgcHJlY2lzZSBJU08gc3RyaW5ncyB0byB1dGlsXG4gICAgICAgICAgICAgICAgZW5kRGF0ZS50b0lTTygpLFxuICAgICAgICAgICAgICAgIGFjdGl2aXR5LFxuICAgICAgICAgICAgICAgIHRpbWVQcmVmZXJlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHNsb3RzOyAvLyBSZXR1cm4gcmF3IHNsb3RzIGFycmF5IChmb3JtYXRUb29sUmVzcG9uc2UgaGFuZGxlcyBwcmVzZW50YXRpb24pXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBmaW5kQXZhaWxhYmxlU2xvdHMgdG9vbCAoJHtkdXJhdGlvbn1taW4sICR7c3RhcnREYXRlLnRvSVNPKCl9IHRvICR7ZW5kRGF0ZS50b0lTTygpfSk6YCwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGVycm9yIG9iamVjdCBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogYEZhaWxlZCB0byBmaW5kIGF2YWlsYWJsZSBzbG90czogJHtlcnJvci5tZXNzYWdlfWAsIHNsb3RzOiBbXSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFdlYXRoZXJGb3JlY2FzdDogYXN5bmMgKGFyZ3MsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsKSA9PiB7XG4gICAgICAgIC8vIFBsYWNlaG9sZGVyIC0gcmVxdWlyZXMgYWN0dWFsIHdlYXRoZXIgQVBJIGludGVncmF0aW9uXG4gICAgICAgIGNvbnN0IHsgbG9jYXRpb24sIGRhdGU6IGRhdGVTdHJpbmcgfSA9IGFyZ3M7XG4gICAgICAgIGlmICghbG9jYXRpb24pIHJldHVybiB7IGVycm9yOiBcIkxvY2F0aW9uIGlzIHJlcXVpcmVkIGZvciB3ZWF0aGVyIGZvcmVjYXN0LlwiLCBzdWNjZXNzOiBmYWxzZSB9O1xuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gdG9kYXkgaWYgZGF0ZSBpcyBtaXNzaW5nIG9yIGludmFsaWRcbiAgICAgICAgbGV0IGZvcmVjYXN0RGF0ZSA9IGRhdGVTdHJpbmcgPyBEYXRlVGltZS5mcm9tSVNPKGRhdGVTdHJpbmcpIDogRGF0ZVRpbWUubm93KCk7XG4gICAgICAgIGlmICghZm9yZWNhc3REYXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBkYXRlIHByb3ZpZGVkIGZvciB3ZWF0aGVyIGZvcmVjYXN0OiAke2RhdGVTdHJpbmd9LiBEZWZhdWx0aW5nIHRvIHRvZGF5LmApO1xuICAgICAgICAgICAgZm9yZWNhc3REYXRlID0gRGF0ZVRpbWUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGZvcmVjYXN0RGF0ZS50b0lTT0RhdGUoKTsgLy8gWVlZWS1NTS1ERFxuXG4gICAgICAgIGNvbnNvbGUubG9nKGBQbGFjZWhvbGRlcjogRmV0Y2hpbmcgd2VhdGhlciBmb3IgJHtsb2NhdGlvbn0gb24gJHtmb3JtYXR0ZWREYXRlfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gLS0tIFJlcGxhY2Ugd2l0aCBhY3R1YWwgd2VhdGhlciBBUEkgY2FsbCAtLS1cbiAgICAgICAgICAgIC8vIEV4YW1wbGU6IGNvbnN0IHdlYXRoZXJEYXRhID0gYXdhaXQgZ2V0V2VhdGhlckRhdGEobG9jYXRpb24sIGZvcm1hdHRlZERhdGUpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHsgLi4ud2VhdGhlckRhdGEsIHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgICAgIC8vIC0tLSBQbGFjZWhvbGRlciByZXNwb25zZSAtLS1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGRhdGU6IGZvcm1hdHRlZERhdGUsXG4gICAgICAgICAgICAgICAgZm9yZWNhc3Q6IGBXZWF0aGVyIGRhdGEgZm9yICR7bG9jYXRpb259IG9uICR7Zm9ybWF0dGVkRGF0ZX0gaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLmAsIC8vIFBsYWNlaG9sZGVyIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSAvLyBJbmRpY2F0ZSBkYXRhIGlzIG5vdCBhY3R1YWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB3ZWF0aGVyIGZvciAke2xvY2F0aW9ufSwgJHtmb3JtYXR0ZWREYXRlfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICBkYXRlOiBmb3JtYXR0ZWREYXRlLFxuICAgICAgICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBnZXQgd2VhdGhlciBmb3JlY2FzdDogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWxldGVDYWxlbmRhckV2ZW50c0J5UXVlcnk6IGFzeW5jIChhcmdzLCB1c2VySWQgPSAnZGVmYXVsdCcsIGFjY2Vzc1Rva2VuID0gbnVsbCkgPT4ge1xuICAgICAgICAvLyBVc2VzIGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSwgZGVsZXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCwgaW52YWxpZGF0ZUNhY2hlXG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBkZWxldGVkQ291bnQ6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfTtcbiAgICAgICAgY29uc3QgeyBxdWVyeSwgc3RhcnRfZGF0ZSwgZW5kX2RhdGUgfSA9IGFyZ3M7XG5cbiAgICAgICAgaWYgKCFxdWVyeSB8fCAhc3RhcnRfZGF0ZSB8fCAhZW5kX2RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBcIlF1ZXJ5LCBzdGFydCBkYXRlLCBhbmQgZW5kIGRhdGUgYXJlIHJlcXVpcmVkLlwiLCBzdWNjZXNzOiBmYWxzZSwgZGVsZXRlZENvdW50OiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydER0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzdGFydF9kYXRlKTtcbiAgICAgICAgY29uc3QgZW5kRHQgPSBEYXRlVGltZS5mcm9tSVNPKGVuZF9kYXRlKTtcbiAgICAgICAgIGlmICghc3RhcnREdC5pc1ZhbGlkIHx8ICFlbmREdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGBJbnZhbGlkIGRhdGUgZm9ybWF0LiBVc2UgSVNPIDg2MDEuYCwgc3VjY2VzczogZmFsc2UsIGRlbGV0ZWRDb3VudDogMCB9O1xuICAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnREdCA+PSBlbmREdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiU3RhcnQgZGF0ZSBtdXN0IGJlIGJlZm9yZSBlbmQgZGF0ZS5cIiwgc3VjY2VzczogZmFsc2UsIGRlbGV0ZWRDb3VudDogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gZGVsZXRlIGV2ZW50cyBtYXRjaGluZyBcIiR7cXVlcnl9XCIgYmV0d2VlbiAke3N0YXJ0RHQudG9JU08oKX0gYW5kICR7ZW5kRHQudG9JU08oKX1gKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gMS4gR2V0IGFsbCBldmVudHMgaW4gdGhlIHJhbmdlICh1c2UgY2FjaGUpXG4gICAgICAgICAgICAvLyAqKlJlcXVpcmVzIGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSBmdW5jdGlvbioqXG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleVN0YXJ0ID0gc3RhcnREdC5zdGFydE9mKCdkYXknKS50b0lTT0RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5RW5kID0gZW5kRHQuZW5kT2YoJ2RheScpLnRvSVNPRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5IYXNoID0gYWNjZXNzVG9rZW4uc3Vic3RyaW5nKGFjY2Vzc1Rva2VuLmxlbmd0aCAtIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZENhY2hlUHJlZml4ID0gYHVzZXJfJHt0b2tlbkhhc2h9YDtcblxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWRDYWNoZVByZWZpeCwgY2FjaGVLZXlTdGFydCwgY2FjaGVLZXlFbmQpO1xuICAgICAgICAgICAgIGlmICghZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBNSVNTIGZvciBidWxrIGRlbGV0ZSBzZWFyY2ggJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgICAgICAgLy8gKipSZXF1aXJlcyBmZXRjaEdDYWxlbmRhckV2ZW50c0ludGVybmFsIGZ1bmN0aW9uKipcbiAgICAgICAgICAgICAgICAgY29uc3QgYXBpRXZlbnRzID0gYXdhaXQgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCh0b2tlbnMsIHN0YXJ0RHQuc3RhcnRPZignZGF5JykudG9KU0RhdGUoKSwgZW5kRHQuZW5kT2YoJ2RheScpLnRvSlNEYXRlKCkpO1xuICAgICAgICAgICAgICAgICBldmVudHMgPSAoQXJyYXkuaXNBcnJheShhcGlFdmVudHMpKSA/IGFwaUV2ZW50cyA6IFtdO1xuICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNhY2hlIGhlcmUgYXMgd2UgYXJlIGFib3V0IHRvIGRlbGV0ZSBwb3RlbnRpYWxseSBtYW55IGV2ZW50c1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FjaGUgSElUIGZvciBidWxrIGRlbGV0ZSBzZWFyY2ggJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIC8vIEZpbHRlciBldmVudHMgcHJlY2lzZWx5IGJ5IHJlcXVlc3RlZCB0aW1lICphbmQqIHF1ZXJ5XG4gICAgICAgICAgICBjb25zdCBxdWVyeUxvd2VyID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRXZlbnRzID0gZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRTdGFydCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEVuZCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kPy5kYXRlVGltZSB8fCBldmVudC5lbmQ/LmRhdGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1bW1hcnlMb3dlciA9IGV2ZW50LnN1bW1hcnk/LnRvTG93ZXJDYXNlKCkgfHwgJyc7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydC5pc1ZhbGlkICYmIGV2ZW50RW5kLmlzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdGFydCA8IGVuZER0ICYmIGV2ZW50RW5kID4gc3RhcnREdCAmJiAvLyBDaGVjayB0aW1lIG92ZXJsYXBcbiAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeUxvd2VyLmluY2x1ZGVzKHF1ZXJ5TG93ZXIpOyAvLyBDaGVjayBzdW1tYXJ5IG1hdGNoXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE5vIGV2ZW50cyBtYXRjaGluZyBcIiR7cXVlcnl9XCIgZm91bmQgaW4gdGhlIHNwZWNpZmllZCByYW5nZS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBgTm8gZXZlbnRzIG1hdGNoaW5nIFwiJHtxdWVyeX1cIiBmb3VuZC5gLCBkZWxldGVkQ291bnQ6IDAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7bWF0Y2hpbmdFdmVudHMubGVuZ3RofSBldmVudHMgbWF0Y2hpbmcgcXVlcnkuIFByb2NlZWRpbmcgd2l0aCBkZWxldGlvbi4uLmApO1xuXG4gICAgICAgICAgICAvLyAyLiBEZWxldGUgZWFjaCBtYXRjaGluZyBldmVudFxuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZmFpbGVkRGVsZXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBtYXRjaGluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICoqUmVxdWlyZXMgZGVsZXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCBmdW5jdGlvbioqXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlbGV0ZUdDYWxlbmRhckV2ZW50SW50ZXJuYWwodG9rZW5zLCBldmVudC5pZCk7IC8vIEFzc3VtZSByZXR1cm5zIG1pbmltYWwgaW5mbyBvciB0aHJvd3NcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVzdWx0cy5wdXNoKHsgaWQ6IGV2ZW50LmlkLCBzdW1tYXJ5OiBldmVudC5zdW1tYXJ5IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyAqKlJlcXVpcmVzIGludmFsaWRhdGVDYWNoZSBmdW5jdGlvbioqIC0gSW52YWxpZGF0ZSBpbW1lZGlhdGVseSBhZnRlciBzdWNjZXNzZnVsIGRlbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudFN0YXJ0SXNvID0gZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50RW5kSXNvID0gZXZlbnQuZW5kPy5kYXRlVGltZSB8fCBldmVudC5lbmQ/LmRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50U3RhcnRJc28gJiYgZXZlbnRFbmRJc28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBpbnZhbGlkYXRlQ2FjaGUodG9rZW5zLCBldmVudFN0YXJ0SXNvLCBldmVudEVuZElzbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBpbnZhbGlkYXRlQ2FjaGUodG9rZW5zKTsgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGNhY2hlRXJyb3IpIHsgY29uc29sZS5lcnJvcihgQ2FjaGUgaW52YWxpZGF0aW9uIGVycm9yIGR1cmluZyBidWxrIGRlbGV0ZSBmb3IgJHtldmVudC5pZH06YCwgY2FjaGVFcnJvcik7IH1cblxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGRlbGV0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBkZWxldGUgZXZlbnQgJHtldmVudC5pZH0gKFwiJHtldmVudC5zdW1tYXJ5fVwiKSBkdXJpbmcgYnVsayBvcGVyYXRpb246YCwgZGVsZXRlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWREZWxldGVzLnB1c2goeyBpZDogZXZlbnQuaWQsIHN1bW1hcnk6IGV2ZW50LnN1bW1hcnksIGVycm9yOiBkZWxldGVFcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMy4gQ29tcGlsZSBhbmQgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NDb3VudCA9IGRlbGV0ZVJlc3VsdHMubGVuZ3RoO1xuICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7c3VjY2Vzc0NvdW50fSBldmVudChzKSBtYXRjaGluZyBcIiR7cXVlcnl9XCIuYDtcbiAgICAgICAgICAgICBpZiAoZmFpbGVkRGVsZXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCBGYWlsZWQgdG8gZGVsZXRlICR7ZmFpbGVkRGVsZXRlcy5sZW5ndGh9IGV2ZW50KHMpLmA7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWx1cmVzIGR1cmluZyBidWxrIGRlbGV0ZTpcIiwgZmFpbGVkRGVsZXRlcyk7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhaWxlZERlbGV0ZXMubGVuZ3RoID09PSAwLCAvLyBPdmVyYWxsIHN1Y2Nlc3MgaWYgbm8gZmFpbHVyZXNcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudDogc3VjY2Vzc0NvdW50LFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtczogZGVsZXRlUmVzdWx0cywgLy8gTGlzdCBzdWNjZXNzZnVsIG9uZXNcbiAgICAgICAgICAgICAgICBmYWlsZWRJdGVtczogZmFpbGVkRGVsZXRlcyAgIC8vIExpc3QgZmFpbHVyZXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyBkZWxldGVDYWxlbmRhckV2ZW50c0J5UXVlcnkgKCR7cXVlcnl9LCAke3N0YXJ0X2RhdGV9LSR7ZW5kX2RhdGV9KTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgIGVycm9yOiBgQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBidWxrIGRlbGV0ZSBvcGVyYXRpb246ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICBkZWxldGVkQ291bnQ6IDBcbiAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4gIFxuICBcbiAgXG5cbi8vIC0tLSBFeHBvcnRzIC0tLVxuLy8gRXhwb3J0IHRoZSBzY2hlbWEgYW5kIHRoZSBpbXBsZW1lbnRhdGlvbiBtYXBcbmV4cG9ydCB7IHRvb2xzLCB0b29sRnVuY3Rpb25zIH07XG5cblxuLy8gcHJvY2Vzc1Rvb2xDYWxscyBpcyBub3QgdHlwaWNhbGx5IGV4cG9ydGVkIGZyb20gaGVyZSwgYnV0IGtlcHQgZm9yIHJlZmVyZW5jZVxuLy8gZXhwb3J0IHsgcHJvY2Vzc1Rvb2xDYWxscyB9O1xuIl0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiZ29vZ2xlIiwiY3JlYXRlT0F1dGgyQ2xpZW50IiwiZ2V0Q2FsZW5kYXJFdmVudHMiLCJmZXRjaEdDYWxlbmRhckV2ZW50c0ludGVybmFsIiwiYWRkQ2FsZW5kYXJFdmVudCIsImFkZEdDYWxlbmRhckV2ZW50SW50ZXJuYWwiLCJkZWxldGVDYWxlbmRhckV2ZW50IiwiZGVsZXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCIsInVwZGF0ZUNhbGVuZGFyRXZlbnQiLCJ1cGRhdGVHQ2FsZW5kYXJFdmVudEludGVybmFsIiwiZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlIiwiY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UiLCJpbnZhbGlkYXRlRGF0ZVJhbmdlQ2FjaGUiLCJnZXRDYWNoZWRFdmVudHMiLCJpbnZhbGlkYXRlQ2FjaGUiLCJmaW5kQXZhaWxhYmxlU2xvdHMiLCJjaGVja0ZvckNvbmZsaWN0cyIsImZvcm1hdEV2ZW50VGltZSIsImZvcm1hdENhbGVuZGFyRXZlbnRzIiwiZm9ybWF0VG9vbFJlc3BvbnNlIiwiVXNlclByZWZlcmVuY2UiLCJhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24iLCJ0b29scyIsInR5cGUiLCJmdW5jdGlvbiIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInBhcmFtZXRlcnMiLCJwcm9wZXJ0aWVzIiwiY2F0ZWdvcnkiLCJrZXkiLCJ2YWx1ZSIsIm9uZU9mIiwiaXRlbXMiLCJjb250ZXh0IiwicmVxdWlyZWQiLCJldmVudHMiLCJzdW1tYXJ5Iiwic3RhcnQiLCJlbmQiLCJsb2NhdGlvbiIsInJlbWluZGVycyIsInN0YXJ0X2RhdGUiLCJlbmRfZGF0ZSIsImV2ZW50SWQiLCJ1cGRhdGVzIiwibWluUHJvcGVydGllcyIsImR1cmF0aW9uIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInRpbWVQcmVmZXJlbmNlIiwiZW51bSIsImFjdGl2aXR5IiwiZGF0ZSIsInF1ZXJ5IiwidG9vbEZ1bmN0aW9ucyIsInNhdmVVc2VyUHJlZmVyZW5jZSIsImFyZ3MiLCJ1c2VySWQiLCJhY2Nlc3NUb2tlbiIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidXNlclByZWYiLCJmaW5kT25lIiwid2hlcmUiLCJ1c2VyX2lkIiwiY3JlYXRlIiwicHJlZmVyZW5jZXNfZGF0YSIsInVuZGVmaW5lZCIsInByZWZzRGF0YSIsImNvbnRleHRLZXkiLCJ1cGRhdGUiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiYWRkQ2FsZW5kYXJFdmVudHMiLCJ0b2tlbnMiLCJhY2Nlc3NfdG9rZW4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJyZXN1bHRzIiwiYWZmZWN0ZWREYXRlUmFuZ2VzIiwiZXZlbnQiLCJwdXNoIiwic3RhcnREdCIsImZyb21JU08iLCJlbmREdCIsImlzVmFsaWQiLCJFcnJvciIsImUiLCJjb25mbGljdENoZWNrUmVzdWx0IiwiY29uZmxpY3RzIiwid2FybiIsImNvbmZsaWN0Iiwic3VnZ2VzdGlvbnMiLCJhZGRlZEV2ZW50IiwiYWRkRXJyb3IiLCJyYW5nZSIsImNhY2hlRXJyb3IiLCJjYWNoZUtleVN0YXJ0IiwidG9JU09EYXRlIiwiY2FjaGVLZXlFbmQiLCJ0b2tlbkhhc2giLCJzdWJzdHJpbmciLCJ1c2VySWRDYWNoZVByZWZpeCIsImZpbHRlciIsImV2ZW50U3RhcnQiLCJkYXRlVGltZSIsImV2ZW50RW5kIiwiYXBpRXZlbnRzIiwidG9KU0RhdGUiLCJ0b0lTTyIsIm9yaWdpbmFsU3RhcnREYXRlIiwib3JpZ2luYWxFbmREYXRlIiwiZXZlbnRTdW1tYXJ5Iiwib2F1dGgyQ2xpZW50IiwiY2FsZW5kYXIiLCJ2ZXJzaW9uIiwiYXV0aCIsImdldCIsImNhbGVuZGFySWQiLCJkYXRhIiwiZ2V0RXJyb3IiLCJjb2RlIiwiT2JqZWN0Iiwia2V5cyIsInZhbGlkYXRpb25FcnJvciIsInVwZGF0ZWRFdmVudCIsInJhbmdlc1RvSW52YWxpZGF0ZSIsIm5ld1N0YXJ0RGF0ZSIsIm5ld0VuZERhdGUiLCJ1bmlxdWVSYW5nZXMiLCJTZXQiLCJtYXAiLCJwYXJzZSIsInNsb3RzIiwicmVxU3RhcnREYXRlIiwicmVxRW5kRGF0ZSIsIm5vdyIsInBsdXMiLCJkYXlzIiwic3RhcnRPZiIsImVuZE9mIiwicmVsZXZhbnRFdmVudHMiLCJnZXRXZWF0aGVyRm9yZWNhc3QiLCJkYXRlU3RyaW5nIiwiZm9yZWNhc3REYXRlIiwiZm9ybWF0dGVkRGF0ZSIsImZvcmVjYXN0IiwiZGVsZXRlQ2FsZW5kYXJFdmVudHNCeVF1ZXJ5IiwiZGVsZXRlZENvdW50IiwicXVlcnlMb3dlciIsInRvTG93ZXJDYXNlIiwibWF0Y2hpbmdFdmVudHMiLCJzdW1tYXJ5TG93ZXIiLCJpbmNsdWRlcyIsImRlbGV0ZVJlc3VsdHMiLCJmYWlsZWREZWxldGVzIiwicmVzdWx0IiwiaWQiLCJldmVudFN0YXJ0SXNvIiwiZXZlbnRFbmRJc28iLCJkZWxldGVFcnJvciIsInN1Y2Nlc3NDb3VudCIsImRlbGV0ZWRJdGVtcyIsImZhaWxlZEl0ZW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/tools/toolIndex.js\n");

/***/ }),

/***/ "(api)/./pages/api/auth/[...nextauth].js":
/*!*****************************************!*\
  !*** ./pages/api/auth/[...nextauth].js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authOptions: () => (/* binding */ authOptions),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-auth */ \"next-auth\");\n/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_auth__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/providers/google */ \"next-auth/providers/google\");\n/* harmony import */ var next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst authOptions = {\n    providers: [\n        next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1___default()({\n            clientId: process.env.GOOGLE_CLIENT_ID,\n            clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n            authorization: {\n                params: {\n                    scope: \"https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/calendar\",\n                    access_type: \"offline\",\n                    prompt: \"consent\"\n                }\n            }\n        })\n    ],\n    callbacks: {\n        async jwt ({ token, account, user }) {\n            // Initial sign in\n            if (account && user) {\n                return {\n                    accessToken: account.access_token,\n                    refreshToken: account.refresh_token,\n                    accessTokenExpires: account.expires_at * 1000,\n                    user\n                };\n            }\n            // Return previous token if the access token has not expired yet\n            if (Date.now() < token.accessTokenExpires) {\n                return token;\n            }\n            // Access token has expired, try to refresh it\n            try {\n                const response = await fetch(\"https://oauth2.googleapis.com/token\", {\n                    headers: {\n                        \"Content-Type\": \"application/x-www-form-urlencoded\"\n                    },\n                    body: new URLSearchParams({\n                        client_id: process.env.GOOGLE_CLIENT_ID,\n                        client_secret: process.env.GOOGLE_CLIENT_SECRET,\n                        grant_type: \"refresh_token\",\n                        refresh_token: token.refreshToken\n                    }),\n                    method: \"POST\"\n                });\n                const refreshedTokens = await response.json();\n                if (!response.ok) {\n                    throw refreshedTokens;\n                }\n                return {\n                    ...token,\n                    accessToken: refreshedTokens.access_token,\n                    accessTokenExpires: Date.now() + refreshedTokens.expires_in * 1000,\n                    // Fall back to old refresh token, but note that\n                    // many providers may only allow using a refresh token once\n                    refreshToken: refreshedTokens.refresh_token ?? token.refreshToken\n                };\n            } catch (error) {\n                console.error(\"Error refreshing access token\", error);\n                // The error property will be used client-side to handle the refresh token error\n                return {\n                    ...token,\n                    error: \"RefreshAccessTokenError\"\n                };\n            }\n        },\n        async session ({ session, token }) {\n            session.user = token.user;\n            session.accessToken = token.accessToken;\n            session.error = token.error;\n            return session;\n        }\n    },\n    // Enable debug messages in the console if you are having problems\n    debug: \"development\" === \"development\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (next_auth__WEBPACK_IMPORTED_MODULE_0___default()(authOptions));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvYXV0aC9bLi4ubmV4dGF1dGhdLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpQztBQUN1QjtBQUVqRCxNQUFNRSxjQUFjO0lBQ3pCQyxXQUFXO1FBQ1RGLGlFQUFjQSxDQUFDO1lBQ2JHLFVBQVVDLFFBQVFDLEdBQUcsQ0FBQ0MsZ0JBQWdCO1lBQ3RDQyxjQUFjSCxRQUFRQyxHQUFHLENBQUNHLG9CQUFvQjtZQUM5Q0MsZUFBZTtnQkFDYkMsUUFBUTtvQkFDTkMsT0FBTztvQkFDUEMsYUFBYTtvQkFDYkMsUUFBUTtnQkFDVjtZQUNGO1FBQ0Y7S0FDRDtJQUNEQyxXQUFXO1FBQ1QsTUFBTUMsS0FBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFO1lBQ2hDLGtCQUFrQjtZQUNsQixJQUFJRCxXQUFXQyxNQUFNO2dCQUNuQixPQUFPO29CQUNMQyxhQUFhRixRQUFRRyxZQUFZO29CQUNqQ0MsY0FBY0osUUFBUUssYUFBYTtvQkFDbkNDLG9CQUFvQk4sUUFBUU8sVUFBVSxHQUFHO29CQUN6Q047Z0JBQ0Y7WUFDRjtZQUVBLGdFQUFnRTtZQUNoRSxJQUFJTyxLQUFLQyxHQUFHLEtBQUtWLE1BQU1PLGtCQUFrQixFQUFFO2dCQUN6QyxPQUFPUDtZQUNUO1lBRUEsOENBQThDO1lBQzlDLElBQUk7Z0JBQ0YsTUFBTVcsV0FBVyxNQUFNQyxNQUFNLHVDQUF1QztvQkFDbEVDLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFvQztvQkFDL0RDLE1BQU0sSUFBSUMsZ0JBQWdCO3dCQUN4QkMsV0FBVzVCLFFBQVFDLEdBQUcsQ0FBQ0MsZ0JBQWdCO3dCQUN2QzJCLGVBQWU3QixRQUFRQyxHQUFHLENBQUNHLG9CQUFvQjt3QkFDL0MwQixZQUFZO3dCQUNaWixlQUFlTixNQUFNSyxZQUFZO29CQUNuQztvQkFDQWMsUUFBUTtnQkFDVjtnQkFFQSxNQUFNQyxrQkFBa0IsTUFBTVQsU0FBU1UsSUFBSTtnQkFFM0MsSUFBSSxDQUFDVixTQUFTVyxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1GO2dCQUNSO2dCQUVBLE9BQU87b0JBQ0wsR0FBR3BCLEtBQUs7b0JBQ1JHLGFBQWFpQixnQkFBZ0JoQixZQUFZO29CQUN6Q0csb0JBQW9CRSxLQUFLQyxHQUFHLEtBQUtVLGdCQUFnQkcsVUFBVSxHQUFHO29CQUM5RCxnREFBZ0Q7b0JBQ2hELDJEQUEyRDtvQkFDM0RsQixjQUFjZSxnQkFBZ0JkLGFBQWEsSUFBSU4sTUFBTUssWUFBWTtnQkFDbkU7WUFDRixFQUFFLE9BQU9tQixPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtnQkFDL0MsZ0ZBQWdGO2dCQUNoRixPQUFPO29CQUFFLEdBQUd4QixLQUFLO29CQUFFd0IsT0FBTztnQkFBMEI7WUFDdEQ7UUFDRjtRQUNBLE1BQU1FLFNBQVEsRUFBRUEsT0FBTyxFQUFFMUIsS0FBSyxFQUFFO1lBQzlCMEIsUUFBUXhCLElBQUksR0FBR0YsTUFBTUUsSUFBSTtZQUN6QndCLFFBQVF2QixXQUFXLEdBQUdILE1BQU1HLFdBQVc7WUFDdkN1QixRQUFRRixLQUFLLEdBQUd4QixNQUFNd0IsS0FBSztZQUMzQixPQUFPRTtRQUNUO0lBQ0Y7SUFDQSxrRUFBa0U7SUFDbEVDLE9BQU92QyxrQkFBeUI7QUFDbEMsRUFBRTtBQUVGLGlFQUFlTCxnREFBUUEsQ0FBQ0UsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL3BhZ2VzL2FwaS9hdXRoL1suLi5uZXh0YXV0aF0uanM/NTI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTmV4dEF1dGggZnJvbSAnbmV4dC1hdXRoJztcbmltcG9ydCBHb29nbGVQcm92aWRlciBmcm9tICduZXh0LWF1dGgvcHJvdmlkZXJzL2dvb2dsZSc7XG5cbmV4cG9ydCBjb25zdCBhdXRoT3B0aW9ucyA9IHtcbiAgcHJvdmlkZXJzOiBbXG4gICAgR29vZ2xlUHJvdmlkZXIoe1xuICAgICAgY2xpZW50SWQ6IHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfSUQsXG4gICAgICBjbGllbnRTZWNyZXQ6IHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfU0VDUkVULFxuICAgICAgYXV0aG9yaXphdGlvbjoge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBzY29wZTogJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvdXNlcmluZm8ucHJvZmlsZSBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3VzZXJpbmZvLmVtYWlsIGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2FsZW5kYXInLFxuICAgICAgICAgIGFjY2Vzc190eXBlOiAnb2ZmbGluZScsXG4gICAgICAgICAgcHJvbXB0OiAnY29uc2VudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICBdLFxuICBjYWxsYmFja3M6IHtcbiAgICBhc3luYyBqd3QoeyB0b2tlbiwgYWNjb3VudCwgdXNlciB9KSB7XG4gICAgICAvLyBJbml0aWFsIHNpZ24gaW5cbiAgICAgIGlmIChhY2NvdW50ICYmIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY2Nlc3NUb2tlbjogYWNjb3VudC5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgcmVmcmVzaFRva2VuOiBhY2NvdW50LnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgYWNjZXNzVG9rZW5FeHBpcmVzOiBhY2NvdW50LmV4cGlyZXNfYXQgKiAxMDAwLCAvLyBDb252ZXJ0IHRvIG1pbGxpc2Vjb25kc1xuICAgICAgICAgIHVzZXJcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHByZXZpb3VzIHRva2VuIGlmIHRoZSBhY2Nlc3MgdG9rZW4gaGFzIG5vdCBleHBpcmVkIHlldFxuICAgICAgaWYgKERhdGUubm93KCkgPCB0b2tlbi5hY2Nlc3NUb2tlbkV4cGlyZXMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuXG4gICAgICAvLyBBY2Nlc3MgdG9rZW4gaGFzIGV4cGlyZWQsIHRyeSB0byByZWZyZXNoIGl0XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbicsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxuICAgICAgICAgIGJvZHk6IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgY2xpZW50X2lkOiBwcm9jZXNzLmVudi5HT09HTEVfQ0xJRU5UX0lELFxuICAgICAgICAgICAgY2xpZW50X3NlY3JldDogcHJvY2Vzcy5lbnYuR09PR0xFX0NMSUVOVF9TRUNSRVQsXG4gICAgICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiB0b2tlbi5yZWZyZXNoVG9rZW4sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlZnJlc2hlZFRva2VucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgcmVmcmVzaGVkVG9rZW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICBhY2Nlc3NUb2tlbjogcmVmcmVzaGVkVG9rZW5zLmFjY2Vzc190b2tlbixcbiAgICAgICAgICBhY2Nlc3NUb2tlbkV4cGlyZXM6IERhdGUubm93KCkgKyByZWZyZXNoZWRUb2tlbnMuZXhwaXJlc19pbiAqIDEwMDAsXG4gICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG9sZCByZWZyZXNoIHRva2VuLCBidXQgbm90ZSB0aGF0XG4gICAgICAgICAgLy8gbWFueSBwcm92aWRlcnMgbWF5IG9ubHkgYWxsb3cgdXNpbmcgYSByZWZyZXNoIHRva2VuIG9uY2VcbiAgICAgICAgICByZWZyZXNoVG9rZW46IHJlZnJlc2hlZFRva2Vucy5yZWZyZXNoX3Rva2VuID8/IHRva2VuLnJlZnJlc2hUb2tlbixcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZnJlc2hpbmcgYWNjZXNzIHRva2VuJywgZXJyb3IpO1xuICAgICAgICAvLyBUaGUgZXJyb3IgcHJvcGVydHkgd2lsbCBiZSB1c2VkIGNsaWVudC1zaWRlIHRvIGhhbmRsZSB0aGUgcmVmcmVzaCB0b2tlbiBlcnJvclxuICAgICAgICByZXR1cm4geyAuLi50b2tlbiwgZXJyb3I6ICdSZWZyZXNoQWNjZXNzVG9rZW5FcnJvcicgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHNlc3Npb24oeyBzZXNzaW9uLCB0b2tlbiB9KSB7XG4gICAgICBzZXNzaW9uLnVzZXIgPSB0b2tlbi51c2VyO1xuICAgICAgc2Vzc2lvbi5hY2Nlc3NUb2tlbiA9IHRva2VuLmFjY2Vzc1Rva2VuO1xuICAgICAgc2Vzc2lvbi5lcnJvciA9IHRva2VuLmVycm9yO1xuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICB9LFxuICAvLyBFbmFibGUgZGVidWcgbWVzc2FnZXMgaW4gdGhlIGNvbnNvbGUgaWYgeW91IGFyZSBoYXZpbmcgcHJvYmxlbXNcbiAgZGVidWc6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTmV4dEF1dGgoYXV0aE9wdGlvbnMpOyJdLCJuYW1lcyI6WyJOZXh0QXV0aCIsIkdvb2dsZVByb3ZpZGVyIiwiYXV0aE9wdGlvbnMiLCJwcm92aWRlcnMiLCJjbGllbnRJZCIsInByb2Nlc3MiLCJlbnYiLCJHT09HTEVfQ0xJRU5UX0lEIiwiY2xpZW50U2VjcmV0IiwiR09PR0xFX0NMSUVOVF9TRUNSRVQiLCJhdXRob3JpemF0aW9uIiwicGFyYW1zIiwic2NvcGUiLCJhY2Nlc3NfdHlwZSIsInByb21wdCIsImNhbGxiYWNrcyIsImp3dCIsInRva2VuIiwiYWNjb3VudCIsInVzZXIiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJhY2Nlc3NUb2tlbkV4cGlyZXMiLCJleHBpcmVzX2F0IiwiRGF0ZSIsIm5vdyIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwiYm9keSIsIlVSTFNlYXJjaFBhcmFtcyIsImNsaWVudF9pZCIsImNsaWVudF9zZWNyZXQiLCJncmFudF90eXBlIiwibWV0aG9kIiwicmVmcmVzaGVkVG9rZW5zIiwianNvbiIsIm9rIiwiZXhwaXJlc19pbiIsImVycm9yIiwiY29uc29sZSIsInNlc3Npb24iLCJkZWJ1ZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/auth/[...nextauth].js\n");

/***/ }),

/***/ "(api)/./pages/api/chat-stream.js":
/*!**********************************!*\
  !*** ./pages/api/chat-stream.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_chatbot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/chatbot */ \"(api)/./lib/chatbot.js\");\n/* harmony import */ var next_auth_next__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/next */ \"next-auth/next\");\n/* harmony import */ var next_auth_next__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_next__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _api_auth_nextauth___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/auth/[...nextauth] */ \"(api)/./pages/api/auth/[...nextauth].js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_chatbot__WEBPACK_IMPORTED_MODULE_0__]);\n_lib_chatbot__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst config = {\n    api: {\n        responseLimit: false\n    }\n};\nasync function handler(req, res) {\n    // This endpoint only accepts GET requests for SSE\n    if (req.method !== \"GET\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    try {\n        const session = await (0,next_auth_next__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(req, res, _api_auth_nextauth___WEBPACK_IMPORTED_MODULE_2__.authOptions);\n        const { message, startNew } = req.query; // Read startNew query param\n        const startNewConversation = startNew === \"true\"; // Convert to boolean\n        if (!message) {\n            return res.status(400).json({\n                error: \"Message is required\"\n            });\n        }\n        // Check if user is authenticated\n        if (!session) {\n            return res.status(401).json({\n                error: \"Authentication required\"\n            });\n        }\n        // Check if token has an error (failed refresh)\n        if (session.error === \"RefreshAccessTokenError\") {\n            return res.status(401).json({\n                error: \"Your session has expired. Please sign in again.\"\n            });\n        }\n        // Get user ID from session\n        const userId = session.user?.email || \"default\";\n        // Get access token from session\n        const accessToken = session.accessToken;\n        // Set up Server-Sent Events\n        res.writeHead(200, {\n            \"Content-Type\": \"text/event-stream\",\n            \"Cache-Control\": \"no-cache, no-transform, no-store\",\n            \"Connection\": \"keep-alive\",\n            \"X-Accel-Buffering\": \"no\" // Disable buffering in Nginx\n        });\n        // Send initial message\n        res.write(`data: ${JSON.stringify({\n            type: \"start\"\n        })}\\n\\n`);\n        // Force flush the initial message\n        if (res.flush) {\n            try {\n                res.flush();\n            } catch (flushError) {\n                console.warn(\"Error flushing initial message:\", flushError);\n            }\n        }\n        // Create a callback function to handle streaming chunks\n        const streamCallback = (chunk)=>{\n            try {\n                const chunkData = JSON.stringify(chunk);\n                res.write(`data: ${chunkData}\\n\\n`);\n            } catch (writeError) {\n                console.error(\"Error writing chunk to response:\", writeError);\n            }\n            // Flush the response to ensure chunks are sent immediately\n            if (res.flush) {\n                try {\n                    res.flush();\n                } catch (flushError) {\n                    console.warn(\"Error flushing response:\", flushError);\n                }\n            }\n        };\n        try {\n            // Call the chatbot with streaming enabled\n            await (0,_lib_chatbot__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(message, userId, accessToken, streamCallback, startNewConversation);\n            // Add a small delay before sending the end message\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            // Send completion message\n            const endMessage = JSON.stringify({\n                type: \"end\"\n            });\n            res.write(`data: ${endMessage}\\n\\n`);\n            // Final flush before ending\n            if (res.flush) {\n                try {\n                    res.flush();\n                } catch (flushError) {\n                    console.warn(\"Error flushing final response:\", flushError);\n                }\n            }\n            // Add another small delay before ending the response\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            res.end();\n        } catch (error) {\n            // Send error message\n            console.error(\"Error in chat-stream processing:\", error);\n            res.write(`data: ${JSON.stringify({\n                type: \"error\",\n                content: error.message\n            })}\\n\\n`);\n            // Flush error message\n            if (res.flush) {\n                try {\n                    res.flush();\n                } catch (flushError) {\n                    console.warn(\"Error flushing error response:\", flushError);\n                }\n            }\n            res.end();\n        }\n    } catch (error) {\n        console.error(\"Error in chat-stream API:\", error);\n        return res.status(500).json({\n            error: \"An error occurred while processing your request\"\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7WUFFbkMsNEJBQTRCO1lBQzVCLElBQUk5QixJQUFJbUIsS0FBSyxFQUFFO2dCQUNiLElBQUk7b0JBQ0ZuQixJQUFJbUIsS0FBSztnQkFDWCxFQUFFLE9BQU9DLFlBQVk7b0JBQ25CQyxRQUFRQyxJQUFJLENBQUMsa0NBQWtDRjtnQkFDakQ7WUFDRjtZQUVBLHFEQUFxRDtZQUNyRCxNQUFNLElBQUlPLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFFakQ1QixJQUFJK0IsR0FBRztRQUNULEVBQUUsT0FBTzNCLE9BQU87WUFDZCxxQkFBcUI7WUFDckJpQixRQUFRakIsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbERKLElBQUllLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFQyxNQUFNO2dCQUFTYyxTQUFTNUIsTUFBTUUsT0FBTztZQUFDLEdBQUcsSUFBSSxDQUFDO1lBQ2xGLHNCQUFzQjtZQUN0QixJQUFJTixJQUFJbUIsS0FBSyxFQUFFO2dCQUNiLElBQUk7b0JBQ0ZuQixJQUFJbUIsS0FBSztnQkFDWCxFQUFFLE9BQU9DLFlBQVk7b0JBQ25CQyxRQUFRQyxJQUFJLENBQUMsa0NBQWtDRjtnQkFDakQ7WUFDRjtZQUNBcEIsSUFBSStCLEdBQUc7UUFDVDtJQUNGLEVBQUUsT0FBTzNCLE9BQU87UUFDZGlCLFFBQVFqQixLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxPQUFPSixJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQUVDLE9BQU87UUFBa0Q7SUFDekY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL3BhZ2VzL2FwaS9jaGF0LXN0cmVhbS5qcz81ZmNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaGF0Ym90IGZyb20gJy4uLy4uL2xpYi9jaGF0Ym90JztcbmltcG9ydCB7IGdldFNlcnZlclNlc3Npb24gfSBmcm9tICduZXh0LWF1dGgvbmV4dCc7XG5pbXBvcnQgeyBhdXRoT3B0aW9ucyB9IGZyb20gJy4uL2FwaS9hdXRoL1suLi5uZXh0YXV0aF0nO1xuXG5leHBvcnQgY29uc3QgY29uZmlnID0ge1xuICBhcGk6IHtcbiAgICByZXNwb25zZUxpbWl0OiBmYWxzZSxcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMpIHtcbiAgLy8gVGhpcyBlbmRwb2ludCBvbmx5IGFjY2VwdHMgR0VUIHJlcXVlc3RzIGZvciBTU0VcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0U2VydmVyU2Vzc2lvbihyZXEsIHJlcywgYXV0aE9wdGlvbnMpO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhcnROZXcgfSA9IHJlcS5xdWVyeTsgLy8gUmVhZCBzdGFydE5ldyBxdWVyeSBwYXJhbVxuICAgIGNvbnN0IHN0YXJ0TmV3Q29udmVyc2F0aW9uID0gc3RhcnROZXcgPT09ICd0cnVlJzsgLy8gQ29udmVydCB0byBib29sZWFuXG4gICAgXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ01lc3NhZ2UgaXMgcmVxdWlyZWQnIH0pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAxKS5qc29uKHsgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaGFzIGFuIGVycm9yIChmYWlsZWQgcmVmcmVzaClcbiAgICBpZiAoc2Vzc2lvbi5lcnJvciA9PT0gJ1JlZnJlc2hBY2Nlc3NUb2tlbkVycm9yJykge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAxKS5qc29uKHsgZXJyb3I6ICdZb3VyIHNlc3Npb24gaGFzIGV4cGlyZWQuIFBsZWFzZSBzaWduIGluIGFnYWluLicgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHVzZXIgSUQgZnJvbSBzZXNzaW9uXG4gICAgY29uc3QgdXNlcklkID0gc2Vzc2lvbi51c2VyPy5lbWFpbCB8fCAnZGVmYXVsdCc7XG4gICAgXG4gICAgLy8gR2V0IGFjY2VzcyB0b2tlbiBmcm9tIHNlc3Npb25cbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHNlc3Npb24uYWNjZXNzVG9rZW47XG4gICAgXG4gICAgLy8gU2V0IHVwIFNlcnZlci1TZW50IEV2ZW50c1xuICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvZXZlbnQtc3RyZWFtJyxcbiAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby10cmFuc2Zvcm0sIG5vLXN0b3JlJyxcbiAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxuICAgICAgJ1gtQWNjZWwtQnVmZmVyaW5nJzogJ25vJyAvLyBEaXNhYmxlIGJ1ZmZlcmluZyBpbiBOZ2lueFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNlbmQgaW5pdGlhbCBtZXNzYWdlXG4gICAgcmVzLndyaXRlKGBkYXRhOiAke0pTT04uc3RyaW5naWZ5KHsgdHlwZTogJ3N0YXJ0JyB9KX1cXG5cXG5gKTtcbiAgICAvLyBGb3JjZSBmbHVzaCB0aGUgaW5pdGlhbCBtZXNzYWdlXG4gICAgaWYgKHJlcy5mbHVzaCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzLmZsdXNoKCk7XG4gICAgICB9IGNhdGNoIChmbHVzaEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZsdXNoaW5nIGluaXRpYWwgbWVzc2FnZTpcIiwgZmx1c2hFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSBzdHJlYW1pbmcgY2h1bmtzXG4gICAgY29uc3Qgc3RyZWFtQ2FsbGJhY2sgPSAoY2h1bmspID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNodW5rRGF0YSA9IEpTT04uc3RyaW5naWZ5KGNodW5rKTtcbiAgICAgICAgcmVzLndyaXRlKGBkYXRhOiAke2NodW5rRGF0YX1cXG5cXG5gKTtcbiAgICAgIH0gY2F0Y2ggKHdyaXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdyaXRpbmcgY2h1bmsgdG8gcmVzcG9uc2U6XCIsIHdyaXRlRXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGbHVzaCB0aGUgcmVzcG9uc2UgdG8gZW5zdXJlIGNodW5rcyBhcmUgc2VudCBpbW1lZGlhdGVseVxuICAgICAgaWYgKHJlcy5mbHVzaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcy5mbHVzaCgpO1xuICAgICAgICB9IGNhdGNoIChmbHVzaEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZmx1c2hpbmcgcmVzcG9uc2U6XCIsIGZsdXNoRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ2FsbCB0aGUgY2hhdGJvdCB3aXRoIHN0cmVhbWluZyBlbmFibGVkXG4gICAgICBhd2FpdCBjaGF0Ym90KG1lc3NhZ2UsIHVzZXJJZCwgYWNjZXNzVG9rZW4sIHN0cmVhbUNhbGxiYWNrLCBzdGFydE5ld0NvbnZlcnNhdGlvbik7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IGJlZm9yZSBzZW5kaW5nIHRoZSBlbmQgbWVzc2FnZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCBjb21wbGV0aW9uIG1lc3NhZ2VcbiAgICAgIGNvbnN0IGVuZE1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdlbmQnIH0pO1xuICAgICAgcmVzLndyaXRlKGBkYXRhOiAke2VuZE1lc3NhZ2V9XFxuXFxuYCk7XG4gICAgICBcbiAgICAgIC8vIEZpbmFsIGZsdXNoIGJlZm9yZSBlbmRpbmdcbiAgICAgIGlmIChyZXMuZmx1c2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMuZmx1c2goKTtcbiAgICAgICAgfSBjYXRjaCAoZmx1c2hFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZsdXNoaW5nIGZpbmFsIHJlc3BvbnNlOlwiLCBmbHVzaEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgYW5vdGhlciBzbWFsbCBkZWxheSBiZWZvcmUgZW5kaW5nIHRoZSByZXNwb25zZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgXG4gICAgICByZXMuZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFNlbmQgZXJyb3IgbWVzc2FnZVxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNoYXQtc3RyZWFtIHByb2Nlc3Npbmc6XCIsIGVycm9yKTtcbiAgICAgIHJlcy53cml0ZShgZGF0YTogJHtKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IGVycm9yLm1lc3NhZ2UgfSl9XFxuXFxuYCk7XG4gICAgICAvLyBGbHVzaCBlcnJvciBtZXNzYWdlXG4gICAgICBpZiAocmVzLmZsdXNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzLmZsdXNoKCk7XG4gICAgICAgIH0gY2F0Y2ggKGZsdXNoRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBmbHVzaGluZyBlcnJvciByZXNwb25zZTpcIiwgZmx1c2hFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY2hhdC1zdHJlYW0gQVBJOicsIGVycm9yKTtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHByb2Nlc3NpbmcgeW91ciByZXF1ZXN0JyB9KTtcbiAgfVxufSJdLCJuYW1lcyI6WyJjaGF0Ym90IiwiZ2V0U2VydmVyU2Vzc2lvbiIsImF1dGhPcHRpb25zIiwiY29uZmlnIiwiYXBpIiwicmVzcG9uc2VMaW1pdCIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJzZXNzaW9uIiwibWVzc2FnZSIsInN0YXJ0TmV3IiwicXVlcnkiLCJzdGFydE5ld0NvbnZlcnNhdGlvbiIsInVzZXJJZCIsInVzZXIiLCJlbWFpbCIsImFjY2Vzc1Rva2VuIiwid3JpdGVIZWFkIiwid3JpdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZSIsImZsdXNoIiwiZmx1c2hFcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwic3RyZWFtQ2FsbGJhY2siLCJjaHVuayIsImNodW5rRGF0YSIsIndyaXRlRXJyb3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJlbmRNZXNzYWdlIiwiZW5kIiwiY29udGVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/chat-stream.js\n");

/***/ }),

/***/ "(api)/./credentials.json":
/*!**************************!*\
  !*** ./credentials.json ***!
  \**************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"web":{"client_id":"1067969091630-i858c64u30bsfafv6803adcbropoiqpl.apps.googleusercontent.com","project_id":"gcalendarmate","auth_uri":"https://accounts.google.com/o/oauth2/auth","token_uri":"https://oauth2.googleapis.com/token","auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs","client_secret":"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","redirect_uris":["http://localhost:3000/auth/google/callback","https://gcalendarapp.vercel.app/auth/google","https://gcalendarapp.vercel.app/auth/google/callback","http://localhost:3000/api/auth/callback/google"],"javascript_origins":["http://localhost:3000","https://gcalendarapp.vercel.app"]}}');

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();