"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/chat-stream";
exports.ids = ["pages/api/chat-stream"];
exports.modules = {

/***/ "dotenv/config":
/*!********************************!*\
  !*** external "dotenv/config" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("dotenv/config");

/***/ }),

/***/ "google-auth-library":
/*!**************************************!*\
  !*** external "google-auth-library" ***!
  \**************************************/
/***/ ((module) => {

module.exports = require("google-auth-library");

/***/ }),

/***/ "googleapis":
/*!*****************************!*\
  !*** external "googleapis" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("googleapis");

/***/ }),

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "next-auth":
/*!****************************!*\
  !*** external "next-auth" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("next-auth");

/***/ }),

/***/ "next-auth/next":
/*!*********************************!*\
  !*** external "next-auth/next" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("next-auth/next");

/***/ }),

/***/ "next-auth/providers/google":
/*!*********************************************!*\
  !*** external "next-auth/providers/google" ***!
  \*********************************************/
/***/ ((module) => {

module.exports = require("next-auth/providers/google");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "node-cache":
/*!*****************************!*\
  !*** external "node-cache" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-cache");

/***/ }),

/***/ "chrono-node":
/*!******************************!*\
  !*** external "chrono-node" ***!
  \******************************/
/***/ ((module) => {

module.exports = import("chrono-node");;

/***/ }),

/***/ "luxon":
/*!************************!*\
  !*** external "luxon" ***!
  \************************/
/***/ ((module) => {

module.exports = import("luxon");;

/***/ }),

/***/ "openai":
/*!*************************!*\
  !*** external "openai" ***!
  \*************************/
/***/ ((module) => {

module.exports = import("openai");;

/***/ }),

/***/ "sequelize":
/*!****************************!*\
  !*** external "sequelize" ***!
  \****************************/
/***/ ((module) => {

module.exports = import("sequelize");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/chat-stream.js */ \"(api)/./pages/api/chat-stream.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/chat-stream\",\n        pathname: \"/api/chat-stream\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_chat_stream_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmNoYXQtc3RyZWFtJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZhcGklMkZjaGF0LXN0cmVhbS5qcyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUN1RDtBQUN2RDtBQUNBLGlFQUFlLHdFQUFLLENBQUMsc0RBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLHNEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCxxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8/NzRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvYXBpL2NoYXQtc3RyZWFtLmpzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvY2hhdC1zdHJlYW1cIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jaGF0LXN0cmVhbVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./googleCalendar.js":
/*!***************************!*\
  !*** ./googleCalendar.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { google } = __webpack_require__(/*! googleapis */ \"googleapis\");\nconst { OAuth2Client } = __webpack_require__(/*! google-auth-library */ \"google-auth-library\");\n/**\n * Creates and configures an OAuth2Client with the provided tokens\n * @param {Object} tokens - The tokens object containing access_token and optionally refresh_token\n * @returns {OAuth2Client} - Configured OAuth2Client instance\n */ function createOAuth2Client(tokens) {\n    try {\n        const credentials = __webpack_require__(/*! ./credentials.json */ \"(api)/./credentials.json\");\n        const { client_secret, client_id, redirect_uris } = credentials.web;\n        const oauth2Client = new OAuth2Client(client_id, client_secret, redirect_uris[0]);\n        // Handle both full tokens object and just access_token\n        if (typeof tokens === \"object\" && tokens !== null) {\n            if (tokens.access_token) {\n                // If it's just the access_token from NextAuth session\n                oauth2Client.setCredentials({\n                    access_token: tokens.access_token,\n                    refresh_token: tokens.refresh_token,\n                    token_type: \"Bearer\"\n                });\n            } else {\n                // If it's a full tokens object\n                oauth2Client.setCredentials(tokens);\n            }\n        } else {\n            console.error(\"Invalid tokens format:\", tokens);\n            throw new Error(\"Invalid tokens format\");\n        }\n        return oauth2Client;\n    } catch (error) {\n        console.error(\"Error creating OAuth2Client:\", error);\n        throw error;\n    }\n}\n/**\n * Get calendar events for a specific date range\n * @param {Object} tokens - User's OAuth tokens\n * @param {Date} start_date - Start date for events\n * @param {Date} end_date - End date for events\n * @returns {Array} - List of calendar events\n */ async function getCalendarEvents(tokens, start_date, end_date) {\n    try {\n        const oauth2Client = createOAuth2Client(tokens);\n        const calendar = google.calendar({\n            version: \"v3\",\n            auth: oauth2Client\n        });\n        const res = await calendar.events.list({\n            calendarId: \"primary\",\n            timeMin: start_date.toISOString(),\n            timeMax: end_date.toISOString(),\n            singleEvents: true,\n            orderBy: \"startTime\"\n        });\n        return res.data.items || [];\n    } catch (error) {\n        console.error(\"Error fetching events:\", error);\n        return [];\n    }\n}\n/**\n * Add a new calendar event\n * @param {Object} tokens - User's OAuth tokens\n * @param {string} summary - Event title\n * @param {string} start - Event start time\n * @param {string} end - Event end time\n * @param {string} description - Event description\n * @param {string} location - Event location\n * @param {Array} reminders - Optional reminders in minutes\n * @returns {Object} - Created event data\n */ async function addCalendarEvent(tokens, summary, start, end, description, location, reminders) {\n    const oauth2Client = createOAuth2Client(tokens);\n    const calendar = google.calendar({\n        version: \"v3\",\n        auth: oauth2Client\n    });\n    const event = {\n        summary,\n        description,\n        location,\n        start: {\n            dateTime: start\n        },\n        end: {\n            dateTime: end\n        }\n    };\n    // Add reminders if provided\n    if (reminders && Array.isArray(reminders) && reminders.length > 0) {\n        event.reminders = {\n            useDefault: false,\n            overrides: reminders.map((minutes)=>({\n                    method: \"popup\",\n                    minutes: minutes\n                }))\n        };\n    }\n    try {\n        const res = await calendar.events.insert({\n            calendarId: \"primary\",\n            resource: event\n        });\n        return res.data;\n    } catch (error) {\n        console.error(\"Error adding event:\", error);\n        throw error;\n    }\n}\n/**\n * Delete a calendar event\n * @param {Object} tokens - User's OAuth tokens\n * @param {string} eventId - ID of the event to delete \n * @param {string} calendarId - Calendar ID (defaults to 'primary')\n * @returns {Object} - Deleted event summary\n */ async function deleteCalendarEvent(tokens, eventId, calendarId = \"primary\") {\n    // Validate inputs\n    if (!tokens) {\n        throw new Error(\"OAuth tokens are required\");\n    }\n    if (!eventId) {\n        throw new Error(\"Event ID is required\");\n    }\n    const oauth2Client = createOAuth2Client(tokens);\n    const calendar = google.calendar({\n        version: \"v3\",\n        auth: oauth2Client\n    });\n    try {\n        // First get the event to return its summary after deletion\n        let eventSummary = null;\n        try {\n            const event = await calendar.events.get({\n                calendarId: calendarId,\n                eventId: eventId\n            });\n            eventSummary = event.data.summary;\n        } catch (getError) {\n            console.warn(`Could not retrieve event details before deletion: ${getError.message}`);\n        }\n        await calendar.events.delete({\n            calendarId: calendarId,\n            eventId: eventId\n        });\n        return {\n            success: true,\n            summary: eventSummary,\n            eventId: eventId\n        };\n    } catch (error) {\n        console.error(`Error deleting event ${eventId}:`, error.message);\n        return {\n            success: false,\n            error: error.message,\n            eventId: eventId\n        };\n    }\n}\n/**\n * Update a calendar event\n * @param {Object} tokens - User's OAuth tokens\n * @param {string} eventId - ID of the event to update\n * @param {Object} updates - Object containing fields to update\n * @returns {Object} - Updated event data\n */ async function updateCalendarEvent(tokens, eventId, updates) {\n    const oauth2Client = createOAuth2Client(tokens);\n    const calendar = google.calendar({\n        version: \"v3\",\n        auth: oauth2Client\n    });\n    try {\n        // First get the current event\n        const currentEvent = await calendar.events.get({\n            calendarId: \"primary\",\n            eventId: eventId\n        });\n        // Prepare the update payload\n        const updatedEvent = {\n            ...currentEvent.data\n        };\n        if (updates.summary) updatedEvent.summary = updates.summary;\n        if (updates.description) updatedEvent.description = updates.description;\n        if (updates.location) updatedEvent.location = updates.location;\n        if (updates.start) {\n            updatedEvent.start = {\n                dateTime: updates.start,\n                timeZone: currentEvent.data.start.timeZone\n            };\n        }\n        if (updates.end) {\n            updatedEvent.end = {\n                dateTime: updates.end,\n                timeZone: currentEvent.data.end.timeZone\n            };\n        }\n        // Update the event\n        const res = await calendar.events.update({\n            calendarId: \"primary\",\n            eventId: eventId,\n            resource: updatedEvent\n        });\n        return res.data;\n    } catch (error) {\n        console.error(\"Error updating event:\", error);\n        throw error;\n    }\n}\nmodule.exports = {\n    createOAuth2Client,\n    getCalendarEvents,\n    addCalendarEvent,\n    deleteCalendarEvent,\n    updateCalendarEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9nb29nbGVDYWxlbmRhci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFakM7Ozs7Q0FJQyxHQUNELFNBQVNFLG1CQUFtQkMsTUFBTTtJQUNoQyxJQUFJO1FBQ0YsTUFBTUMsY0FBY0osbUJBQU9BLENBQUM7UUFDNUIsTUFBTSxFQUFFSyxhQUFhLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFLEdBQUdILFlBQVlJLEdBQUc7UUFDbkUsTUFBTUMsZUFBZSxJQUFJUixhQUFhSyxXQUFXRCxlQUFlRSxhQUFhLENBQUMsRUFBRTtRQUVoRix1REFBdUQ7UUFDdkQsSUFBSSxPQUFPSixXQUFXLFlBQVlBLFdBQVcsTUFBTTtZQUNqRCxJQUFJQSxPQUFPTyxZQUFZLEVBQUU7Z0JBQ3ZCLHNEQUFzRDtnQkFDdERELGFBQWFFLGNBQWMsQ0FBQztvQkFDMUJELGNBQWNQLE9BQU9PLFlBQVk7b0JBQ2pDRSxlQUFlVCxPQUFPUyxhQUFhO29CQUNuQ0MsWUFBWTtnQkFDZDtZQUNGLE9BQU87Z0JBQ0wsK0JBQStCO2dCQUMvQkosYUFBYUUsY0FBYyxDQUFDUjtZQUM5QjtRQUNGLE9BQU87WUFDTFcsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQlo7WUFDeEMsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO1FBRUEsT0FBT1A7SUFDVCxFQUFFLE9BQU9NLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ0E7UUFDOUMsTUFBTUE7SUFDUjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsZUFBZUUsa0JBQWtCZCxNQUFNLEVBQUVlLFVBQVUsRUFBRUMsUUFBUTtJQUMzRCxJQUFJO1FBQ0YsTUFBTVYsZUFBZVAsbUJBQW1CQztRQUN4QyxNQUFNaUIsV0FBV3JCLE9BQU9xQixRQUFRLENBQUM7WUFBRUMsU0FBUztZQUFNQyxNQUFNYjtRQUFhO1FBQ3JFLE1BQU1jLE1BQU0sTUFBTUgsU0FBU0ksTUFBTSxDQUFDQyxJQUFJLENBQUM7WUFDckNDLFlBQVk7WUFDWkMsU0FBU1QsV0FBV1UsV0FBVztZQUMvQkMsU0FBU1YsU0FBU1MsV0FBVztZQUM3QkUsY0FBYztZQUNkQyxTQUFTO1FBQ1g7UUFDQSxPQUFPUixJQUFJUyxJQUFJLENBQUNDLEtBQUssSUFBSSxFQUFFO0lBQzdCLEVBQUUsT0FBT2xCLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxlQUFlbUIsaUJBQWlCL0IsTUFBTSxFQUFFZ0MsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLFNBQVM7SUFDM0YsTUFBTS9CLGVBQWVQLG1CQUFtQkM7SUFDeEMsTUFBTWlCLFdBQVdyQixPQUFPcUIsUUFBUSxDQUFDO1FBQUVDLFNBQVM7UUFBTUMsTUFBTWI7SUFBYTtJQUVyRSxNQUFNZ0MsUUFBUTtRQUNaTjtRQUNBRztRQUNBQztRQUNBSCxPQUFPO1lBQUVNLFVBQVVOO1FBQU07UUFDekJDLEtBQUs7WUFBRUssVUFBVUw7UUFBSTtJQUN2QjtJQUVBLDRCQUE0QjtJQUM1QixJQUFJRyxhQUFhRyxNQUFNQyxPQUFPLENBQUNKLGNBQWNBLFVBQVVLLE1BQU0sR0FBRyxHQUFHO1FBQ2pFSixNQUFNRCxTQUFTLEdBQUc7WUFDaEJNLFlBQVk7WUFDWkMsV0FBV1AsVUFBVVEsR0FBRyxDQUFDQyxDQUFBQSxVQUFZO29CQUNuQ0MsUUFBUTtvQkFDUkQsU0FBU0E7Z0JBQ1g7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU0xQixNQUFNLE1BQU1ILFNBQVNJLE1BQU0sQ0FBQzJCLE1BQU0sQ0FBQztZQUN2Q3pCLFlBQVk7WUFDWjBCLFVBQVVYO1FBQ1o7UUFDQSxPQUFPbEIsSUFBSVMsSUFBSTtJQUNqQixFQUFFLE9BQU9qQixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyx1QkFBdUJBO1FBQ3JDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELGVBQWVzQyxvQkFBb0JsRCxNQUFNLEVBQUVtRCxPQUFPLEVBQUU1QixhQUFhLFNBQVM7SUFDeEUsa0JBQWtCO0lBQ2xCLElBQUksQ0FBQ3ZCLFFBQVE7UUFDWCxNQUFNLElBQUlhLE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNzQyxTQUFTO1FBQ1osTUFBTSxJQUFJdEMsTUFBTTtJQUNsQjtJQUVBLE1BQU1QLGVBQWVQLG1CQUFtQkM7SUFDeEMsTUFBTWlCLFdBQVdyQixPQUFPcUIsUUFBUSxDQUFDO1FBQUVDLFNBQVM7UUFBTUMsTUFBTWI7SUFBYTtJQUVyRSxJQUFJO1FBQ0YsMkRBQTJEO1FBQzNELElBQUk4QyxlQUFlO1FBQ25CLElBQUk7WUFDRixNQUFNZCxRQUFRLE1BQU1yQixTQUFTSSxNQUFNLENBQUNnQyxHQUFHLENBQUM7Z0JBQ3RDOUIsWUFBWUE7Z0JBQ1o0QixTQUFTQTtZQUNYO1lBQ0FDLGVBQWVkLE1BQU1ULElBQUksQ0FBQ0csT0FBTztRQUNuQyxFQUFFLE9BQU9zQixVQUFVO1lBQ2pCM0MsUUFBUTRDLElBQUksQ0FBQyxDQUFDLGtEQUFrRCxFQUFFRCxTQUFTRSxPQUFPLENBQUMsQ0FBQztRQUN0RjtRQUVBLE1BQU12QyxTQUFTSSxNQUFNLENBQUNvQyxNQUFNLENBQUM7WUFDM0JsQyxZQUFZQTtZQUNaNEIsU0FBU0E7UUFDWDtRQUNBLE9BQU87WUFBRU8sU0FBUztZQUFNMUIsU0FBU29CO1lBQWNELFNBQVNBO1FBQVE7SUFDbEUsRUFBRSxPQUFPdkMsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsRUFBRXVDLFFBQVEsQ0FBQyxDQUFDLEVBQUV2QyxNQUFNNEMsT0FBTztRQUMvRCxPQUFPO1lBQUVFLFNBQVM7WUFBTzlDLE9BQU9BLE1BQU00QyxPQUFPO1lBQUVMLFNBQVNBO1FBQVE7SUFDbEU7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELGVBQWVRLG9CQUFvQjNELE1BQU0sRUFBRW1ELE9BQU8sRUFBRVMsT0FBTztJQUN6RCxNQUFNdEQsZUFBZVAsbUJBQW1CQztJQUN4QyxNQUFNaUIsV0FBV3JCLE9BQU9xQixRQUFRLENBQUM7UUFBRUMsU0FBUztRQUFNQyxNQUFNYjtJQUFhO0lBRXJFLElBQUk7UUFDRiw4QkFBOEI7UUFDOUIsTUFBTXVELGVBQWUsTUFBTTVDLFNBQVNJLE1BQU0sQ0FBQ2dDLEdBQUcsQ0FBQztZQUM3QzlCLFlBQVk7WUFDWjRCLFNBQVNBO1FBQ1g7UUFFQSw2QkFBNkI7UUFDN0IsTUFBTVcsZUFBZTtZQUFFLEdBQUdELGFBQWFoQyxJQUFJO1FBQUM7UUFFNUMsSUFBSStCLFFBQVE1QixPQUFPLEVBQUU4QixhQUFhOUIsT0FBTyxHQUFHNEIsUUFBUTVCLE9BQU87UUFDM0QsSUFBSTRCLFFBQVF6QixXQUFXLEVBQUUyQixhQUFhM0IsV0FBVyxHQUFHeUIsUUFBUXpCLFdBQVc7UUFDdkUsSUFBSXlCLFFBQVF4QixRQUFRLEVBQUUwQixhQUFhMUIsUUFBUSxHQUFHd0IsUUFBUXhCLFFBQVE7UUFFOUQsSUFBSXdCLFFBQVEzQixLQUFLLEVBQUU7WUFDakI2QixhQUFhN0IsS0FBSyxHQUFHO2dCQUNuQk0sVUFBVXFCLFFBQVEzQixLQUFLO2dCQUN2QjhCLFVBQVVGLGFBQWFoQyxJQUFJLENBQUNJLEtBQUssQ0FBQzhCLFFBQVE7WUFDNUM7UUFDRjtRQUVBLElBQUlILFFBQVExQixHQUFHLEVBQUU7WUFDZjRCLGFBQWE1QixHQUFHLEdBQUc7Z0JBQ2pCSyxVQUFVcUIsUUFBUTFCLEdBQUc7Z0JBQ3JCNkIsVUFBVUYsYUFBYWhDLElBQUksQ0FBQ0ssR0FBRyxDQUFDNkIsUUFBUTtZQUMxQztRQUNGO1FBRUEsbUJBQW1CO1FBQ25CLE1BQU0zQyxNQUFNLE1BQU1ILFNBQVNJLE1BQU0sQ0FBQzJDLE1BQU0sQ0FBQztZQUN2Q3pDLFlBQVk7WUFDWjRCLFNBQVNBO1lBQ1RGLFVBQVVhO1FBQ1o7UUFFQSxPQUFPMUMsSUFBSVMsSUFBSTtJQUNqQixFQUFFLE9BQU9qQixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3ZDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBcUQsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZuRTtJQUNBZTtJQUNBaUI7SUFDQW1CO0lBQ0FTO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nY2FsZW5kYXJhcHAvLi9nb29nbGVDYWxlbmRhci5qcz8xMGYxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgZ29vZ2xlIH0gPSByZXF1aXJlKCdnb29nbGVhcGlzJyk7XG5jb25zdCB7IE9BdXRoMkNsaWVudCB9ID0gcmVxdWlyZSgnZ29vZ2xlLWF1dGgtbGlicmFyeScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGNvbmZpZ3VyZXMgYW4gT0F1dGgyQ2xpZW50IHdpdGggdGhlIHByb3ZpZGVkIHRva2Vuc1xuICogQHBhcmFtIHtPYmplY3R9IHRva2VucyAtIFRoZSB0b2tlbnMgb2JqZWN0IGNvbnRhaW5pbmcgYWNjZXNzX3Rva2VuIGFuZCBvcHRpb25hbGx5IHJlZnJlc2hfdG9rZW5cbiAqIEByZXR1cm5zIHtPQXV0aDJDbGllbnR9IC0gQ29uZmlndXJlZCBPQXV0aDJDbGllbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucykge1xuICB0cnkge1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi9jcmVkZW50aWFscy5qc29uJyk7XG4gICAgY29uc3QgeyBjbGllbnRfc2VjcmV0LCBjbGllbnRfaWQsIHJlZGlyZWN0X3VyaXMgfSA9IGNyZWRlbnRpYWxzLndlYjtcbiAgICBjb25zdCBvYXV0aDJDbGllbnQgPSBuZXcgT0F1dGgyQ2xpZW50KGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCwgcmVkaXJlY3RfdXJpc1swXSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIGJvdGggZnVsbCB0b2tlbnMgb2JqZWN0IGFuZCBqdXN0IGFjY2Vzc190b2tlblxuICAgIGlmICh0eXBlb2YgdG9rZW5zID09PSAnb2JqZWN0JyAmJiB0b2tlbnMgIT09IG51bGwpIHtcbiAgICAgIGlmICh0b2tlbnMuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIC8vIElmIGl0J3MganVzdCB0aGUgYWNjZXNzX3Rva2VuIGZyb20gTmV4dEF1dGggc2Vzc2lvblxuICAgICAgICBvYXV0aDJDbGllbnQuc2V0Q3JlZGVudGlhbHMoe1xuICAgICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW5zLmFjY2Vzc190b2tlbixcbiAgICAgICAgICByZWZyZXNoX3Rva2VuOiB0b2tlbnMucmVmcmVzaF90b2tlbixcbiAgICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSBmdWxsIHRva2VucyBvYmplY3RcbiAgICAgICAgb2F1dGgyQ2xpZW50LnNldENyZWRlbnRpYWxzKHRva2Vucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdG9rZW5zIGZvcm1hdDonLCB0b2tlbnMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VucyBmb3JtYXQnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG9hdXRoMkNsaWVudDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBPQXV0aDJDbGllbnQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNhbGVuZGFyIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBkYXRlIHJhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtEYXRlfSBzdGFydF9kYXRlIC0gU3RhcnQgZGF0ZSBmb3IgZXZlbnRzXG4gKiBAcGFyYW0ge0RhdGV9IGVuZF9kYXRlIC0gRW5kIGRhdGUgZm9yIGV2ZW50c1xuICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgY2FsZW5kYXIgZXZlbnRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENhbGVuZGFyRXZlbnRzKHRva2Vucywgc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBvYXV0aDJDbGllbnQgPSBjcmVhdGVPQXV0aDJDbGllbnQodG9rZW5zKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IGdvb2dsZS5jYWxlbmRhcih7IHZlcnNpb246ICd2MycsIGF1dGg6IG9hdXRoMkNsaWVudCB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxlbmRhci5ldmVudHMubGlzdCh7XG4gICAgICBjYWxlbmRhcklkOiAncHJpbWFyeScsXG4gICAgICB0aW1lTWluOiBzdGFydF9kYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICB0aW1lTWF4OiBlbmRfZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgc2luZ2xlRXZlbnRzOiB0cnVlLFxuICAgICAgb3JkZXJCeTogJ3N0YXJ0VGltZScsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcy5kYXRhLml0ZW1zIHx8IFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV2ZW50czonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGNhbGVuZGFyIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IHN1bW1hcnkgLSBFdmVudCB0aXRsZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0IC0gRXZlbnQgc3RhcnQgdGltZVxuICogQHBhcmFtIHtzdHJpbmd9IGVuZCAtIEV2ZW50IGVuZCB0aW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzY3JpcHRpb24gLSBFdmVudCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gRXZlbnQgbG9jYXRpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHJlbWluZGVycyAtIE9wdGlvbmFsIHJlbWluZGVycyBpbiBtaW51dGVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIENyZWF0ZWQgZXZlbnQgZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBhZGRDYWxlbmRhckV2ZW50KHRva2Vucywgc3VtbWFyeSwgc3RhcnQsIGVuZCwgZGVzY3JpcHRpb24sIGxvY2F0aW9uLCByZW1pbmRlcnMpIHtcbiAgY29uc3Qgb2F1dGgyQ2xpZW50ID0gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucyk7XG4gIGNvbnN0IGNhbGVuZGFyID0gZ29vZ2xlLmNhbGVuZGFyKHsgdmVyc2lvbjogJ3YzJywgYXV0aDogb2F1dGgyQ2xpZW50IH0pO1xuICBcbiAgY29uc3QgZXZlbnQgPSB7XG4gICAgc3VtbWFyeSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBsb2NhdGlvbixcbiAgICBzdGFydDogeyBkYXRlVGltZTogc3RhcnQgfSxcbiAgICBlbmQ6IHsgZGF0ZVRpbWU6IGVuZCB9LFxuICB9O1xuICBcbiAgLy8gQWRkIHJlbWluZGVycyBpZiBwcm92aWRlZFxuICBpZiAocmVtaW5kZXJzICYmIEFycmF5LmlzQXJyYXkocmVtaW5kZXJzKSAmJiByZW1pbmRlcnMubGVuZ3RoID4gMCkge1xuICAgIGV2ZW50LnJlbWluZGVycyA9IHtcbiAgICAgIHVzZURlZmF1bHQ6IGZhbHNlLFxuICAgICAgb3ZlcnJpZGVzOiByZW1pbmRlcnMubWFwKG1pbnV0ZXMgPT4gKHtcbiAgICAgICAgbWV0aG9kOiAncG9wdXAnLFxuICAgICAgICBtaW51dGVzOiBtaW51dGVzXG4gICAgICB9KSlcbiAgICB9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxlbmRhci5ldmVudHMuaW5zZXJ0KHtcbiAgICAgIGNhbGVuZGFySWQ6ICdwcmltYXJ5JyxcbiAgICAgIHJlc291cmNlOiBldmVudCxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGV2ZW50OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBhIGNhbGVuZGFyIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50SWQgLSBJRCBvZiB0aGUgZXZlbnQgdG8gZGVsZXRlIFxuICogQHBhcmFtIHtzdHJpbmd9IGNhbGVuZGFySWQgLSBDYWxlbmRhciBJRCAoZGVmYXVsdHMgdG8gJ3ByaW1hcnknKVxuICogQHJldHVybnMge09iamVjdH0gLSBEZWxldGVkIGV2ZW50IHN1bW1hcnlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ2FsZW5kYXJFdmVudCh0b2tlbnMsIGV2ZW50SWQsIGNhbGVuZGFySWQgPSAncHJpbWFyeScpIHtcbiAgLy8gVmFsaWRhdGUgaW5wdXRzXG4gIGlmICghdG9rZW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPQXV0aCB0b2tlbnMgYXJlIHJlcXVpcmVkJyk7XG4gIH1cbiAgXG4gIGlmICghZXZlbnRJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgSUQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBcbiAgY29uc3Qgb2F1dGgyQ2xpZW50ID0gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucyk7XG4gIGNvbnN0IGNhbGVuZGFyID0gZ29vZ2xlLmNhbGVuZGFyKHsgdmVyc2lvbjogJ3YzJywgYXV0aDogb2F1dGgyQ2xpZW50IH0pO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBGaXJzdCBnZXQgdGhlIGV2ZW50IHRvIHJldHVybiBpdHMgc3VtbWFyeSBhZnRlciBkZWxldGlvblxuICAgIGxldCBldmVudFN1bW1hcnkgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudCA9IGF3YWl0IGNhbGVuZGFyLmV2ZW50cy5nZXQoe1xuICAgICAgICBjYWxlbmRhcklkOiBjYWxlbmRhcklkLFxuICAgICAgICBldmVudElkOiBldmVudElkLFxuICAgICAgfSk7XG4gICAgICBldmVudFN1bW1hcnkgPSBldmVudC5kYXRhLnN1bW1hcnk7XG4gICAgfSBjYXRjaCAoZ2V0RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHJldHJpZXZlIGV2ZW50IGRldGFpbHMgYmVmb3JlIGRlbGV0aW9uOiAke2dldEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIGF3YWl0IGNhbGVuZGFyLmV2ZW50cy5kZWxldGUoe1xuICAgICAgY2FsZW5kYXJJZDogY2FsZW5kYXJJZCxcbiAgICAgIGV2ZW50SWQ6IGV2ZW50SWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgc3VtbWFyeTogZXZlbnRTdW1tYXJ5LCBldmVudElkOiBldmVudElkIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgZXZlbnQgJHtldmVudElkfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UsIGV2ZW50SWQ6IGV2ZW50SWQgfTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIGNhbGVuZGFyIGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5zIC0gVXNlcidzIE9BdXRoIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50SWQgLSBJRCBvZiB0aGUgZXZlbnQgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcyAtIE9iamVjdCBjb250YWluaW5nIGZpZWxkcyB0byB1cGRhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gVXBkYXRlZCBldmVudCBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUNhbGVuZGFyRXZlbnQodG9rZW5zLCBldmVudElkLCB1cGRhdGVzKSB7XG4gIGNvbnN0IG9hdXRoMkNsaWVudCA9IGNyZWF0ZU9BdXRoMkNsaWVudCh0b2tlbnMpO1xuICBjb25zdCBjYWxlbmRhciA9IGdvb2dsZS5jYWxlbmRhcih7IHZlcnNpb246ICd2MycsIGF1dGg6IG9hdXRoMkNsaWVudCB9KTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gRmlyc3QgZ2V0IHRoZSBjdXJyZW50IGV2ZW50XG4gICAgY29uc3QgY3VycmVudEV2ZW50ID0gYXdhaXQgY2FsZW5kYXIuZXZlbnRzLmdldCh7XG4gICAgICBjYWxlbmRhcklkOiAncHJpbWFyeScsXG4gICAgICBldmVudElkOiBldmVudElkLFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFByZXBhcmUgdGhlIHVwZGF0ZSBwYXlsb2FkXG4gICAgY29uc3QgdXBkYXRlZEV2ZW50ID0geyAuLi5jdXJyZW50RXZlbnQuZGF0YSB9O1xuICAgIFxuICAgIGlmICh1cGRhdGVzLnN1bW1hcnkpIHVwZGF0ZWRFdmVudC5zdW1tYXJ5ID0gdXBkYXRlcy5zdW1tYXJ5O1xuICAgIGlmICh1cGRhdGVzLmRlc2NyaXB0aW9uKSB1cGRhdGVkRXZlbnQuZGVzY3JpcHRpb24gPSB1cGRhdGVzLmRlc2NyaXB0aW9uO1xuICAgIGlmICh1cGRhdGVzLmxvY2F0aW9uKSB1cGRhdGVkRXZlbnQubG9jYXRpb24gPSB1cGRhdGVzLmxvY2F0aW9uO1xuICAgIFxuICAgIGlmICh1cGRhdGVzLnN0YXJ0KSB7XG4gICAgICB1cGRhdGVkRXZlbnQuc3RhcnQgPSB7XG4gICAgICAgIGRhdGVUaW1lOiB1cGRhdGVzLnN0YXJ0LFxuICAgICAgICB0aW1lWm9uZTogY3VycmVudEV2ZW50LmRhdGEuc3RhcnQudGltZVpvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGlmICh1cGRhdGVzLmVuZCkge1xuICAgICAgdXBkYXRlZEV2ZW50LmVuZCA9IHtcbiAgICAgICAgZGF0ZVRpbWU6IHVwZGF0ZXMuZW5kLFxuICAgICAgICB0aW1lWm9uZTogY3VycmVudEV2ZW50LmRhdGEuZW5kLnRpbWVab25lXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdGhlIGV2ZW50XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2FsZW5kYXIuZXZlbnRzLnVwZGF0ZSh7XG4gICAgICBjYWxlbmRhcklkOiAncHJpbWFyeScsXG4gICAgICBldmVudElkOiBldmVudElkLFxuICAgICAgcmVzb3VyY2U6IHVwZGF0ZWRFdmVudCxcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcmVzLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZXZlbnQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVPQXV0aDJDbGllbnQsXG4gIGdldENhbGVuZGFyRXZlbnRzLFxuICBhZGRDYWxlbmRhckV2ZW50LFxuICBkZWxldGVDYWxlbmRhckV2ZW50LFxuICB1cGRhdGVDYWxlbmRhckV2ZW50XG59O1xuIl0sIm5hbWVzIjpbImdvb2dsZSIsInJlcXVpcmUiLCJPQXV0aDJDbGllbnQiLCJjcmVhdGVPQXV0aDJDbGllbnQiLCJ0b2tlbnMiLCJjcmVkZW50aWFscyIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRfaWQiLCJyZWRpcmVjdF91cmlzIiwid2ViIiwib2F1dGgyQ2xpZW50IiwiYWNjZXNzX3Rva2VuIiwic2V0Q3JlZGVudGlhbHMiLCJyZWZyZXNoX3Rva2VuIiwidG9rZW5fdHlwZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwiZ2V0Q2FsZW5kYXJFdmVudHMiLCJzdGFydF9kYXRlIiwiZW5kX2RhdGUiLCJjYWxlbmRhciIsInZlcnNpb24iLCJhdXRoIiwicmVzIiwiZXZlbnRzIiwibGlzdCIsImNhbGVuZGFySWQiLCJ0aW1lTWluIiwidG9JU09TdHJpbmciLCJ0aW1lTWF4Iiwic2luZ2xlRXZlbnRzIiwib3JkZXJCeSIsImRhdGEiLCJpdGVtcyIsImFkZENhbGVuZGFyRXZlbnQiLCJzdW1tYXJ5Iiwic3RhcnQiLCJlbmQiLCJkZXNjcmlwdGlvbiIsImxvY2F0aW9uIiwicmVtaW5kZXJzIiwiZXZlbnQiLCJkYXRlVGltZSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInVzZURlZmF1bHQiLCJvdmVycmlkZXMiLCJtYXAiLCJtaW51dGVzIiwibWV0aG9kIiwiaW5zZXJ0IiwicmVzb3VyY2UiLCJkZWxldGVDYWxlbmRhckV2ZW50IiwiZXZlbnRJZCIsImV2ZW50U3VtbWFyeSIsImdldCIsImdldEVycm9yIiwid2FybiIsIm1lc3NhZ2UiLCJkZWxldGUiLCJzdWNjZXNzIiwidXBkYXRlQ2FsZW5kYXJFdmVudCIsInVwZGF0ZXMiLCJjdXJyZW50RXZlbnQiLCJ1cGRhdGVkRXZlbnQiLCJ0aW1lWm9uZSIsInVwZGF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./googleCalendar.js\n");

/***/ }),

/***/ "(api)/./lib/chatbot.js":
/*!************************!*\
  !*** ./lib/chatbot.js ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ chat),\n/* harmony export */   getConversationsByUserId: () => (/* reexport safe */ _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getConversationsByUserId),\n/* harmony export */   listTodaysEvents: () => (/* reexport safe */ _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__.listTodaysEvents),\n/* harmony export */   suggestEventTime: () => (/* reexport safe */ _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__.suggestEventTime)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai */ \"openai\");\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-cache */ \"node-cache\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dotenv/config */ \"dotenv/config\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dotenv_config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _data_prompts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/prompts.js */ \"(api)/./lib/data/prompts.js\");\n/* harmony import */ var _tools_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools/schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\n/* harmony import */ var _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tools/eventHelpers.js */ \"(api)/./lib/tools/eventHelpers.js\");\n/* harmony import */ var _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tools/toolIndex.js */ \"(api)/./lib/tools/toolIndex.js\");\n/* harmony import */ var _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./postgresClient.js */ \"(api)/./lib/postgresClient.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([openai__WEBPACK_IMPORTED_MODULE_0__, luxon__WEBPACK_IMPORTED_MODULE_1__, _tools_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__, _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__]);\n([openai__WEBPACK_IMPORTED_MODULE_0__, luxon__WEBPACK_IMPORTED_MODULE_1__, _tools_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _tools_eventHelpers_js__WEBPACK_IMPORTED_MODULE_6__, _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// lib/chatbot.js\n// --- IMPORTS ---\n\n\n\n\n// Local Modules\n// Import system prompt\n\n\n\n\n\n// Weather client function (if used)\n// import { getWeatherData } from './weatherClient.js'; // Example path\n// Google APIs library (needed for direct calls in tool functions like delete/update)\n// **FIX:** Use import instead of require for consistency if possible (depends on project setup)\n// If using ES modules: import { google } from 'googleapis';\n// If require is necessary:\nconst { google } = __webpack_require__(/*! googleapis */ \"googleapis\"); // Keep require if necessary for googleapis\n// --- Database Initialization ---\n// (Keep the getDatabaseInitPromise function as is)\nlet dbInitPromise = null;\n// Initialize OpenAI client\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    apiKey: process.env.OPENAI_API_KEY\n});\n// Create a global variable to store the current responseCallback\nglobal.currentResponseCallback = null;\n// Create a global variable to store pending event data\nglobal.pendingEventData = null;\n// --- Helper Functions (Formatting & Time) ---\nfunction formatEventTime(eventTime) {\n    try {\n        const dt = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(eventTime);\n        if (dt.isValid) {\n            return dt.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATETIME_FULL);\n        }\n        const dateOnly = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(eventTime, {\n            zone: \"utc\"\n        });\n        if (dateOnly.isValid) {\n            return dateOnly.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATE_FULL) + \" (All day)\";\n        }\n        return eventTime;\n    } catch (e) {\n        console.warn(\"Error formatting event time:\", eventTime, e);\n        return String(eventTime); // Ensure returns string\n    }\n}\nfunction formatCalendarEvents(events) {\n    if (!events) return \"No events found or an error occurred.\";\n    if (!Array.isArray(events)) return \"An error occurred processing events.\";\n    if (events.length === 0) return \"No events found for the specified time period.\";\n    return events.map((event)=>{\n        try {\n            const start = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n            const end = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n            if (!start.isValid || !end.isValid) return `â“ Invalid date found for event: ${event.summary || event.id}`;\n            const isAllDay = !event.start?.dateTime;\n            // Include the event ID in the formatted output (hidden with a zero-width space for reference)\n            let formattedEvent = `ðŸ“… ${event.summary || \"(No Title)\"} [ID:â€‹${event.id}]\\n`;\n            formattedEvent += `   ðŸ“† ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATE_FULL)}\\n`;\n            if (!isAllDay) {\n                formattedEvent += `   ðŸ•’ ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.TIME_SIMPLE)} - ${end.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.TIME_SIMPLE)}\\n`;\n            } else {\n                formattedEvent += `   ðŸ•’ All Day\\n`;\n            }\n            if (event.description) formattedEvent += `   ðŸ“ ${event.description}\\n`;\n            if (event.location) formattedEvent += `   ðŸ“ ${event.location}\\n`;\n            if (event.reminders?.useDefault === false && Array.isArray(event.reminders.overrides)) {\n                formattedEvent += `   ðŸ”” Reminders: ${event.reminders.overrides.map((r)=>`${r.minutes} min`).join(\", \")}\\n`;\n            }\n            return formattedEvent.trim(); // Trim each event string\n        } catch (mapError) {\n            console.error(\"Error mapping event:\", event, mapError);\n            return `â“ Error processing event: ${event.summary || event.id}`;\n        }\n    }).join(\"\\n\\n\"); // Add space between events\n}\n// --- Formatting Tool Responses for the LLM ---\nfunction formatToolResponse(functionName, result) {\n    try {\n        // Explicitly handle null/undefined results first\n        if (result == null) {\n            console.warn(`Tool ${functionName} returned null or undefined.`);\n            return `Tool ${functionName} did not return a result. (Status: FAILED)`;\n        }\n        // Handle known error shapes returned by tool functions\n        if (typeof result === \"string\" && result.toLowerCase().startsWith(\"error:\")) return `${result} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.error) return `Error executing ${functionName}: ${result.error} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.success === false) return `Tool ${functionName} failed: ${result.message || \"No details.\"} (Status: FAILED)`;\n        // --- Format successful results ---\n        switch(functionName){\n            case \"saveUserPreference\":\n                return result.success ? `âœ… Pref saved: ${result.message} (Status: SUCCESS)` : `âŒ Pref fail: ${result.message} (Status: FAILED)`;\n            case \"addCalendarEvents\":\n                if (!Array.isArray(result)) return \"Error: Invalid response format from addCalendarEvents. (Status: FAILED)\";\n                if (result.length === 0) return \"No events were processed. (Status: NEUTRAL)\";\n                return result.map((item)=>{\n                    if (!item) return \"â“ Invalid item in result array. (Status: FAILED)\";\n                    if (item.error) {\n                        const summary = item.summary || \"?\";\n                        if (item.conflict) {\n                            // Include suggestions if available\n                            const suggestionText = item.suggestions && item.suggestions.length > 0 ? ` Suggested slots: ${item.suggestions.map((s)=>`${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(s.start).toFormat(\"h:mma\")} - ${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(s.end).toFormat(\"h:mma\")}`).join(\", \")}` : \"\";\n                            return `âš ï¸ Conflict detected for event \"${summary}\".${suggestionText} (Status: CONFLICT)`;\n                        } else {\n                            return `âŒ Failed to add event \"${summary}\": ${item.error} (Status: FAILED)`;\n                        }\n                    } else if (item.id && item.summary && (item.start?.dateTime || item.start?.date)) {\n                        try {\n                            const startStr = formatEventTime(item.start.dateTime || item.start.date); // Use existing helper\n                            return `âœ… Event added: \"${item.summary}\" starting ${startStr}. (ID: ${item.id}) (Status: SUCCESS)`;\n                        } catch (e) {\n                            console.error(\"Error formatting success message for added event:\", item, e);\n                            return `âœ… Event added: \"${item.summary}\" (details unavailable). (ID: ${item.id}) (Status: SUCCESS)`;\n                        }\n                    } else {\n                        console.warn(\"Unexpected item shape in addCalendarEvents result:\", item);\n                        return `â“ Unknown outcome for an event attempt. (Status: UNKNOWN)`;\n                    }\n                }).join(\"\\n\");\n            case \"getCalendarEvents\":\n                if (typeof result === \"string\") return `ðŸ—“ï¸ Events: ${result} (Status: ${result.toLowerCase().startsWith(\"error\") ? \"FAILED\" : \"SUCCESS\"})`;\n                if (!Array.isArray(result)) return \"Error: Invalid getCalendarEvents response. (Status: FAILED)\";\n                return result.length === 0 ? \"\\uD83D\\uDDD3ï¸ No events found. (Status: SUCCESS)\" : `ðŸ—“ï¸ Found ${result.length} event(s):\\n\\n${formatCalendarEvents(result)} (Status: SUCCESS)`;\n            case \"deleteCalendarEvent\":\n                return result.success ? `ðŸ—‘ï¸ Event \"${result.summary || result.eventId}\" deleted. (Status: SUCCESS)` // Use eventId if summary wasn't fetched/returned\n                 : `âŒ Failed to delete event ${result.eventId || \"?\"}: ${result.error || result.message || \"?\"} (Status: FAILED)`;\n            case \"updateCalendarEvent\":\n                // Check if result has an ID, indicating success from googleCalendar update function\n                if (result && result.id) {\n                    return `âœï¸ Event \"${result.summary || eventId}\" updated. (ID: ${result.id}) (Status: SUCCESS)`;\n                } else {\n                    // Handle potential error objects passed back\n                    const errorMsg = result?.error || result?.message || JSON.stringify(result);\n                    return `âŒ Failed to update event: ${errorMsg} (Status: FAILED)`;\n                }\n            case \"findAvailableSlots\":\n                if (!Array.isArray(result)) return \"Error: Invalid findAvailableSlots response. (Status: FAILED)\";\n                if (result.length === 0) return `ðŸ•’ No available slots found matching criteria. (Status: SUCCESS)`;\n                // Format slots with success status\n                const formattedSlots = result.map((slot)=>`${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(slot.start).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.DATETIME_SHORT)} - ${luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(slot.end).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.TIME_SIMPLE)}`).join(\"\\n\");\n                return `ðŸ•’ Found ${result.length} available slot(s):\\n\\n${formattedSlots}\\n\\n(Status: SUCCESS)`;\n            case \"getWeatherForecast\":\n                return `ðŸŒ¤ï¸ Weather for ${result.location} on ${result.date}: ${result.forecast || \"N/A\"} (Status: ${result.forecast && !result.forecast.includes(\"unavailable\") ? \"SUCCESS\" : \"PARTIAL\"})`;\n            case \"deleteCalendarEventsByQuery\":\n                return result.success ? `ðŸ—‘ï¸ ${result.message} (Deleted Count: ${result.deletedCount}) (Status: SUCCESS)` : `âŒ Failed bulk delete: ${result.message || result.error || \"?\"} (Status: FAILED)`;\n            default:\n                // Safely stringify other results with status indicators\n                if (typeof result === \"object\" && result !== null) {\n                    const status = result.success === true ? \"SUCCESS\" : result.success === false ? \"FAILED\" : \"UNKNOWN\";\n                    return `${JSON.stringify(result)} (Status: ${status})`;\n                } else {\n                    return `${String(result)} (Status: UNKNOWN)`;\n                }\n        }\n    } catch (formatError) {\n        console.error(`CRITICAL: Error *within* formatToolResponse for ${functionName}:`, formatError, \"Raw result:\", result);\n        // Return a guaranteed string error message\n        return `Internal Error: Failed to format the result for ${functionName}. (Status: ERROR)`;\n    }\n}\n// Helper function to process tool calls\nasync function processToolCalls(toolCalls, messages, conversationId, userId, accessToken, responseCallback) {\n    try {\n        console.log(`Processing ${toolCalls.length} tool calls`);\n        // Define isConversationalQuery at the function scope level so it's accessible throughout\n        let isConversationalQuery = false;\n        // Check if this is a purely conversational query by examining the original message\n        // This helps prevent showing processing cards for simple questions\n        const userMessage = messages.find((msg)=>msg.role === \"user\")?.content?.toLowerCase() || \"\";\n        isConversationalQuery = !userMessage.includes(\"calendar\") && !userMessage.includes(\"schedule\") && !userMessage.includes(\"event\") && !userMessage.includes(\"meeting\") && !userMessage.includes(\"appointment\") && !userMessage.includes(\"tomorrow\") && !userMessage.includes(\"today\") && !userMessage.includes(\"yesterday\") && !userMessage.match(/\\b(next|last|this)\\s+(week|month|year)\\b/) && !userMessage.match(/\\b\\d{1,2}(st|nd|rd|th)?\\b/);\n        // First ensure Analyzing Request is marked as complete\n        // This is now handled by the chat-stream.js file to avoid duplication\n        // Use Promise.allSettled for robustness\n        const toolPromises = toolCalls.map(async (toolCall)=>{\n            const toolCallId = toolCall.id;\n            const functionName = toolCall.function?.name;\n            let toolResponseContent = \"\";\n            try {\n                // 1. Basic Validation\n                if (!toolCallId || toolCall.type !== \"function\" || !functionName) {\n                    throw new Error(`Invalid tool call structure received: ${JSON.stringify(toolCall)}`);\n                }\n                if (!_tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__.toolFunctions[functionName]) {\n                    throw new Error(`Tool function \"${functionName}\" is not available.`);\n                }\n                // 2. Parse Arguments\n                let parsedArgs = {};\n                try {\n                    parsedArgs = JSON.parse(toolCall.function.arguments || \"{}\");\n                } catch (parseError) {\n                    throw new Error(`Invalid JSON arguments for ${functionName}. Args: ${toolCall.function.arguments}. Error: ${parseError.message}`);\n                }\n                // Send appropriate processing step based on the tool being used\n                if (responseCallback) {\n                    // Only send processing steps for non-conversational queries or specific tool functions\n                    let processingStepText = \"\";\n                    // Determine appropriate step text based on the function name\n                    if (functionName.includes(\"Calendar\") || functionName.includes(\"Event\")) {\n                        processingStepText = \"Fetching Calendar Data: ...\";\n                    } else if (functionName.includes(\"Weather\")) {\n                        processingStepText = \"Getting Weather Data: ...\";\n                    } else if (functionName.includes(\"Preference\")) {\n                        processingStepText = \"Updating User Preferences: ...\";\n                    } else {\n                        // Generic step for other tools\n                        processingStepText = `Using ${functionName.replace(/([A-Z])/g, \" $1\").trim()}: ...`;\n                    }\n                    // Send the appropriate processing step\n                    if (!isConversationalQuery || functionName.includes(\"Calendar\") || functionName.includes(\"Weather\")) {\n                        setTimeout(()=>{\n                            responseCallback({\n                                type: \"processing\",\n                                content: processingStepText\n                            });\n                        }, 500);\n                    }\n                }\n                // 3. Execute Tool Function\n                console.log(`Executing tool: ${functionName} (ID: ${toolCallId}) with args:`, parsedArgs);\n                const result = await _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__.toolFunctions[functionName](parsedArgs, userId, accessToken);\n                console.log(`Tool ${functionName} (ID: ${toolCallId}) raw result:`, result);\n                // 4. Format Result\n                toolResponseContent = formatToolResponse(functionName, result);\n                console.log(`Tool ${functionName} (ID: ${toolCallId}) formatted response:`, toolResponseContent);\n                // Store event data for later use\n                if (functionName === \"getCalendarEvents\" && Array.isArray(result) && result.length > 0) {\n                    global.pendingEventData = result;\n                // Don't send events here, wait for the final response\n                }\n                // Send completion notification for the appropriate step\n                if (responseCallback) {\n                    // Determine the completion step text based on the function name\n                    let completionStepText = \"\";\n                    if (functionName.includes(\"Calendar\") || functionName.includes(\"Event\")) {\n                        completionStepText = \"Fetching Calendar Data: âœ“\";\n                    } else if (functionName.includes(\"Weather\")) {\n                        completionStepText = \"Getting Weather Data: âœ“\";\n                    } else if (functionName.includes(\"Preference\")) {\n                        completionStepText = \"Updating User Preferences: âœ“\";\n                    } else {\n                        // Generic step for other tools\n                        completionStepText = `Using ${functionName.replace(/([A-Z])/g, \" $1\").trim()}: âœ“`;\n                    }\n                    // Add appropriate delay based on the tool\n                    if (!isConversationalQuery || functionName.includes(\"Calendar\") || functionName.includes(\"Weather\")) {\n                        const delay = functionName.includes(\"Calendar\") ? 2000 : 1500;\n                        setTimeout(()=>{\n                            responseCallback({\n                                type: \"processing\",\n                                content: completionStepText\n                            });\n                            // Then quickly start the next step to show how fast the system is\n                            setTimeout(()=>{\n                                responseCallback({\n                                    type: \"processing\",\n                                    content: `Generating Response: ...`\n                                });\n                                // Quickly complete it to demonstrate speed\n                                setTimeout(()=>{\n                                    responseCallback({\n                                        type: \"processing\",\n                                        content: `Generating Response: âœ“`\n                                    });\n                                }, 800); // Quick completion of Generating Response\n                            }, 300); // Very quick transition to Generating Response\n                        }, delay); // Appropriate delay based on the tool\n                    }\n                }\n                // Add a success indicator to the tool response for context tracking\n                let successIndicator = \"\";\n                if (functionName === \"deleteCalendarEvent\" && result.success) {\n                    successIndicator = \"\\n\\n[âœ… Event successfully deleted]\";\n                } else if (functionName === \"addCalendarEvent\" && result.id) {\n                    successIndicator = \"\\n\\n[âœ… Event successfully added]\";\n                } else if (functionName === \"updateCalendarEvent\" && result.id) {\n                    successIndicator = \"\\n\\n[âœ… Event successfully updated]\";\n                }\n                // Add success indicator to the response if applicable\n                return {\n                    status: \"fulfilled\",\n                    value: {\n                        role: \"tool\",\n                        content: toolResponseContent + successIndicator,\n                        tool_call_id: toolCallId\n                    }\n                };\n            } catch (error) {\n                console.error(`ERROR processing tool call ${toolCallId} (${functionName || \"?\"}):`, error);\n                toolResponseContent = `Error processing tool ${functionName || \"?\"}: ${error.message || error}`;\n                return {\n                    status: \"rejected\",\n                    reason: error,\n                    value: {\n                        role: \"tool\",\n                        content: toolResponseContent,\n                        tool_call_id: toolCallId\n                    }\n                };\n            }\n        });\n        const settledToolResults = await Promise.allSettled(toolPromises);\n        const toolResponses = settledToolResults.map((settledResult)=>{\n            if (settledResult.status === \"fulfilled\") {\n                return settledResult.value.value;\n            } else {\n                return settledResult.reason.value;\n            }\n        }).filter(Boolean);\n        // Add tool responses to history\n        messages.push(...toolResponses);\n        // Store tool responses in DB (best effort, loop through results)\n        if (conversationId) {\n            try {\n                // Use Promise.all to store all tool responses in parallel\n                await Promise.all(toolResponses.map((toolMsg)=>(0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversationId, \"tool\", toolMsg.content, {\n                        tool_call_id: toolMsg.tool_call_id\n                    }).catch((dbError)=>{\n                        console.error(`DB Error storing tool response ${toolMsg.tool_call_id}:`, dbError);\n                        // Don't throw, allow other messages to be stored\n                        return null;\n                    })));\n                console.log(`Stored ${toolResponses.length} tool responses in database`);\n            } catch (batchError) {\n                console.error(`Error in batch storing tool responses:`, batchError);\n            // Individual errors are already caught in the map function\n            // This catch is for errors outside the individual promises\n            }\n        }\n        return toolResponses;\n    } catch (error) {\n        console.error(\"FATAL Error in runConversation pipeline:\", error);\n        // Log history specifically for 400 errors to help debug sequence issues\n        if (error.status === 400) {\n            console.error(\"Message history at time of 400 error:\", JSON.stringify(messages, null, 2));\n        }\n        responseCallback?.({\n            type: \"error\",\n            content: `An error occurred: ${error.message || \"Check server logs.\"}`\n        });\n        throw error; // Re-throw\n    }\n}\nasync function runConversation(messages, userInput, conversationId = null, userId = \"default\", accessToken = null, responseCallback = null) {\n    console.log(`Running conversation ${conversationId} for user ${userId}. AccessToken: ${!!accessToken}`);\n    const model = \"gpt-4o\"; // Use a capable model for reasoning\n    const maxToolIterations = 5; // Limit sequential tool calls to prevent infinite loops\n    try {\n        let currentMessages = [\n            ...messages\n        ]; // Use a mutable copy for this turn\n        let iteration = 0;\n        let finalContent = null; // Stores the final text response for the user\n        // Helper to filter messages (Keep existing filterMessagesForAPI)\n        const filterMessagesForAPI = (msgs)=>{\n            // ... (keep existing implementation) ...\n            if (!msgs || !Array.isArray(msgs)) {\n                console.error(\"Invalid messages array passed to filter:\", msgs);\n                return []; // Return empty array to prevent further errors\n            }\n            // Create a copy to avoid modifying the original\n            const filteredMsgs = [\n                ...msgs\n            ];\n            // Track tool call IDs from assistant messages\n            const validToolCallIds = new Set();\n            // First pass: collect all valid tool call IDs from assistant messages\n            filteredMsgs.forEach((msg)=>{\n                if (msg.role === \"assistant\" && msg.tool_calls && Array.isArray(msg.tool_calls)) {\n                    msg.tool_calls.forEach((toolCall)=>{\n                        if (toolCall.id) {\n                            validToolCallIds.add(toolCall.id);\n                        }\n                    });\n                }\n            });\n            // Second pass: filter out invalid tool messages\n            const result = filteredMsgs.filter((msg, index)=>{\n                // Keep all non-tool messages\n                if (msg.role !== \"tool\") return true;\n                // For tool messages, check if they have a valid tool_call_id\n                if (!msg.tool_call_id) {\n                    console.warn(`Filtering TOOL message with missing tool_call_id at index ${index}`);\n                    return false;\n                }\n                // Check if this tool message has a corresponding tool call from an assistant\n                if (!validToolCallIds.has(msg.tool_call_id)) {\n                    console.warn(`Filtering TOOL message not correctly preceded by assistant tool_call. Index=${index}, ToolCallID=${msg.tool_call_id}`);\n                    return false;\n                }\n                // Also ensure content exists for tool messages\n                if (msg.content == null || msg.content === \"\") {\n                    console.warn(`Filtering TOOL message with missing/empty content. Index=${index}, ToolCallID=${msg.tool_call_id}`);\n                    return false;\n                }\n                return true;\n            });\n            // Final sanity check: Ensure alternating user/assistant/tool sequence where appropriate\n            // Remove consecutive messages of the same role (except 'tool' which follows 'assistant')\n            const finalFiltered = [];\n            for(let i = 0; i < result.length; i++){\n                const currentMsg = result[i];\n                const prevMsg = finalFiltered[finalFiltered.length - 1];\n                if (prevMsg && currentMsg.role === prevMsg.role && currentMsg.role !== \"tool\") {\n                    console.warn(`Filtering consecutive message of role ${currentMsg.role} at index ${i}`);\n                    continue; // Skip adding the consecutive message\n                }\n                // Ensure tool message follows an assistant message (loosely, filter handles specific ID matching)\n                // if (currentMsg.role === 'tool' && (!prevMsg || prevMsg.role !== 'assistant')) {\n                //     console.warn(`Filtering TOOL message not following an assistant message at index ${i}`);\n                //     continue; // Skip adding the out-of-place tool message\n                // }\n                finalFiltered.push(currentMsg);\n            }\n            console.log(`Filtered ${msgs.length - finalFiltered.length} invalid/malformed messages`);\n            return finalFiltered;\n        };\n        // --- Main Reasoning Loop ---\n        while(iteration < maxToolIterations){\n            iteration++;\n            console.log(`\\n--- Conversation Turn ${iteration}/${maxToolIterations} ---`);\n            const messagesForAPI = filterMessagesForAPI(currentMessages);\n            if (messagesForAPI.length === 0) {\n                console.error(\"Message history became empty during filtering.\");\n                throw new Error(\"Internal error: Cannot proceed with empty message history.\");\n            }\n            // ***** DEBUG LOG *****\n            console.log(`Making API call #${iteration} with model: ${model}`);\n            console.log(`Message History (Length: ${messagesForAPI.length}):`);\n            messagesForAPI.forEach((msg, index)=>{\n                console.log(`  [${index}] Role: ${msg.role}`);\n                if (msg.content) console.log(`      Content: ${String(msg.content).substring(0, 100)}...`); // Truncate, ensure string\n                if (msg.tool_calls) console.log(`      Tool Calls: ${JSON.stringify(msg.tool_calls.map((tc)=>tc.id + \":\" + tc.function?.name))}`);\n                if (msg.tool_call_id) console.log(`      Tool Call ID: ${msg.tool_call_id}`);\n            });\n            console.log(`--- End API Call #${iteration} History --- \\n`);\n            // ***** END DEBUG LOG *****\n            // --- Call OpenAI ---\n            const response = await openai.chat.completions.create({\n                model: model,\n                messages: messagesForAPI,\n                tools: _tools_toolIndex_js__WEBPACK_IMPORTED_MODULE_7__.tools,\n                tool_choice: \"auto\"\n            });\n            const responseMessage = response.choices[0].message;\n            // --- Add Assistant Message to History (Local & DB) ---\n            currentMessages.push(responseMessage);\n            if (conversationId) {\n                try {\n                    await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversationId, \"assistant\", responseMessage.content || null, {\n                        tool_calls: responseMessage.tool_calls || null\n                    } // Always pass an object, even if tool_calls is null\n                    );\n                } catch (dbError) {\n                    console.error(`DB Error storing assistant message (iteration ${iteration}):`, dbError);\n                // Continue even if DB store fails for this message\n                }\n            }\n            // --- Check for Tool Calls ---\n            const assistantToolCalls = responseMessage.tool_calls;\n            if (assistantToolCalls && assistantToolCalls.length > 0) {\n                console.log(`Assistant requested ${assistantToolCalls.length} tool call(s) in iteration ${iteration}:`, JSON.stringify(assistantToolCalls.map((tc)=>({\n                        id: tc.id,\n                        name: tc.function?.name\n                    }))));\n                // Inform client we're processing with more specific information\n                // --- Process the requested tools ---\n                // processToolCalls adds the tool responses to currentMessages and stores them in DB\n                const toolResponses = await processToolCalls(assistantToolCalls, currentMessages, conversationId, userId, accessToken, responseCallback);\n                // Check if any tool call failed critically, maybe stop early? (Optional enhancement)\n                const hasCriticalFailure = toolResponses.some((tr)=>tr.content?.includes(\"(Status: FAILED)\"));\n                if (hasCriticalFailure) {\n                    console.warn(`Critical tool failure detected in iteration ${iteration}. LLM will be informed.`);\n                // Let the loop continue, LLM should see the failure message\n                }\n            // --- Loop continues: Send tool results back to LLM ---\n            } else {\n                // --- No Tool Calls: This is the final response ---\n                console.log(`No tool calls requested in iteration ${iteration}. Final response generated.`);\n                // For general questions (no tool calls), go directly from \"Analyzing Request\" to \"Generating Response\"\n                // Mark \"Generating Response\" as complete before sending the final content\n                if (responseCallback && iteration > 1) {\n                // Send completion immediately to ensure it's marked before the response is shown\n                // This is now handled in the tool processing section with specific timing for tool calls\n                // For non-tool calls, it's handled in the else block above\n                }\n                finalContent = responseMessage.content ?? \"\"; // Use nullish coalescing for safety\n                break; // Exit the loop\n            }\n        } // End of while loop\n        // --- Handle loop exit ---\n        if (iteration >= maxToolIterations) {\n            console.warn(`Maximum tool iterations (${maxToolIterations}) reached. Returning last generated content or error.`);\n            // Attempt to return the last content generated, even if it wasn't intended as final\n            const lastAssistantMsg = currentMessages[currentMessages.length - 1];\n            if (lastAssistantMsg?.role === \"assistant\" && lastAssistantMsg.content) {\n                finalContent = lastAssistantMsg.content;\n            } else {\n                finalContent = \"I seem to be stuck in a loop trying to process that request. Could you try rephrasing it?\";\n                responseCallback?.({\n                    type: \"error\",\n                    content: finalContent\n                });\n            }\n        }\n        if (finalContent === null) {\n            console.error(\"Loop finished without generating final content.\");\n            finalContent = \"Sorry, I wasn't able to generate a final response after processing your request.\";\n            responseCallback?.({\n                type: \"error\",\n                content: finalContent\n            });\n        }\n        // --- Stream the FINAL response ---\n        if (responseCallback && finalContent) {\n            // Ensure \"Generating Response\" is marked as complete before sending content\n            // This is now handled earlier with a delay\n            // Check if we have pending event data to send\n            if (global.pendingEventData) {\n                // Add a delay before sending the final content to ensure all processing steps are visible\n                await new Promise((resolve)=>setTimeout(resolve, 1200));\n                // Send the event data\n                responseCallback({\n                    type: \"events\",\n                    content: finalContent,\n                    events: global.pendingEventData\n                });\n                // Clear the pending event data\n                global.pendingEventData = null;\n                // Short delay before end\n                await new Promise((resolve)=>setTimeout(resolve, 50));\n                responseCallback({\n                    type: \"end\"\n                });\n            } else {\n                // Add a small delay before sending content to ensure all processing steps are visible and marked complete\n                await new Promise((resolve)=>setTimeout(resolve, 1200));\n                responseCallback({\n                    type: \"content\",\n                    content: finalContent\n                });\n                await new Promise((resolve)=>setTimeout(resolve, 50)); // Short delay before end\n                responseCallback({\n                    type: \"end\"\n                });\n            }\n        } else if (!responseCallback && finalContent) {\n            // Non-streaming mode: return the final content\n            return finalContent;\n        } else if (!finalContent) {\n            // Ensure something is returned/sent even if content is empty/null\n            if (responseCallback) {\n                responseCallback({\n                    type: \"content\",\n                    content: \"\"\n                }); // Send empty content\n                responseCallback({\n                    type: \"end\"\n                });\n            }\n            return \"\";\n        }\n        console.log(\"Final response content:\", finalContent);\n        // The function implicitly returns finalContent if not streaming, or handles streaming via callback\n        return finalContent; // Return for non-streaming case\n    } catch (error) {\n        console.error(\"FATAL Error in runConversation pipeline:\", error);\n        if (error.status === 400) {\n            console.error(\"Message history at time of 400 error:\", JSON.stringify(messages, null, 2)); // Log initial history state\n        }\n        // Ensure error is propagated to the client\n        const errorMessage = `An error occurred: ${error.message || \"Check server logs.\"}`;\n        responseCallback?.({\n            type: \"error\",\n            content: errorMessage\n        });\n        // Throw or return error string based on expected caller behavior\n        // throw error; // Re-throwing might be better for chat() function to catch\n        return errorMessage; // Or return error string for non-streaming\n    }\n}\n// --- Helper function to format user preferences ---\nfunction formatUserPreferences(preferencesData) {\n    // Handle the case where preferencesData might be a Sequelize model instance\n    // or might have a dataValues property\n    let actualPrefsData = preferencesData;\n    // If it's a Sequelize model instance with dataValues\n    if (preferencesData && typeof preferencesData === \"object\" && preferencesData.dataValues) {\n        actualPrefsData = preferencesData.dataValues;\n        console.log(\"DEBUG: Using dataValues from preferencesData object\");\n    }\n    // Log the actual data we're working with\n    console.log(\"DEBUG: Actual preferences data to format:\", JSON.stringify(actualPrefsData));\n    // Check if we have valid data to format\n    if (!preferencesData || Object.keys(preferencesData).length === 0) {\n        console.log(\"DEBUG: formatUserPreferences called with empty or undefined preferencesData:\", JSON.stringify(preferencesData));\n        return \"\";\n    }\n    try {\n        // Format preferences as a clear, human-readable string\n        let prefsString = \"\\n\\nUser Preferences Context (Consider when relevant):\\n\";\n        prefsString += JSON.stringify(actualPrefsData, null, 2);\n        console.log(\"DEBUG: Formatted preferences string:\", prefsString);\n        return prefsString;\n    } catch (error) {\n        console.error(\"Error formatting user preferences:\", error);\n        return \"\"; // Return empty string on error\n    }\n}\n// --- Main Chat Entry Point ---\nasync function chat(userInput, userId = \"default\", accessToken = null, streamCallback = null, startNewConversation = false) {\n    console.log(`Chat request: User=${userId}, Input=\"${userInput}\", StartNew=${startNewConversation}`); // Log the flag\n    // Store the streamCallback in the global variable\n    global.currentResponseCallback = streamCallback;\n    if (!userId || userId === \"default\") {\n        streamCallback?.({\n            type: \"error\",\n            content: \"User ID missing.\"\n        });\n        return \"Error: User ID required.\";\n    }\n    if (!userInput?.trim()) {\n        streamCallback?.({\n            type: \"info\",\n            content: \"Enter a message.\"\n        });\n        return \"\";\n    }\n    // Send 'start' signal immediately for streaming\n    streamCallback?.({\n        type: \"start\"\n    });\n    try {\n        const tokens = accessToken ? {\n            access_token: accessToken\n        } : null;\n        let user;\n        let conversation;\n        let historyMessages = []; // Formatted history for OpenAI API\n        // --- Load User & Conversation History ---\n        if (!startNewConversation) {\n            try {\n                // **FIX:** Use the optimized query\n                user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getUserWithLatestConversation)(userId);\n                if (user?.Conversations?.length > 0) {\n                    conversation = user.Conversations[0];\n                    console.log(`Found active conversation ${conversation.conversation_id}`);\n                    if (conversation.ConversationMessages?.length > 0) {\n                        // Sort ASCENDING for API\n                        conversation.ConversationMessages.sort((a, b)=>a.sequence_number - b.sequence_number);\n                        // **CRITICAL FIX: Robust History Mapping**\n                        historyMessages = conversation.ConversationMessages.map((msg, index, allMsgs)=>{\n                            const messageObject = {\n                                role: msg.role\n                            };\n                            // Content: Mandatory unless assistant w/ tool calls\n                            if (msg.content != null) {\n                                messageObject.content = msg.content;\n                            } else if (msg.role === \"assistant\" && msg.tool_calls) {\n                                // Check if tool_calls field actually contains valid calls\n                                let validToolCallsExist = false;\n                                if (msg.tool_calls.tool_calls && Array.isArray(msg.tool_calls.tool_calls) && msg.tool_calls.tool_calls.length > 0) {\n                                    validToolCallsExist = msg.tool_calls.tool_calls.some((tc)=>tc.id && tc.function?.name);\n                                } else if (Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {\n                                    validToolCallsExist = msg.tool_calls.some((tc)=>tc.id && tc.function?.name);\n                                }\n                                if (validToolCallsExist) {\n                                    messageObject.content = null; // API expects null/\"\" if only tool_calls\n                                } else {\n                                    messageObject.content = \"\"; // Treat as empty content if tool_calls invalid/empty\n                                }\n                            } else {\n                                messageObject.content = \"\"; // Default empty string\n                            }\n                            // Tool Calls (Assistant): Extract the array\n                            if (msg.role === \"assistant\" && msg.tool_calls) {\n                                let toolCallsArray = null;\n                                // Case 1: Stored as { tool_calls: [...] }\n                                if (msg.tool_calls.tool_calls && Array.isArray(msg.tool_calls.tool_calls)) {\n                                    toolCallsArray = msg.tool_calls.tool_calls;\n                                // Case 2: Stored as [...] (fallback)\n                                } else if (Array.isArray(msg.tool_calls)) {\n                                    toolCallsArray = msg.tool_calls;\n                                }\n                                // Add ONLY if valid and non-empty\n                                if (toolCallsArray && toolCallsArray.length > 0) {\n                                    const validToolCalls = toolCallsArray.filter((tc)=>tc.id && tc.type === \"function\" && tc.function?.name);\n                                    if (validToolCalls.length > 0) {\n                                        messageObject.tool_calls = validToolCalls;\n                                        // Re-ensure content is null if ONLY tool calls\n                                        if (messageObject.content === \"\" && validToolCalls.length === toolCallsArray.length) {\n                                            messageObject.content = null;\n                                        }\n                                    } else {\n                                        console.warn(`DB message ${msg.message_id} had tool_calls object but no valid calls.`);\n                                    // Don't add empty/invalid tool_calls array to API message\n                                    }\n                                }\n                            }\n                            // Tool Call ID (Tool): Extract the ID string\n                            if (msg.role === \"tool\") {\n                                let toolId = null;\n                                // Case 1: Stored as { tool_call_id: \"...\" }\n                                if (typeof msg.tool_call_id === \"object\" && msg.tool_call_id !== null && msg.tool_call_id.tool_call_id) {\n                                    toolId = msg.tool_call_id.tool_call_id;\n                                // Case 2: Stored as \"...\" (fallback)\n                                } else if (typeof msg.tool_call_id === \"string\") {\n                                    toolId = msg.tool_call_id;\n                                }\n                                // Tool message MUST have ID and content to be valid for API\n                                if (toolId && messageObject.content != null) {\n                                    messageObject.tool_call_id = toolId;\n                                } else {\n                                    console.warn(`Filtering invalid TOOL message (missing ID or content): DB_ID=${msg.message_id}`);\n                                    return null; // Filter out invalid tool message\n                                }\n                            }\n                            // API Validation Check: tool role must follow assistant role with tool_calls\n                            // **REMOVED STRICT PRECEDING CHECK** - Relying on filterMessagesForAPI inside runConversation\n                            // if (messageObject.role === 'tool') {\n                            //     const prevMappedMessage = index > 0 ? historyMessages[index - 1] : null; // Check the *mapped* previous message\n                            //     if (!prevMappedMessage || prevMappedMessage.role !== 'assistant' || !prevMappedMessage.tool_calls || !prevMappedMessage.tool_calls.some(tc => tc.id === messageObject.tool_call_id)) {\n                            //          console.warn(`Filtering TOOL message not correctly preceded by assistant tool_call. DB_ID=${msg.message_id}, ToolCallID=${messageObject.tool_call_id}`);\n                            //          return null; // Filter out orphaned/mismatched tool message\n                            //     }\n                            // }\n                            // Filter out assistant messages that end up empty (no content, no valid tool calls)\n                            if (messageObject.role === \"assistant\" && messageObject.content == null && !messageObject.tool_calls) {\n                                console.warn(`Filtering empty ASSISTANT message. DB_ID=${msg.message_id}`);\n                                return null;\n                            }\n                            return messageObject;\n                        }).filter(Boolean); // Remove nulls from filtering\n                        console.log(`Loaded and mapped ${historyMessages.length} valid messages from history.`);\n                    // DEBUG: Log the final history being sent, ONLY FOR DEBUGGING SENSITIVE DATA\n                    // console.log(\"Final history for API:\", JSON.stringify(historyMessages, null, 2));\n                    } else {\n                        console.log(`Conversation ${conversation.conversation_id} has no messages.`);\n                    }\n                } else {\n                    console.log(`No existing user/conversation found for ${userId}. Creating.`);\n                    if (!user) {\n                        const isEmail = userId.includes(\"@\");\n                        const email = isEmail ? userId : `${userId}@example.com`;\n                        const provider = isEmail ? \"email\" : \"system\"; // Adjust as needed\n                        user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getOrCreateUser)(email, provider, userId, userId);\n                    }\n                }\n            } catch (error) {\n                console.error(\"CRITICAL: Error loading user/history:\", error);\n                try {\n                    const isEmail = userId.includes(\"@\");\n                    const email = isEmail ? userId : `${userId}@example.com`;\n                    user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getOrCreateUser)(email, isEmail ? \"email\" : \"system\", userId, userId);\n                } catch (userError) {\n                    console.error(\"CRITICAL: Failed user recovery:\", userError);\n                    streamCallback?.({\n                        type: \"error\",\n                        content: \"Failed to load user profile.\"\n                    });\n                    return \"Error: Could not load user profile.\";\n                }\n                conversation = null;\n                historyMessages = []; // Reset state\n            }\n        } else {\n            console.log(\"Starting a new conversation as requested.\");\n            // Ensure user object is loaded, even if history loading was skipped\n            console.log(\"DEBUG: startNewConversation=true, user object before loading:\", user ? `User exists: ${user.user_id}` : \"User is null\");\n            if (!user) {\n                try {\n                    const isEmail = userId.includes(\"@\");\n                    const email = isEmail ? userId : `${userId}@example.com`;\n                    console.log(`DEBUG: About to call getOrCreateUser with email=${email}`);\n                    user = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getOrCreateUser)(email, isEmail ? \"email\" : \"system\", userId, userId);\n                    console.log(\"DEBUG: After getOrCreateUser call, user object:\", JSON.stringify({\n                        user_id: user.user_id,\n                        email: user.email,\n                        hasUserPreference: !!user.UserPreference,\n                        userPreferenceKeys: user.UserPreference ? Object.keys(user.UserPreference) : null,\n                        preferencesDataKeys: user.UserPreference?.preferences_data ? Object.keys(user.UserPreference.preferences_data) : null\n                    }));\n                } catch (userError) {\n                    console.error(\"CRITICAL: Failed user creation/retrieval when starting new conversation:\", userError);\n                    streamCallback?.({\n                        type: \"error\",\n                        content: \"Failed to load user profile for new chat.\"\n                    });\n                    return \"Error: Could not load user profile.\";\n                }\n            }\n            // Explicitly clear conversation and history\n            conversation = null;\n            historyMessages = [];\n        }\n        // --- Create Conversation if needed & Add System Prompt ---\n        if (!conversation) {\n            try {\n                conversation = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.createConversation)(user.user_id);\n                console.log(`Created new conversation ${conversation.conversation_id}. Preparing system prompt.`);\n                // Get base system prompt\n                let systemPromptContent = (0,_data_prompts_js__WEBPACK_IMPORTED_MODULE_4__.getAthenaSystemPrompt)();\n                // Debug log the user object structure\n                console.log(\"DEBUG: User object structure when creating new conversation:\", JSON.stringify({\n                    user_id: user.user_id,\n                    email: user.email,\n                    hasUserPreference: !!user.UserPreference,\n                    userPreferenceDataValues: user.UserPreference ? !!user.UserPreference.dataValues : null,\n                    preferencesDataRaw: user.UserPreference ? user.UserPreference.preferences_data : null,\n                    preferencesDataFromDataValues: user.UserPreference ? user.UserPreference.dataValues?.preferences_data : null\n                }));\n                // Format and append user preferences if they exist\n                // Access preferences_data from dataValues if direct access fails\n                const preferencesData = user.UserPreference?.preferences_data || (user.UserPreference?.dataValues ? user.UserPreference.dataValues.preferences_data : null) || {};\n                // Log the raw UserPreference object to help diagnose issues\n                console.log(\"DEBUG: Raw UserPreference object:\", user.UserPreference ? JSON.stringify(user.UserPreference).substring(0, 200) + \"...\" : \"null\");\n                const prefsString = formatUserPreferences(preferencesData);\n                systemPromptContent += prefsString;\n                // Log the final system prompt\n                console.log(\"DEBUG: Final system prompt for new conversation:\", systemPromptContent.substring(0, 200) + \"... [truncated]\");\n                console.log(\"DEBUG: Does new conversation system prompt contain preferences?\", systemPromptContent.includes(\"User Preferences Context\"));\n                // Store the base system prompt in DB first\n                await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversation.conversation_id, \"system\", systemPromptContent);\n                // Add the potentially combined system prompt to the START of the local history array\n                historyMessages.unshift({\n                    role: \"system\",\n                    content: systemPromptContent\n                });\n            } catch (createError) {\n                console.error(\"CRITICAL: Failed to create conversation:\", createError);\n                streamCallback?.({\n                    type: \"error\",\n                    content: \"Failed to start chat session.\"\n                });\n                return \"Error: Could not start chat session.\";\n            }\n        }\n        // --- Prepare messages for API ---\n        // Create a copy of history messages\n        let currentMessages = [\n            ...historyMessages\n        ];\n        // Dynamically inject user preferences into system prompt for every API call\n        if (currentMessages.length > 0 && currentMessages[0].role === \"system\") {\n            // Get the base system prompt content\n            let baseSystemPrompt = (0,_data_prompts_js__WEBPACK_IMPORTED_MODULE_4__.getAthenaSystemPrompt)();\n            // Debug log the user object structure\n            console.log(\"DEBUG: User object structure before API call:\", JSON.stringify({\n                user_id: user.user_id,\n                email: user.email,\n                hasUserPreference: !!user.UserPreference,\n                userPreferenceDataValues: user.UserPreference ? !!user.UserPreference.dataValues : null,\n                preferencesDataRaw: user.UserPreference ? user.UserPreference.preferences_data : null,\n                preferencesDataFromDataValues: user.UserPreference ? user.UserPreference.dataValues?.preferences_data : null\n            }));\n            // Format and append user preferences if they exist\n            // Access preferences_data from dataValues if direct access fails\n            const preferencesData = user.UserPreference?.preferences_data || (user.UserPreference?.dataValues ? user.UserPreference.dataValues.preferences_data : null) || {};\n            // Log the raw UserPreference object to help diagnose issues\n            console.log(\"DEBUG: Raw UserPreference object:\", user.UserPreference ? JSON.stringify(user.UserPreference).substring(0, 200) + \"...\" : \"null\");\n            const prefsString = formatUserPreferences(preferencesData);\n            // Create the combined system prompt\n            const combinedPromptContent = baseSystemPrompt + prefsString;\n            // Log the final system prompt\n            console.log(\"DEBUG: Final system prompt:\", combinedPromptContent.substring(0, 200) + \"... [truncated]\");\n            console.log(\"DEBUG: Does system prompt contain preferences?\", combinedPromptContent.includes(\"User Preferences Context\"));\n            // Replace the existing system message with the updated one\n            currentMessages[0] = {\n                role: \"system\",\n                content: combinedPromptContent\n            };\n            console.log(\"Dynamically injected user preferences into system prompt for this API call.\");\n        }\n        // Add current user input\n        const userMessageForAPI = {\n            role: \"user\",\n            content: userInput\n        };\n        currentMessages.push(userMessageForAPI);\n        // Store user message in DB reliably\n        try {\n            await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.addMessageToConversation)(conversation.conversation_id, \"user\", userInput);\n        } catch (dbError) {\n            console.error(\"Error storing user message:\", dbError);\n        // Non-critical? Log and continue.\n        }\n        // --- Run the conversation logic ---\n        const response = await runConversation(currentMessages, userInput, conversation.conversation_id, user.user_id, accessToken, streamCallback);\n        // If not streaming, return the response.\n        // If streaming, runConversation handles sending via callback, so we might just return void or true/false\n        if (!streamCallback) {\n            return response; // Final text response for non-streaming\n        } else {\n            // Streaming handled by runConversation's callbacks\n            // Ensure 'end' was sent if an error occurred within runConversation before completion\n            // (runConversation should ideally handle sending 'end' or 'error' in most cases)\n            return; // Indicate success or simply complete for streaming\n        }\n    } catch (error) {\n        console.error(\"Error in main chat function:\", error);\n        const errorMessage = `An unexpected error occurred: ${error.message || \"Please try again.\"}`;\n        // Ensure 'end' or 'error' is sent in case of top-level failure\n        streamCallback?.({\n            type: \"error\",\n            content: errorMessage\n        });\n        streamCallback?.({\n            type: \"end\"\n        }); // Send end signal after error in streaming mode\n        return errorMessage; // Return error string for non-streaming\n    }\n}\n// --- Exports ---\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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XSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2NoYXRib3QuanNcbi8vIC0tLSBJTVBPUlRTIC0tLVxuaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgTm9kZUNhY2hlIGZyb20gJ25vZGUtY2FjaGUnO1xuaW1wb3J0ICdkb3RlbnYvY29uZmlnJztcblxuLy8gTG9jYWwgTW9kdWxlc1xuLy8gSW1wb3J0IHN5c3RlbSBwcm9tcHRcbmltcG9ydCB7IGdldEF0aGVuYVN5c3RlbVByb21wdCB9IGZyb20gJy4vZGF0YS9wcm9tcHRzLmpzJztcbmltcG9ydCB7IGZpbmRBdmFpbGFibGVTbG90cyBhcyBmaW5kQXZhaWxhYmxlU2xvdHNVdGlsLCBmb3JtYXRBdmFpbGFibGVTbG90cyB9IGZyb20gJy4vdG9vbHMvc2NoZWR1bGluZ1V0aWxzLmpzJztcbmltcG9ydCB7IGxpc3RUb2RheXNFdmVudHMsIHN1Z2dlc3RFdmVudFRpbWUgfSBmcm9tICcuL3Rvb2xzL2V2ZW50SGVscGVycy5qcyc7XG5pbXBvcnQgeyB0b29scywgdG9vbEZ1bmN0aW9ucyB9IGZyb20gJy4vdG9vbHMvdG9vbEluZGV4LmpzJztcbmltcG9ydCB7XG4gIGdldE9yQ3JlYXRlVXNlcixcbiAgY3JlYXRlQ29udmVyc2F0aW9uLFxuICAvLyBnZXRDb252ZXJzYXRpb24sIC8vIExlc3MgbGlrZWx5IG5lZWRlZCBkaXJlY3RseSBpZiB1c2luZyBnZXRVc2VyV2l0aExhdGVzdENvbnZlcnNhdGlvblxuICAvLyBnZXRDb252ZXJzYXRpb25NZXNzYWdlcywgLy8gTGVzcyBsaWtlbHkgbmVlZGVkIGRpcmVjdGx5XG4gIENvbnZlcnNhdGlvbk1lc3NhZ2UsIC8vIE5lZWRlZCBmb3IgdHlwZSBoaW50cy9jaGVja3MgaWYgYW55XG4gIGFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbixcbiAgaW5pdGlhbGl6ZURhdGFiYXNlLFxuICBnZXRDb252ZXJzYXRpb25zQnlVc2VySWQsXG4gIGdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uLFxuICBVc2VyUHJlZmVyZW5jZSAvLyBJbXBvcnQgVXNlclByZWZlcmVuY2UgbW9kZWwgZm9yIHRvb2wgZnVuY3Rpb24gdXNhZ2Vcbn0gZnJvbSAnLi9wb3N0Z3Jlc0NsaWVudC5qcyc7XG5cbi8vIFdlYXRoZXIgY2xpZW50IGZ1bmN0aW9uIChpZiB1c2VkKVxuLy8gaW1wb3J0IHsgZ2V0V2VhdGhlckRhdGEgfSBmcm9tICcuL3dlYXRoZXJDbGllbnQuanMnOyAvLyBFeGFtcGxlIHBhdGhcblxuLy8gR29vZ2xlIEFQSXMgbGlicmFyeSAobmVlZGVkIGZvciBkaXJlY3QgY2FsbHMgaW4gdG9vbCBmdW5jdGlvbnMgbGlrZSBkZWxldGUvdXBkYXRlKVxuLy8gKipGSVg6KiogVXNlIGltcG9ydCBpbnN0ZWFkIG9mIHJlcXVpcmUgZm9yIGNvbnNpc3RlbmN5IGlmIHBvc3NpYmxlIChkZXBlbmRzIG9uIHByb2plY3Qgc2V0dXApXG4vLyBJZiB1c2luZyBFUyBtb2R1bGVzOiBpbXBvcnQgeyBnb29nbGUgfSBmcm9tICdnb29nbGVhcGlzJztcbi8vIElmIHJlcXVpcmUgaXMgbmVjZXNzYXJ5OlxuY29uc3QgeyBnb29nbGUgfSA9IHJlcXVpcmUoJ2dvb2dsZWFwaXMnKTsgLy8gS2VlcCByZXF1aXJlIGlmIG5lY2Vzc2FyeSBmb3IgZ29vZ2xlYXBpc1xuXG4vLyAtLS0gRGF0YWJhc2UgSW5pdGlhbGl6YXRpb24gLS0tXG4vLyAoS2VlcCB0aGUgZ2V0RGF0YWJhc2VJbml0UHJvbWlzZSBmdW5jdGlvbiBhcyBpcylcbmxldCBkYkluaXRQcm9taXNlID0gbnVsbDtcblxuLy8gSW5pdGlhbGl6ZSBPcGVuQUkgY2xpZW50XG5jb25zdCBvcGVuYWkgPSBuZXcgT3BlbkFJKHsgYXBpS2V5OiBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSB9KTtcblxuLy8gQ3JlYXRlIGEgZ2xvYmFsIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBjdXJyZW50IHJlc3BvbnNlQ2FsbGJhY2tcbmdsb2JhbC5jdXJyZW50UmVzcG9uc2VDYWxsYmFjayA9IG51bGw7XG5cbi8vIENyZWF0ZSBhIGdsb2JhbCB2YXJpYWJsZSB0byBzdG9yZSBwZW5kaW5nIGV2ZW50IGRhdGFcbmdsb2JhbC5wZW5kaW5nRXZlbnREYXRhID0gbnVsbDtcblxuLy8gLS0tIEhlbHBlciBGdW5jdGlvbnMgKEZvcm1hdHRpbmcgJiBUaW1lKSAtLS1cbmZ1bmN0aW9uIGZvcm1hdEV2ZW50VGltZShldmVudFRpbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkdCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnRUaW1lKTtcbiAgICAgICAgaWYgKGR0LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkdC50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFVElNRV9GVUxMKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlT25seSA9IERhdGVUaW1lLmZyb21JU08oZXZlbnRUaW1lLCB7IHpvbmU6ICd1dGMnIH0pO1xuICAgICAgICBpZiAoZGF0ZU9ubHkuaXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVPbmx5LnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCkgKyBcIiAoQWxsIGRheSlcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRUaW1lO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZm9ybWF0dGluZyBldmVudCB0aW1lOlwiLCBldmVudFRpbWUsIGUpO1xuICAgICAgICByZXR1cm4gU3RyaW5nKGV2ZW50VGltZSk7IC8vIEVuc3VyZSByZXR1cm5zIHN0cmluZ1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0Q2FsZW5kYXJFdmVudHMoZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudHMpIHJldHVybiBcIk5vIGV2ZW50cyBmb3VuZCBvciBhbiBlcnJvciBvY2N1cnJlZC5cIjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSkgcmV0dXJuIFwiQW4gZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyBldmVudHMuXCI7XG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHJldHVybiBcIk5vIGV2ZW50cyBmb3VuZCBmb3IgdGhlIHNwZWNpZmllZCB0aW1lIHBlcmlvZC5cIjtcblxuICAgIHJldHVybiBldmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5zdGFydD8uZGF0ZVRpbWUgfHwgZXZlbnQuc3RhcnQ/LmRhdGUpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5lbmQ/LmRhdGVUaW1lIHx8IGV2ZW50LmVuZD8uZGF0ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQgfHwgIWVuZC5pc1ZhbGlkKSByZXR1cm4gYOKdkyBJbnZhbGlkIGRhdGUgZm91bmQgZm9yIGV2ZW50OiAke2V2ZW50LnN1bW1hcnkgfHwgZXZlbnQuaWR9YDtcblxuICAgICAgICAgICAgY29uc3QgaXNBbGxEYXkgPSAhZXZlbnQuc3RhcnQ/LmRhdGVUaW1lO1xuICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgZXZlbnQgSUQgaW4gdGhlIGZvcm1hdHRlZCBvdXRwdXQgKGhpZGRlbiB3aXRoIGEgemVyby13aWR0aCBzcGFjZSBmb3IgcmVmZXJlbmNlKVxuICAgICAgICAgICAgbGV0IGZvcm1hdHRlZEV2ZW50ID0gYPCfk4UgJHtldmVudC5zdW1tYXJ5IHx8ICcoTm8gVGl0bGUpJ30gW0lEOuKAiyR7ZXZlbnQuaWR9XVxcbmA7XG4gICAgICAgICAgICBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+ThiAke3N0YXJ0LnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCl9XFxuYDtcbiAgICAgICAgICAgIGlmICghaXNBbGxEYXkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+VkiAke3N0YXJ0LnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKX0gLSAke2VuZC50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSl9XFxuYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCflZIgQWxsIERheVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGVzY3JpcHRpb24pIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5OdICR7ZXZlbnQuZGVzY3JpcHRpb259XFxuYDtcbiAgICAgICAgICAgIGlmIChldmVudC5sb2NhdGlvbikgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCfk40gJHtldmVudC5sb2NhdGlvbn1cXG5gO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnJlbWluZGVycz8udXNlRGVmYXVsdCA9PT0gZmFsc2UgJiYgQXJyYXkuaXNBcnJheShldmVudC5yZW1pbmRlcnMub3ZlcnJpZGVzKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5SUIFJlbWluZGVyczogJHtldmVudC5yZW1pbmRlcnMub3ZlcnJpZGVzLm1hcChyID0+IGAke3IubWludXRlc30gbWluYCkuam9pbignLCAnKX1cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZEV2ZW50LnRyaW0oKTsgLy8gVHJpbSBlYWNoIGV2ZW50IHN0cmluZ1xuICAgICAgICB9IGNhdGNoIChtYXBFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1hcHBpbmcgZXZlbnQ6XCIsIGV2ZW50LCBtYXBFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gYOKdkyBFcnJvciBwcm9jZXNzaW5nIGV2ZW50OiAke2V2ZW50LnN1bW1hcnkgfHwgZXZlbnQuaWR9YDtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oJ1xcblxcbicpOyAvLyBBZGQgc3BhY2UgYmV0d2VlbiBldmVudHNcbn1cblxuLy8gLS0tIEZvcm1hdHRpbmcgVG9vbCBSZXNwb25zZXMgZm9yIHRoZSBMTE0gLS0tXG5mdW5jdGlvbiBmb3JtYXRUb29sUmVzcG9uc2UoZnVuY3Rpb25OYW1lLCByZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IGhhbmRsZSBudWxsL3VuZGVmaW5lZCByZXN1bHRzIGZpcnN0XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUb29sICR7ZnVuY3Rpb25OYW1lfSByZXR1cm5lZCBudWxsIG9yIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICAgIHJldHVybiBgVG9vbCAke2Z1bmN0aW9uTmFtZX0gZGlkIG5vdCByZXR1cm4gYSByZXN1bHQuIChTdGF0dXM6IEZBSUxFRClgO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGtub3duIGVycm9yIHNoYXBlcyByZXR1cm5lZCBieSB0b29sIGZ1bmN0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgJiYgcmVzdWx0LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZXJyb3I6JykpXG4gICAgICAgICAgICByZXR1cm4gYCR7cmVzdWx0fSAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdC5lcnJvcilcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZXhlY3V0aW5nICR7ZnVuY3Rpb25OYW1lfTogJHtyZXN1bHQuZXJyb3J9IChTdGF0dXM6IEZBSUxFRClgO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGBUb29sICR7ZnVuY3Rpb25OYW1lfSBmYWlsZWQ6ICR7cmVzdWx0Lm1lc3NhZ2UgfHwgJ05vIGRldGFpbHMuJ30gKFN0YXR1czogRkFJTEVEKWA7XG5cbiAgICAgICAgLy8gLS0tIEZvcm1hdCBzdWNjZXNzZnVsIHJlc3VsdHMgLS0tXG4gICAgICAgIHN3aXRjaCAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdzYXZlVXNlclByZWZlcmVuY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IGDinIUgUHJlZiBzYXZlZDogJHtyZXN1bHQubWVzc2FnZX0gKFN0YXR1czogU1VDQ0VTUylgIDogYOKdjCBQcmVmIGZhaWw6ICR7cmVzdWx0Lm1lc3NhZ2V9IChTdGF0dXM6IEZBSUxFRClgO1xuXG4gICAgICAgICAgICBjYXNlICdhZGRDYWxlbmRhckV2ZW50cyc6XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHJldHVybiBcIkVycm9yOiBJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIGFkZENhbGVuZGFyRXZlbnRzLiAoU3RhdHVzOiBGQUlMRUQpXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHJldHVybiBcIk5vIGV2ZW50cyB3ZXJlIHByb2Nlc3NlZC4gKFN0YXR1czogTkVVVFJBTClcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gJ+KdkyBJbnZhbGlkIGl0ZW0gaW4gcmVzdWx0IGFycmF5LiAoU3RhdHVzOiBGQUlMRUQpJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZXJyb3IpIHsgLy8gSGFuZGxlIGV4cGxpY2l0IGVycm9ycyBmaXJzdCAoY29uZmxpY3QsIHZhbGlkYXRpb24sIEFQSSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSBpdGVtLnN1bW1hcnkgfHwgJz8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29uZmxpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHN1Z2dlc3Rpb25zIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25UZXh0ID0gaXRlbS5zdWdnZXN0aW9ucyAmJiBpdGVtLnN1Z2dlc3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgIFN1Z2dlc3RlZCBzbG90czogJHtpdGVtLnN1Z2dlc3Rpb25zLm1hcChzID0+IGAke0RhdGVUaW1lLmZyb21JU08ocy5zdGFydCkudG9Gb3JtYXQoJ2g6bW1hJyl9IC0gJHtEYXRlVGltZS5mcm9tSVNPKHMuZW5kKS50b0Zvcm1hdCgnaDptbWEnKX1gKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKaoO+4jyBDb25mbGljdCBkZXRlY3RlZCBmb3IgZXZlbnQgXCIke3N1bW1hcnl9XCIuJHtzdWdnZXN0aW9uVGV4dH0gKFN0YXR1czogQ09ORkxJQ1QpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinYwgRmFpbGVkIHRvIGFkZCBldmVudCBcIiR7c3VtbWFyeX1cIjogJHtpdGVtLmVycm9yfSAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmlkICYmIGl0ZW0uc3VtbWFyeSAmJiAoaXRlbS5zdGFydD8uZGF0ZVRpbWUgfHwgaXRlbS5zdGFydD8uZGF0ZSkpIHsgLy8gQXNzdW1lIHN1Y2Nlc3MgaWYga2V5IGZpZWxkcyBleGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydFN0ciA9IGZvcm1hdEV2ZW50VGltZShpdGVtLnN0YXJ0LmRhdGVUaW1lIHx8IGl0ZW0uc3RhcnQuZGF0ZSk7IC8vIFVzZSBleGlzdGluZyBoZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKchSBFdmVudCBhZGRlZDogXCIke2l0ZW0uc3VtbWFyeX1cIiBzdGFydGluZyAke3N0YXJ0U3RyfS4gKElEOiAke2l0ZW0uaWR9KSAoU3RhdHVzOiBTVUNDRVNTKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZvcm1hdHRpbmcgc3VjY2VzcyBtZXNzYWdlIGZvciBhZGRlZCBldmVudDpcIiwgaXRlbSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinIUgRXZlbnQgYWRkZWQ6IFwiJHtpdGVtLnN1bW1hcnl9XCIgKGRldGFpbHMgdW5hdmFpbGFibGUpLiAoSUQ6ICR7aXRlbS5pZH0pIChTdGF0dXM6IFNVQ0NFU1MpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gRmFsbGJhY2sgZm9yIHVuZXhwZWN0ZWQgc2hhcGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkIGl0ZW0gc2hhcGUgaW4gYWRkQ2FsZW5kYXJFdmVudHMgcmVzdWx0OlwiLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBg4p2TIFVua25vd24gb3V0Y29tZSBmb3IgYW4gZXZlbnQgYXR0ZW1wdC4gKFN0YXR1czogVU5LTk9XTilgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ2dldENhbGVuZGFyRXZlbnRzJzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBg8J+Xk++4jyBFdmVudHM6ICR7cmVzdWx0fSAoU3RhdHVzOiAke3Jlc3VsdC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Vycm9yJykgPyAnRkFJTEVEJyA6ICdTVUNDRVNTJ30pYDtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IEludmFsaWQgZ2V0Q2FsZW5kYXJFdmVudHMgcmVzcG9uc2UuIChTdGF0dXM6IEZBSUxFRClcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IFwi8J+Xk++4jyBObyBldmVudHMgZm91bmQuIChTdGF0dXM6IFNVQ0NFU1MpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBg8J+Xk++4jyBGb3VuZCAke3Jlc3VsdC5sZW5ndGh9IGV2ZW50KHMpOlxcblxcbiR7Zm9ybWF0Q2FsZW5kYXJFdmVudHMocmVzdWx0KX0gKFN0YXR1czogU1VDQ0VTUylgO1xuXG4gICAgICAgICAgICBjYXNlICdkZWxldGVDYWxlbmRhckV2ZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgPyBg8J+Xke+4jyBFdmVudCBcIiR7cmVzdWx0LnN1bW1hcnkgfHwgcmVzdWx0LmV2ZW50SWR9XCIgZGVsZXRlZC4gKFN0YXR1czogU1VDQ0VTUylgIC8vIFVzZSBldmVudElkIGlmIHN1bW1hcnkgd2Fzbid0IGZldGNoZWQvcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgOiBg4p2MIEZhaWxlZCB0byBkZWxldGUgZXZlbnQgJHtyZXN1bHQuZXZlbnRJZCB8fCAnPyd9OiAke3Jlc3VsdC5lcnJvciB8fCByZXN1bHQubWVzc2FnZSB8fCAnPyd9IChTdGF0dXM6IEZBSUxFRClgO1xuXG4gICAgICAgICAgICBjYXNlICd1cGRhdGVDYWxlbmRhckV2ZW50JzpcbiAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcmVzdWx0IGhhcyBhbiBJRCwgaW5kaWNhdGluZyBzdWNjZXNzIGZyb20gZ29vZ2xlQ2FsZW5kYXIgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGDinI/vuI8gRXZlbnQgXCIke3Jlc3VsdC5zdW1tYXJ5IHx8IGV2ZW50SWR9XCIgdXBkYXRlZC4gKElEOiAke3Jlc3VsdC5pZH0pIChTdGF0dXM6IFNVQ0NFU1MpYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgcG90ZW50aWFsIGVycm9yIG9iamVjdHMgcGFzc2VkIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSByZXN1bHQ/LmVycm9yIHx8IHJlc3VsdD8ubWVzc2FnZSB8fCBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKdjCBGYWlsZWQgdG8gdXBkYXRlIGV2ZW50OiAke2Vycm9yTXNnfSAoU3RhdHVzOiBGQUlMRUQpYDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZpbmRBdmFpbGFibGVTbG90cyc6XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBJbnZhbGlkIGZpbmRBdmFpbGFibGVTbG90cyByZXNwb25zZS4gKFN0YXR1czogRkFJTEVEKVwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYPCflZIgTm8gYXZhaWxhYmxlIHNsb3RzIGZvdW5kIG1hdGNoaW5nIGNyaXRlcmlhLiAoU3RhdHVzOiBTVUNDRVNTKWA7XG4gICAgICAgICAgICAgICAgLy8gRm9ybWF0IHNsb3RzIHdpdGggc3VjY2VzcyBzdGF0dXNcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRTbG90cyA9IHJlc3VsdC5tYXAoc2xvdCA9PlxuICAgICAgICAgICAgICAgICAgICBgJHtEYXRlVGltZS5mcm9tSVNPKHNsb3Quc3RhcnQpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKX0gLSAke0RhdGVUaW1lLmZyb21JU08oc2xvdC5lbmQpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKX1gXG4gICAgICAgICAgICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYPCflZIgRm91bmQgJHtyZXN1bHQubGVuZ3RofSBhdmFpbGFibGUgc2xvdChzKTpcXG5cXG4ke2Zvcm1hdHRlZFNsb3RzfVxcblxcbihTdGF0dXM6IFNVQ0NFU1MpYDtcblxuICAgICAgICAgICAgY2FzZSAnZ2V0V2VhdGhlckZvcmVjYXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYPCfjKTvuI8gV2VhdGhlciBmb3IgJHtyZXN1bHQubG9jYXRpb259IG9uICR7cmVzdWx0LmRhdGV9OiAke3Jlc3VsdC5mb3JlY2FzdCB8fCAnTi9BJ30gKFN0YXR1czogJHtyZXN1bHQuZm9yZWNhc3QgJiYgIXJlc3VsdC5mb3JlY2FzdC5pbmNsdWRlcygndW5hdmFpbGFibGUnKSA/ICdTVUNDRVNTJyA6ICdQQVJUSUFMJ30pYDtcblxuICAgICAgICAgICAgY2FzZSAnZGVsZXRlQ2FsZW5kYXJFdmVudHNCeVF1ZXJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgPyBg8J+Xke+4jyAke3Jlc3VsdC5tZXNzYWdlfSAoRGVsZXRlZCBDb3VudDogJHtyZXN1bHQuZGVsZXRlZENvdW50fSkgKFN0YXR1czogU1VDQ0VTUylgXG4gICAgICAgICAgICAgICAgICAgIDogYOKdjCBGYWlsZWQgYnVsayBkZWxldGU6ICR7cmVzdWx0Lm1lc3NhZ2UgfHwgcmVzdWx0LmVycm9yIHx8ICc/J30gKFN0YXR1czogRkFJTEVEKWA7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gU2FmZWx5IHN0cmluZ2lmeSBvdGhlciByZXN1bHRzIHdpdGggc3RhdHVzIGluZGljYXRvcnNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3VsdC5zdWNjZXNzID09PSB0cnVlID8gJ1NVQ0NFU1MnIDogKHJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSA/ICdGQUlMRUQnIDogJ1VOS05PV04nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9IChTdGF0dXM6ICR7c3RhdHVzfSlgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtTdHJpbmcocmVzdWx0KX0gKFN0YXR1czogVU5LTk9XTilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGZvcm1hdEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYENSSVRJQ0FMOiBFcnJvciAqd2l0aGluKiBmb3JtYXRUb29sUmVzcG9uc2UgZm9yICR7ZnVuY3Rpb25OYW1lfTpgLCBmb3JtYXRFcnJvciwgXCJSYXcgcmVzdWx0OlwiLCByZXN1bHQpO1xuICAgICAgICAvLyBSZXR1cm4gYSBndWFyYW50ZWVkIHN0cmluZyBlcnJvciBtZXNzYWdlXG4gICAgICAgIHJldHVybiBgSW50ZXJuYWwgRXJyb3I6IEZhaWxlZCB0byBmb3JtYXQgdGhlIHJlc3VsdCBmb3IgJHtmdW5jdGlvbk5hbWV9LiAoU3RhdHVzOiBFUlJPUilgO1xuICAgIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHByb2Nlc3MgdG9vbCBjYWxsc1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1Rvb2xDYWxscyh0b29sQ2FsbHMsIG1lc3NhZ2VzLCBjb252ZXJzYXRpb25JZCwgdXNlcklkLCBhY2Nlc3NUb2tlbiwgcmVzcG9uc2VDYWxsYmFjaykge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7dG9vbENhbGxzLmxlbmd0aH0gdG9vbCBjYWxsc2ApO1xuXG4gICAgLy8gRGVmaW5lIGlzQ29udmVyc2F0aW9uYWxRdWVyeSBhdCB0aGUgZnVuY3Rpb24gc2NvcGUgbGV2ZWwgc28gaXQncyBhY2Nlc3NpYmxlIHRocm91Z2hvdXRcbiAgICBsZXQgaXNDb252ZXJzYXRpb25hbFF1ZXJ5ID0gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHB1cmVseSBjb252ZXJzYXRpb25hbCBxdWVyeSBieSBleGFtaW5pbmcgdGhlIG9yaWdpbmFsIG1lc3NhZ2VcbiAgICAvLyBUaGlzIGhlbHBzIHByZXZlbnQgc2hvd2luZyBwcm9jZXNzaW5nIGNhcmRzIGZvciBzaW1wbGUgcXVlc3Rpb25zXG4gICAgY29uc3QgdXNlck1lc3NhZ2UgPSBtZXNzYWdlcy5maW5kKG1zZyA9PiBtc2cucm9sZSA9PT0gJ3VzZXInKT8uY29udGVudD8udG9Mb3dlckNhc2UoKSB8fCAnJztcbiAgICBpc0NvbnZlcnNhdGlvbmFsUXVlcnkgPSAhdXNlck1lc3NhZ2UuaW5jbHVkZXMoJ2NhbGVuZGFyJykgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAhdXNlck1lc3NhZ2UuaW5jbHVkZXMoJ3NjaGVkdWxlJykgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAhdXNlck1lc3NhZ2UuaW5jbHVkZXMoJ2V2ZW50JykgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAhdXNlck1lc3NhZ2UuaW5jbHVkZXMoJ21lZXRpbmcnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIXVzZXJNZXNzYWdlLmluY2x1ZGVzKCdhcHBvaW50bWVudCcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAhdXNlck1lc3NhZ2UuaW5jbHVkZXMoJ3RvbW9ycm93JykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICF1c2VyTWVzc2FnZS5pbmNsdWRlcygndG9kYXknKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIXVzZXJNZXNzYWdlLmluY2x1ZGVzKCd5ZXN0ZXJkYXknKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIXVzZXJNZXNzYWdlLm1hdGNoKC9cXGIobmV4dHxsYXN0fHRoaXMpXFxzKyh3ZWVrfG1vbnRofHllYXIpXFxiLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICF1c2VyTWVzc2FnZS5tYXRjaCgvXFxiXFxkezEsMn0oc3R8bmR8cmR8dGgpP1xcYi8pO1xuICAgIFxuICAgIC8vIEZpcnN0IGVuc3VyZSBBbmFseXppbmcgUmVxdWVzdCBpcyBtYXJrZWQgYXMgY29tcGxldGVcbiAgICAvLyBUaGlzIGlzIG5vdyBoYW5kbGVkIGJ5IHRoZSBjaGF0LXN0cmVhbS5qcyBmaWxlIHRvIGF2b2lkIGR1cGxpY2F0aW9uXG4gICAgXG4gICAgLy8gVXNlIFByb21pc2UuYWxsU2V0dGxlZCBmb3Igcm9idXN0bmVzc1xuICAgIGNvbnN0IHRvb2xQcm9taXNlcyA9IHRvb2xDYWxscy5tYXAoYXN5bmMgKHRvb2xDYWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsSWQgPSB0b29sQ2FsbC5pZDtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdG9vbENhbGwuZnVuY3Rpb24/Lm5hbWU7XG4gICAgICAgIGxldCB0b29sUmVzcG9uc2VDb250ZW50ID0gJyc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIEJhc2ljIFZhbGlkYXRpb25cbiAgICAgICAgICAgIGlmICghdG9vbENhbGxJZCB8fCB0b29sQ2FsbC50eXBlICE9PSAnZnVuY3Rpb24nIHx8ICFmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsIHN0cnVjdHVyZSByZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh0b29sQ2FsbCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRvb2xGdW5jdGlvbnNbZnVuY3Rpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCBmdW5jdGlvbiBcIiR7ZnVuY3Rpb25OYW1lfVwiIGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDIuIFBhcnNlIEFyZ3VtZW50c1xuICAgICAgICAgICAgbGV0IHBhcnNlZEFyZ3MgPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXJncyA9IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzIHx8ICd7fScpO1xuICAgICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OIGFyZ3VtZW50cyBmb3IgJHtmdW5jdGlvbk5hbWV9LiBBcmdzOiAke3Rvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50c30uIEVycm9yOiAke3BhcnNlRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2VuZCBhcHByb3ByaWF0ZSBwcm9jZXNzaW5nIHN0ZXAgYmFzZWQgb24gdGhlIHRvb2wgYmVpbmcgdXNlZFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIE9ubHkgc2VuZCBwcm9jZXNzaW5nIHN0ZXBzIGZvciBub24tY29udmVyc2F0aW9uYWwgcXVlcmllcyBvciBzcGVjaWZpYyB0b29sIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICBsZXQgcHJvY2Vzc2luZ1N0ZXBUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIERldGVybWluZSBhcHByb3ByaWF0ZSBzdGVwIHRleHQgYmFzZWQgb24gdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZS5pbmNsdWRlcygnQ2FsZW5kYXInKSB8fCBmdW5jdGlvbk5hbWUuaW5jbHVkZXMoJ0V2ZW50JykpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nU3RlcFRleHQgPSBcIkZldGNoaW5nIENhbGVuZGFyIERhdGE6IC4uLlwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZS5pbmNsdWRlcygnV2VhdGhlcicpKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1N0ZXBUZXh0ID0gXCJHZXR0aW5nIFdlYXRoZXIgRGF0YTogLi4uXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25OYW1lLmluY2x1ZGVzKCdQcmVmZXJlbmNlJykpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nU3RlcFRleHQgPSBcIlVwZGF0aW5nIFVzZXIgUHJlZmVyZW5jZXM6IC4uLlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEdlbmVyaWMgc3RlcCBmb3Igb3RoZXIgdG9vbHNcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nU3RlcFRleHQgPSBgVXNpbmcgJHtmdW5jdGlvbk5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCAnICQxJykudHJpbSgpfTogLi4uYDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgYXBwcm9wcmlhdGUgcHJvY2Vzc2luZyBzdGVwXG4gICAgICAgICAgICAgIGlmICghaXNDb252ZXJzYXRpb25hbFF1ZXJ5IHx8IGZ1bmN0aW9uTmFtZS5pbmNsdWRlcygnQ2FsZW5kYXInKSB8fCBmdW5jdGlvbk5hbWUuaW5jbHVkZXMoJ1dlYXRoZXInKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDYWxsYmFjayh7IFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHJvY2Vzc2luZycsIFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBwcm9jZXNzaW5nU3RlcFRleHRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gMy4gRXhlY3V0ZSBUb29sIEZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhlY3V0aW5nIHRvb2w6ICR7ZnVuY3Rpb25OYW1lfSAoSUQ6ICR7dG9vbENhbGxJZH0pIHdpdGggYXJnczpgLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9vbEZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdKHBhcnNlZEFyZ3MsIHVzZXJJZCwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFRvb2wgJHtmdW5jdGlvbk5hbWV9IChJRDogJHt0b29sQ2FsbElkfSkgcmF3IHJlc3VsdDpgLCByZXN1bHQpO1xuXG4gICAgICAgICAgICAvLyA0LiBGb3JtYXQgUmVzdWx0XG4gICAgICAgICAgICB0b29sUmVzcG9uc2VDb250ZW50ID0gZm9ybWF0VG9vbFJlc3BvbnNlKGZ1bmN0aW9uTmFtZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUb29sICR7ZnVuY3Rpb25OYW1lfSAoSUQ6ICR7dG9vbENhbGxJZH0pIGZvcm1hdHRlZCByZXNwb25zZTpgLCB0b29sUmVzcG9uc2VDb250ZW50KTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgZXZlbnQgZGF0YSBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25OYW1lID09PSAnZ2V0Q2FsZW5kYXJFdmVudHMnICYmIEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdsb2JhbC5wZW5kaW5nRXZlbnREYXRhID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHNlbmQgZXZlbnRzIGhlcmUsIHdhaXQgZm9yIHRoZSBmaW5hbCByZXNwb25zZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZW5kIGNvbXBsZXRpb24gbm90aWZpY2F0aW9uIGZvciB0aGUgYXBwcm9wcmlhdGUgc3RlcFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb21wbGV0aW9uIHN0ZXAgdGV4dCBiYXNlZCBvbiB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgICBsZXQgY29tcGxldGlvblN0ZXBUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUuaW5jbHVkZXMoJ0NhbGVuZGFyJykgfHwgZnVuY3Rpb25OYW1lLmluY2x1ZGVzKCdFdmVudCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvblN0ZXBUZXh0ID0gXCJGZXRjaGluZyBDYWxlbmRhciBEYXRhOiDinJNcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUuaW5jbHVkZXMoJ1dlYXRoZXInKSkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25TdGVwVGV4dCA9IFwiR2V0dGluZyBXZWF0aGVyIERhdGE6IOKck1wiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZS5pbmNsdWRlcygnUHJlZmVyZW5jZScpKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvblN0ZXBUZXh0ID0gXCJVcGRhdGluZyBVc2VyIFByZWZlcmVuY2VzOiDinJNcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmljIHN0ZXAgZm9yIG90aGVyIHRvb2xzXG4gICAgICAgICAgICAgICAgY29tcGxldGlvblN0ZXBUZXh0ID0gYFVzaW5nICR7ZnVuY3Rpb25OYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgJyAkMScpLnRyaW0oKX06IOKck2A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFkZCBhcHByb3ByaWF0ZSBkZWxheSBiYXNlZCBvbiB0aGUgdG9vbFxuICAgICAgICAgICAgICBpZiAoIWlzQ29udmVyc2F0aW9uYWxRdWVyeSB8fCBmdW5jdGlvbk5hbWUuaW5jbHVkZXMoJ0NhbGVuZGFyJykgfHwgZnVuY3Rpb25OYW1lLmluY2x1ZGVzKCdXZWF0aGVyJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IGZ1bmN0aW9uTmFtZS5pbmNsdWRlcygnQ2FsZW5kYXInKSA/IDIwMDAgOiAxNTAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDYWxsYmFjayh7IFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHJvY2Vzc2luZycsIFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb21wbGV0aW9uU3RlcFRleHRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBUaGVuIHF1aWNrbHkgc3RhcnQgdGhlIG5leHQgc3RlcCB0byBzaG93IGhvdyBmYXN0IHRoZSBzeXN0ZW0gaXNcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNhbGxiYWNrKHsgXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Byb2Nlc3NpbmcnLCBcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBgR2VuZXJhdGluZyBSZXNwb25zZTogLi4uYCBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBRdWlja2x5IGNvbXBsZXRlIGl0IHRvIGRlbW9uc3RyYXRlIHNwZWVkXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2soeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwcm9jZXNzaW5nJywgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBgR2VuZXJhdGluZyBSZXNwb25zZTog4pyTYCBcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgODAwKTsgLy8gUXVpY2sgY29tcGxldGlvbiBvZiBHZW5lcmF0aW5nIFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9LCAzMDApOyAvLyBWZXJ5IHF1aWNrIHRyYW5zaXRpb24gdG8gR2VuZXJhdGluZyBSZXNwb25zZVxuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTsgLy8gQXBwcm9wcmlhdGUgZGVsYXkgYmFzZWQgb24gdGhlIHRvb2xcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgYSBzdWNjZXNzIGluZGljYXRvciB0byB0aGUgdG9vbCByZXNwb25zZSBmb3IgY29udGV4dCB0cmFja2luZ1xuICAgICAgICAgICAgbGV0IHN1Y2Nlc3NJbmRpY2F0b3IgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2RlbGV0ZUNhbGVuZGFyRXZlbnQnICYmIHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0luZGljYXRvciA9IFwiXFxuXFxuW+KchSBFdmVudCBzdWNjZXNzZnVsbHkgZGVsZXRlZF1cIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25OYW1lID09PSAnYWRkQ2FsZW5kYXJFdmVudCcgJiYgcmVzdWx0LmlkKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0luZGljYXRvciA9IFwiXFxuXFxuW+KchSBFdmVudCBzdWNjZXNzZnVsbHkgYWRkZWRdXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ3VwZGF0ZUNhbGVuZGFyRXZlbnQnICYmIHJlc3VsdC5pZCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NJbmRpY2F0b3IgPSBcIlxcblxcblvinIUgRXZlbnQgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWRdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBzdWNjZXNzIGluZGljYXRvciB0byB0aGUgcmVzcG9uc2UgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdmdWxmaWxsZWQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7IHJvbGU6IFwidG9vbFwiLCBjb250ZW50OiB0b29sUmVzcG9uc2VDb250ZW50ICsgc3VjY2Vzc0luZGljYXRvciwgdG9vbF9jYWxsX2lkOiB0b29sQ2FsbElkIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVSUk9SIHByb2Nlc3NpbmcgdG9vbCBjYWxsICR7dG9vbENhbGxJZH0gKCR7ZnVuY3Rpb25OYW1lIHx8ICc/J30pOmAsIGVycm9yKTtcbiAgICAgICAgICAgIHRvb2xSZXNwb25zZUNvbnRlbnQgPSBgRXJyb3IgcHJvY2Vzc2luZyB0b29sICR7ZnVuY3Rpb25OYW1lIHx8ICc/J306ICR7ZXJyb3IubWVzc2FnZSB8fCBlcnJvcn1gO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogJ3JlamVjdGVkJyxcbiAgICAgICAgICAgICAgICByZWFzb246IGVycm9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7IHJvbGU6IFwidG9vbFwiLCBjb250ZW50OiB0b29sUmVzcG9uc2VDb250ZW50LCB0b29sX2NhbGxfaWQ6IHRvb2xDYWxsSWQgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2V0dGxlZFRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHRvb2xQcm9taXNlcyk7XG4gICAgXG4gICAgY29uc3QgdG9vbFJlc3BvbnNlcyA9IHNldHRsZWRUb29sUmVzdWx0cy5tYXAoc2V0dGxlZFJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChzZXR0bGVkUmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0bGVkUmVzdWx0LnZhbHVlLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRsZWRSZXN1bHQucmVhc29uLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgLy8gQWRkIHRvb2wgcmVzcG9uc2VzIHRvIGhpc3RvcnlcbiAgICBtZXNzYWdlcy5wdXNoKC4uLnRvb2xSZXNwb25zZXMpO1xuXG4gICAgLy8gU3RvcmUgdG9vbCByZXNwb25zZXMgaW4gREIgKGJlc3QgZWZmb3J0LCBsb29wIHRocm91Z2ggcmVzdWx0cylcbiAgICBpZiAoY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFVzZSBQcm9taXNlLmFsbCB0byBzdG9yZSBhbGwgdG9vbCByZXNwb25zZXMgaW4gcGFyYWxsZWxcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRvb2xSZXNwb25zZXMubWFwKHRvb2xNc2cgPT4gXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVRvQ29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbklkLCBcInRvb2xcIiwgdG9vbE1zZy5jb250ZW50LCB7IHRvb2xfY2FsbF9pZDogdG9vbE1zZy50b29sX2NhbGxfaWQgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZGJFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYERCIEVycm9yIHN0b3JpbmcgdG9vbCByZXNwb25zZSAke3Rvb2xNc2cudG9vbF9jYWxsX2lkfTpgLCBkYkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgdGhyb3csIGFsbG93IG90aGVyIG1lc3NhZ2VzIHRvIGJlIHN0b3JlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU3RvcmVkICR7dG9vbFJlc3BvbnNlcy5sZW5ndGh9IHRvb2wgcmVzcG9uc2VzIGluIGRhdGFiYXNlYCk7XG4gICAgICAgIH0gY2F0Y2ggKGJhdGNoRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGJhdGNoIHN0b3JpbmcgdG9vbCByZXNwb25zZXM6YCwgYmF0Y2hFcnJvcik7XG4gICAgICAgICAgICAvLyBJbmRpdmlkdWFsIGVycm9ycyBhcmUgYWxyZWFkeSBjYXVnaHQgaW4gdGhlIG1hcCBmdW5jdGlvblxuICAgICAgICAgICAgLy8gVGhpcyBjYXRjaCBpcyBmb3IgZXJyb3JzIG91dHNpZGUgdGhlIGluZGl2aWR1YWwgcHJvbWlzZXNcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9vbFJlc3BvbnNlcztcblxuICB9IGNhdGNoIChlcnJvcikgeyAvLyBDYXRjaCBlcnJvcnMgZnJvbSB0aGUgZW50aXJlIHJ1bkNvbnZlcnNhdGlvbiBmbG93XG4gICAgY29uc29sZS5lcnJvcihcIkZBVEFMIEVycm9yIGluIHJ1bkNvbnZlcnNhdGlvbiBwaXBlbGluZTpcIiwgZXJyb3IpO1xuICAgIC8vIExvZyBoaXN0b3J5IHNwZWNpZmljYWxseSBmb3IgNDAwIGVycm9ycyB0byBoZWxwIGRlYnVnIHNlcXVlbmNlIGlzc3Vlc1xuICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWVzc2FnZSBoaXN0b3J5IGF0IHRpbWUgb2YgNDAwIGVycm9yOlwiLCBKU09OLnN0cmluZ2lmeShtZXNzYWdlcywgbnVsbCwgMikpO1xuICAgIH1cbiAgICByZXNwb25zZUNhbGxiYWNrPy4oeyB0eXBlOiAnZXJyb3InLCBjb250ZW50OiBgQW4gZXJyb3Igb2NjdXJyZWQ6ICR7ZXJyb3IubWVzc2FnZSB8fCBcIkNoZWNrIHNlcnZlciBsb2dzLlwifWAgfSk7XG4gICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuQ29udmVyc2F0aW9uKG1lc3NhZ2VzLCB1c2VySW5wdXQsIGNvbnZlcnNhdGlvbklkID0gbnVsbCwgdXNlcklkID0gJ2RlZmF1bHQnLCBhY2Nlc3NUb2tlbiA9IG51bGwsIHJlc3BvbnNlQ2FsbGJhY2sgPSBudWxsKSB7XG4gIGNvbnNvbGUubG9nKGBSdW5uaW5nIGNvbnZlcnNhdGlvbiAke2NvbnZlcnNhdGlvbklkfSBmb3IgdXNlciAke3VzZXJJZH0uIEFjY2Vzc1Rva2VuOiAkeyEhYWNjZXNzVG9rZW59YCk7XG4gICAgXG4gIGNvbnN0IG1vZGVsID0gXCJncHQtNG9cIjsgLy8gVXNlIGEgY2FwYWJsZSBtb2RlbCBmb3IgcmVhc29uaW5nXG4gIGNvbnN0IG1heFRvb2xJdGVyYXRpb25zID0gNTsgLy8gTGltaXQgc2VxdWVudGlhbCB0b29sIGNhbGxzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcblxuICB0cnkge1xuICAgICAgbGV0IGN1cnJlbnRNZXNzYWdlcyA9IFsuLi5tZXNzYWdlc107IC8vIFVzZSBhIG11dGFibGUgY29weSBmb3IgdGhpcyB0dXJuXG4gICAgICBsZXQgaXRlcmF0aW9uID0gMDtcbiAgICAgIGxldCBmaW5hbENvbnRlbnQgPSBudWxsOyAvLyBTdG9yZXMgdGhlIGZpbmFsIHRleHQgcmVzcG9uc2UgZm9yIHRoZSB1c2VyXG5cbiAgICAgIC8vIEhlbHBlciB0byBmaWx0ZXIgbWVzc2FnZXMgKEtlZXAgZXhpc3RpbmcgZmlsdGVyTWVzc2FnZXNGb3JBUEkpXG4gICAgICBjb25zdCBmaWx0ZXJNZXNzYWdlc0ZvckFQSSA9IChtc2dzKSA9PiB7XG4gICAgICAgICAgLy8gLi4uIChrZWVwIGV4aXN0aW5nIGltcGxlbWVudGF0aW9uKSAuLi5cbiAgICAgICAgICAgaWYgKCFtc2dzIHx8ICFBcnJheS5pc0FycmF5KG1zZ3MpKSB7XG4gICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgbWVzc2FnZXMgYXJyYXkgcGFzc2VkIHRvIGZpbHRlcjpcIiwgbXNncyk7XG4gICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgdG8gcHJldmVudCBmdXJ0aGVyIGVycm9yc1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSB0byBhdm9pZCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTXNncyA9IFsuLi5tc2dzXTtcblxuICAgICAgICAgICAvLyBUcmFjayB0b29sIGNhbGwgSURzIGZyb20gYXNzaXN0YW50IG1lc3NhZ2VzXG4gICAgICAgICAgIGNvbnN0IHZhbGlkVG9vbENhbGxJZHMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAgLy8gRmlyc3QgcGFzczogY29sbGVjdCBhbGwgdmFsaWQgdG9vbCBjYWxsIElEcyBmcm9tIGFzc2lzdGFudCBtZXNzYWdlc1xuICAgICAgICAgICBmaWx0ZXJlZE1zZ3MuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgIGlmIChtc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgbXNnLnRvb2xfY2FsbHMgJiYgQXJyYXkuaXNBcnJheShtc2cudG9vbF9jYWxscykpIHtcbiAgICAgICAgICAgICAgIG1zZy50b29sX2NhbGxzLmZvckVhY2godG9vbENhbGwgPT4ge1xuICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwuaWQpIHtcbiAgICAgICAgICAgICAgICAgICB2YWxpZFRvb2xDYWxsSWRzLmFkZCh0b29sQ2FsbC5pZCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgLy8gU2Vjb25kIHBhc3M6IGZpbHRlciBvdXQgaW52YWxpZCB0b29sIG1lc3NhZ2VzXG4gICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbHRlcmVkTXNncy5maWx0ZXIoKG1zZywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAvLyBLZWVwIGFsbCBub24tdG9vbCBtZXNzYWdlc1xuICAgICAgICAgICAgIGlmIChtc2cucm9sZSAhPT0gJ3Rvb2wnKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgIC8vIEZvciB0b29sIG1lc3NhZ2VzLCBjaGVjayBpZiB0aGV5IGhhdmUgYSB2YWxpZCB0b29sX2NhbGxfaWRcbiAgICAgICAgICAgICBpZiAoIW1zZy50b29sX2NhbGxfaWQpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmlsdGVyaW5nIFRPT0wgbWVzc2FnZSB3aXRoIG1pc3NpbmcgdG9vbF9jYWxsX2lkIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyB0b29sIG1lc3NhZ2UgaGFzIGEgY29ycmVzcG9uZGluZyB0b29sIGNhbGwgZnJvbSBhbiBhc3Npc3RhbnRcbiAgICAgICAgICAgICBpZiAoIXZhbGlkVG9vbENhbGxJZHMuaGFzKG1zZy50b29sX2NhbGxfaWQpKSB7XG4gICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZpbHRlcmluZyBUT09MIG1lc3NhZ2Ugbm90IGNvcnJlY3RseSBwcmVjZWRlZCBieSBhc3Npc3RhbnQgdG9vbF9jYWxsLiBJbmRleD0ke2luZGV4fSwgVG9vbENhbGxJRD0ke21zZy50b29sX2NhbGxfaWR9YCk7XG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIC8vIEFsc28gZW5zdXJlIGNvbnRlbnQgZXhpc3RzIGZvciB0b29sIG1lc3NhZ2VzXG4gICAgICAgICAgICAgaWYgKG1zZy5jb250ZW50ID09IG51bGwgfHwgbXNnLmNvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZpbHRlcmluZyBUT09MIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nL2VtcHR5IGNvbnRlbnQuIEluZGV4PSR7aW5kZXh9LCBUb29sQ2FsbElEPSR7bXNnLnRvb2xfY2FsbF9pZH1gKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZpbmFsIHNhbml0eSBjaGVjazogRW5zdXJlIGFsdGVybmF0aW5nIHVzZXIvYXNzaXN0YW50L3Rvb2wgc2VxdWVuY2Ugd2hlcmUgYXBwcm9wcmlhdGVcbiAgICAgICAgICAgLy8gUmVtb3ZlIGNvbnNlY3V0aXZlIG1lc3NhZ2VzIG9mIHRoZSBzYW1lIHJvbGUgKGV4Y2VwdCAndG9vbCcgd2hpY2ggZm9sbG93cyAnYXNzaXN0YW50JylcbiAgICAgICAgICAgY29uc3QgZmluYWxGaWx0ZXJlZCA9IFtdO1xuICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TXNnID0gcmVzdWx0W2ldO1xuICAgICAgICAgICAgICBjb25zdCBwcmV2TXNnID0gZmluYWxGaWx0ZXJlZFtmaW5hbEZpbHRlcmVkLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2TXNnICYmIGN1cnJlbnRNc2cucm9sZSA9PT0gcHJldk1zZy5yb2xlICYmIGN1cnJlbnRNc2cucm9sZSAhPT0gJ3Rvb2wnKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZpbHRlcmluZyBjb25zZWN1dGl2ZSBtZXNzYWdlIG9mIHJvbGUgJHtjdXJyZW50TXNnLnJvbGV9IGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIGFkZGluZyB0aGUgY29uc2VjdXRpdmUgbWVzc2FnZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEVuc3VyZSB0b29sIG1lc3NhZ2UgZm9sbG93cyBhbiBhc3Npc3RhbnQgbWVzc2FnZSAobG9vc2VseSwgZmlsdGVyIGhhbmRsZXMgc3BlY2lmaWMgSUQgbWF0Y2hpbmcpXG4gICAgICAgICAgICAgIC8vIGlmIChjdXJyZW50TXNnLnJvbGUgPT09ICd0b29sJyAmJiAoIXByZXZNc2cgfHwgcHJldk1zZy5yb2xlICE9PSAnYXNzaXN0YW50JykpIHtcbiAgICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUud2FybihgRmlsdGVyaW5nIFRPT0wgbWVzc2FnZSBub3QgZm9sbG93aW5nIGFuIGFzc2lzdGFudCBtZXNzYWdlIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgICAgICAgLy8gICAgIGNvbnRpbnVlOyAvLyBTa2lwIGFkZGluZyB0aGUgb3V0LW9mLXBsYWNlIHRvb2wgbWVzc2FnZVxuICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgZmluYWxGaWx0ZXJlZC5wdXNoKGN1cnJlbnRNc2cpO1xuICAgICAgICAgICB9XG5cblxuICAgICAgICAgICBjb25zb2xlLmxvZyhgRmlsdGVyZWQgJHttc2dzLmxlbmd0aCAtIGZpbmFsRmlsdGVyZWQubGVuZ3RofSBpbnZhbGlkL21hbGZvcm1lZCBtZXNzYWdlc2ApO1xuICAgICAgICAgICByZXR1cm4gZmluYWxGaWx0ZXJlZDtcbiAgICAgIH07XG5cblxuICAgICAgLy8gLS0tIE1haW4gUmVhc29uaW5nIExvb3AgLS0tXG4gICAgICB3aGlsZSAoaXRlcmF0aW9uIDwgbWF4VG9vbEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBpdGVyYXRpb24rKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhgXFxuLS0tIENvbnZlcnNhdGlvbiBUdXJuICR7aXRlcmF0aW9ufS8ke21heFRvb2xJdGVyYXRpb25zfSAtLS1gKTtcblxuICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzRm9yQVBJID0gZmlsdGVyTWVzc2FnZXNGb3JBUEkoY3VycmVudE1lc3NhZ2VzKTtcbiAgICAgICAgICBpZiAobWVzc2FnZXNGb3JBUEkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNZXNzYWdlIGhpc3RvcnkgYmVjYW1lIGVtcHR5IGR1cmluZyBmaWx0ZXJpbmcuXCIpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogQ2Fubm90IHByb2NlZWQgd2l0aCBlbXB0eSBtZXNzYWdlIGhpc3RvcnkuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICoqKioqIERFQlVHIExPRyAqKioqKlxuICAgICAgICAgIGNvbnNvbGUubG9nKGBNYWtpbmcgQVBJIGNhbGwgIyR7aXRlcmF0aW9ufSB3aXRoIG1vZGVsOiAke21vZGVsfWApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBNZXNzYWdlIEhpc3RvcnkgKExlbmd0aDogJHttZXNzYWdlc0ZvckFQSS5sZW5ndGh9KTpgKTtcbiAgICAgICAgICBtZXNzYWdlc0ZvckFQSS5mb3JFYWNoKChtc2csIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIFske2luZGV4fV0gUm9sZTogJHttc2cucm9sZX1gKTtcbiAgICAgICAgICAgICAgaWYgKG1zZy5jb250ZW50KSBjb25zb2xlLmxvZyhgICAgICAgQ29udGVudDogJHtTdHJpbmcobXNnLmNvbnRlbnQpLnN1YnN0cmluZygwLCAxMDApfS4uLmApOyAvLyBUcnVuY2F0ZSwgZW5zdXJlIHN0cmluZ1xuICAgICAgICAgICAgICBpZiAobXNnLnRvb2xfY2FsbHMpIGNvbnNvbGUubG9nKGAgICAgICBUb29sIENhbGxzOiAke0pTT04uc3RyaW5naWZ5KG1zZy50b29sX2NhbGxzLm1hcCh0YyA9PiB0Yy5pZCArIFwiOlwiICsgdGMuZnVuY3Rpb24/Lm5hbWUpKX1gKTtcbiAgICAgICAgICAgICAgaWYgKG1zZy50b29sX2NhbGxfaWQpIGNvbnNvbGUubG9nKGAgICAgICBUb29sIENhbGwgSUQ6ICR7bXNnLnRvb2xfY2FsbF9pZH1gKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgLS0tIEVuZCBBUEkgQ2FsbCAjJHtpdGVyYXRpb259IEhpc3RvcnkgLS0tIFxcbmApO1xuICAgICAgICAgIC8vICoqKioqIEVORCBERUJVRyBMT0cgKioqKipcblxuICAgICAgICAgIC8vIC0tLSBDYWxsIE9wZW5BSSAtLS1cbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzRm9yQVBJLFxuICAgICAgICAgICAgICB0b29sczogdG9vbHMsIC8vIE1ha2UgdG9vbHMgYXZhaWxhYmxlIG9uIGV2ZXJ5IHR1cm5cbiAgICAgICAgICAgICAgdG9vbF9jaG9pY2U6IFwiYXV0b1wiLCAvLyBMZXQgdGhlIG1vZGVsIGRlY2lkZSBpZiBpdCBuZWVkcyB0b29sc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gcmVzcG9uc2UuY2hvaWNlc1swXS5tZXNzYWdlO1xuXG4gICAgICAgICAgLy8gLS0tIEFkZCBBc3Npc3RhbnQgTWVzc2FnZSB0byBIaXN0b3J5IChMb2NhbCAmIERCKSAtLS1cbiAgICAgICAgICBjdXJyZW50TWVzc2FnZXMucHVzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChjb252ZXJzYXRpb25JZCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgYWRkTWVzc2FnZVRvQ29udmVyc2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlLmNvbnRlbnQgfHwgbnVsbCwgLy8gU3RvcmUgbnVsbCBpZiBubyBjb250ZW50IFxuICAgICAgICAgICAgICAgICAgICAgIHsgdG9vbF9jYWxsczogcmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgfHwgbnVsbCB9IC8vIEFsd2F5cyBwYXNzIGFuIG9iamVjdCwgZXZlbiBpZiB0b29sX2NhbGxzIGlzIG51bGxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGRiRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYERCIEVycm9yIHN0b3JpbmcgYXNzaXN0YW50IG1lc3NhZ2UgKGl0ZXJhdGlvbiAke2l0ZXJhdGlvbn0pOmAsIGRiRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiBEQiBzdG9yZSBmYWlscyBmb3IgdGhpcyBtZXNzYWdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAtLS0gQ2hlY2sgZm9yIFRvb2wgQ2FsbHMgLS0tXG4gICAgICAgICAgY29uc3QgYXNzaXN0YW50VG9vbENhbGxzID0gcmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHM7XG5cbiAgICAgICAgICBpZiAoYXNzaXN0YW50VG9vbENhbGxzICYmIGFzc2lzdGFudFRvb2xDYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBc3Npc3RhbnQgcmVxdWVzdGVkICR7YXNzaXN0YW50VG9vbENhbGxzLmxlbmd0aH0gdG9vbCBjYWxsKHMpIGluIGl0ZXJhdGlvbiAke2l0ZXJhdGlvbn06YCwgSlNPTi5zdHJpbmdpZnkoYXNzaXN0YW50VG9vbENhbGxzLm1hcCh0YyA9PiAoeyBpZDogdGMuaWQsIG5hbWU6IHRjLmZ1bmN0aW9uPy5uYW1lIH0pKSkpO1xuXG4gICAgICAgICAgICAgIC8vIEluZm9ybSBjbGllbnQgd2UncmUgcHJvY2Vzc2luZyB3aXRoIG1vcmUgc3BlY2lmaWMgaW5mb3JtYXRpb25cblxuICAgICAgICAgICAgICAvLyAtLS0gUHJvY2VzcyB0aGUgcmVxdWVzdGVkIHRvb2xzIC0tLVxuICAgICAgICAgICAgICAvLyBwcm9jZXNzVG9vbENhbGxzIGFkZHMgdGhlIHRvb2wgcmVzcG9uc2VzIHRvIGN1cnJlbnRNZXNzYWdlcyBhbmQgc3RvcmVzIHRoZW0gaW4gREJcbiAgICAgICAgICAgICAgY29uc3QgdG9vbFJlc3BvbnNlcyA9IGF3YWl0IHByb2Nlc3NUb29sQ2FsbHMoYXNzaXN0YW50VG9vbENhbGxzLCBjdXJyZW50TWVzc2FnZXMsIGNvbnZlcnNhdGlvbklkLCB1c2VySWQsIGFjY2Vzc1Rva2VuLCByZXNwb25zZUNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgdG9vbCBjYWxsIGZhaWxlZCBjcml0aWNhbGx5LCBtYXliZSBzdG9wIGVhcmx5PyAoT3B0aW9uYWwgZW5oYW5jZW1lbnQpXG4gICAgICAgICAgICAgIGNvbnN0IGhhc0NyaXRpY2FsRmFpbHVyZSA9IHRvb2xSZXNwb25zZXMuc29tZSh0ciA9PiB0ci5jb250ZW50Py5pbmNsdWRlcygnKFN0YXR1czogRkFJTEVEKScpKTtcbiAgICAgICAgICAgICAgaWYgKGhhc0NyaXRpY2FsRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ3JpdGljYWwgdG9vbCBmYWlsdXJlIGRldGVjdGVkIGluIGl0ZXJhdGlvbiAke2l0ZXJhdGlvbn0uIExMTSB3aWxsIGJlIGluZm9ybWVkLmApO1xuICAgICAgICAgICAgICAgICAgIC8vIExldCB0aGUgbG9vcCBjb250aW51ZSwgTExNIHNob3VsZCBzZWUgdGhlIGZhaWx1cmUgbWVzc2FnZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gLS0tIExvb3AgY29udGludWVzOiBTZW5kIHRvb2wgcmVzdWx0cyBiYWNrIHRvIExMTSAtLS1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIC0tLSBObyBUb29sIENhbGxzOiBUaGlzIGlzIHRoZSBmaW5hbCByZXNwb25zZSAtLS1cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYE5vIHRvb2wgY2FsbHMgcmVxdWVzdGVkIGluIGl0ZXJhdGlvbiAke2l0ZXJhdGlvbn0uIEZpbmFsIHJlc3BvbnNlIGdlbmVyYXRlZC5gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEZvciBnZW5lcmFsIHF1ZXN0aW9ucyAobm8gdG9vbCBjYWxscyksIGdvIGRpcmVjdGx5IGZyb20gXCJBbmFseXppbmcgUmVxdWVzdFwiIHRvIFwiR2VuZXJhdGluZyBSZXNwb25zZVwiXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBNYXJrIFwiR2VuZXJhdGluZyBSZXNwb25zZVwiIGFzIGNvbXBsZXRlIGJlZm9yZSBzZW5kaW5nIHRoZSBmaW5hbCBjb250ZW50XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZUNhbGxiYWNrICYmIGl0ZXJhdGlvbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGNvbXBsZXRpb24gaW1tZWRpYXRlbHkgdG8gZW5zdXJlIGl0J3MgbWFya2VkIGJlZm9yZSB0aGUgcmVzcG9uc2UgaXMgc2hvd25cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5vdyBoYW5kbGVkIGluIHRoZSB0b29sIHByb2Nlc3Npbmcgc2VjdGlvbiB3aXRoIHNwZWNpZmljIHRpbWluZyBmb3IgdG9vbCBjYWxsc1xuICAgICAgICAgICAgICAgIC8vIEZvciBub24tdG9vbCBjYWxscywgaXQncyBoYW5kbGVkIGluIHRoZSBlbHNlIGJsb2NrIGFib3ZlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGZpbmFsQ29udGVudCA9IHJlc3BvbnNlTWVzc2FnZS5jb250ZW50ID8/IFwiXCI7IC8vIFVzZSBudWxsaXNoIGNvYWxlc2NpbmcgZm9yIHNhZmV0eVxuICAgICAgICAgICAgICBicmVhazsgLy8gRXhpdCB0aGUgbG9vcFxuICAgICAgICAgIH1cbiAgICAgIH0gLy8gRW5kIG9mIHdoaWxlIGxvb3BcblxuICAgICAgLy8gLS0tIEhhbmRsZSBsb29wIGV4aXQgLS0tXG4gICAgICBpZiAoaXRlcmF0aW9uID49IG1heFRvb2xJdGVyYXRpb25zKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBNYXhpbXVtIHRvb2wgaXRlcmF0aW9ucyAoJHttYXhUb29sSXRlcmF0aW9uc30pIHJlYWNoZWQuIFJldHVybmluZyBsYXN0IGdlbmVyYXRlZCBjb250ZW50IG9yIGVycm9yLmApO1xuICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcmV0dXJuIHRoZSBsYXN0IGNvbnRlbnQgZ2VuZXJhdGVkLCBldmVuIGlmIGl0IHdhc24ndCBpbnRlbmRlZCBhcyBmaW5hbFxuICAgICAgICAgIGNvbnN0IGxhc3RBc3Npc3RhbnRNc2cgPSBjdXJyZW50TWVzc2FnZXNbY3VycmVudE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0QXNzaXN0YW50TXNnPy5yb2xlID09PSAnYXNzaXN0YW50JyAmJiBsYXN0QXNzaXN0YW50TXNnLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgIGZpbmFsQ29udGVudCA9IGxhc3RBc3Npc3RhbnRNc2cuY29udGVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaW5hbENvbnRlbnQgPSBcIkkgc2VlbSB0byBiZSBzdHVjayBpbiBhIGxvb3AgdHJ5aW5nIHRvIHByb2Nlc3MgdGhhdCByZXF1ZXN0LiBDb3VsZCB5b3UgdHJ5IHJlcGhyYXNpbmcgaXQ/XCI7XG4gICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2s/Lih7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IGZpbmFsQ29udGVudCB9KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbENvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTG9vcCBmaW5pc2hlZCB3aXRob3V0IGdlbmVyYXRpbmcgZmluYWwgY29udGVudC5cIik7XG4gICAgICAgICAgZmluYWxDb250ZW50ID0gXCJTb3JyeSwgSSB3YXNuJ3QgYWJsZSB0byBnZW5lcmF0ZSBhIGZpbmFsIHJlc3BvbnNlIGFmdGVyIHByb2Nlc3NpbmcgeW91ciByZXF1ZXN0LlwiO1xuICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2s/Lih7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IGZpbmFsQ29udGVudCB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tIFN0cmVhbSB0aGUgRklOQUwgcmVzcG9uc2UgLS0tXG4gICAgICBpZiAocmVzcG9uc2VDYWxsYmFjayAmJiBmaW5hbENvbnRlbnQpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgXCJHZW5lcmF0aW5nIFJlc3BvbnNlXCIgaXMgbWFya2VkIGFzIGNvbXBsZXRlIGJlZm9yZSBzZW5kaW5nIGNvbnRlbnRcbiAgICAgICAgICAvLyBUaGlzIGlzIG5vdyBoYW5kbGVkIGVhcmxpZXIgd2l0aCBhIGRlbGF5XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBwZW5kaW5nIGV2ZW50IGRhdGEgdG8gc2VuZFxuICAgICAgICAgIGlmIChnbG9iYWwucGVuZGluZ0V2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAvLyBBZGQgYSBkZWxheSBiZWZvcmUgc2VuZGluZyB0aGUgZmluYWwgY29udGVudCB0byBlbnN1cmUgYWxsIHByb2Nlc3Npbmcgc3RlcHMgYXJlIHZpc2libGVcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEyMDApKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGV2ZW50IGRhdGFcbiAgICAgICAgICAgICAgcmVzcG9uc2VDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnRzJyxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZpbmFsQ29udGVudCwgLy8gVXNlIHRoZSBmaW5hbCBjb250ZW50IGFzIHRoZSBtZXNzYWdlIHRleHRcbiAgICAgICAgICAgICAgICAgIGV2ZW50czogZ2xvYmFsLnBlbmRpbmdFdmVudERhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgcGVuZGluZyBldmVudCBkYXRhXG4gICAgICAgICAgICAgIGdsb2JhbC5wZW5kaW5nRXZlbnREYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFNob3J0IGRlbGF5IGJlZm9yZSBlbmRcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2soeyB0eXBlOiAnZW5kJyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSBiZWZvcmUgc2VuZGluZyBjb250ZW50IHRvIGVuc3VyZSBhbGwgcHJvY2Vzc2luZyBzdGVwcyBhcmUgdmlzaWJsZSBhbmQgbWFya2VkIGNvbXBsZXRlXG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMjAwKSk7XG4gICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2soeyB0eXBlOiAnY29udGVudCcsIGNvbnRlbnQ6IGZpbmFsQ29udGVudCB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7IC8vIFNob3J0IGRlbGF5IGJlZm9yZSBlbmRcbiAgICAgICAgICAgICAgcmVzcG9uc2VDYWxsYmFjayh7IHR5cGU6ICdlbmQnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3BvbnNlQ2FsbGJhY2sgJiYgZmluYWxDb250ZW50KSB7XG4gICAgICAgICAgLy8gTm9uLXN0cmVhbWluZyBtb2RlOiByZXR1cm4gdGhlIGZpbmFsIGNvbnRlbnRcbiAgICAgICAgICByZXR1cm4gZmluYWxDb250ZW50O1xuICAgICAgfSBlbHNlIGlmICghZmluYWxDb250ZW50KSB7XG4gICAgICAgICAgIC8vIEVuc3VyZSBzb21ldGhpbmcgaXMgcmV0dXJuZWQvc2VudCBldmVuIGlmIGNvbnRlbnQgaXMgZW1wdHkvbnVsbFxuICAgICAgICAgICBpZiAocmVzcG9uc2VDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2soeyB0eXBlOiAnY29udGVudCcsIGNvbnRlbnQ6ICcnIH0pOyAvLyBTZW5kIGVtcHR5IGNvbnRlbnRcbiAgICAgICAgICAgICAgICByZXNwb25zZUNhbGxiYWNrKHsgdHlwZTogJ2VuZCcgfSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiRmluYWwgcmVzcG9uc2UgY29udGVudDpcIiwgZmluYWxDb250ZW50KTtcbiAgICAgIC8vIFRoZSBmdW5jdGlvbiBpbXBsaWNpdGx5IHJldHVybnMgZmluYWxDb250ZW50IGlmIG5vdCBzdHJlYW1pbmcsIG9yIGhhbmRsZXMgc3RyZWFtaW5nIHZpYSBjYWxsYmFja1xuICAgICAgcmV0dXJuIGZpbmFsQ29udGVudDsgLy8gUmV0dXJuIGZvciBub24tc3RyZWFtaW5nIGNhc2VcblxuXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8vIENhdGNoIGVycm9ycyBmcm9tIHRoZSBlbnRpcmUgcnVuQ29udmVyc2F0aW9uIGZsb3dcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGQVRBTCBFcnJvciBpbiBydW5Db252ZXJzYXRpb24gcGlwZWxpbmU6XCIsIGVycm9yKTtcbiAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNZXNzYWdlIGhpc3RvcnkgYXQgdGltZSBvZiA0MDAgZXJyb3I6XCIsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzLCBudWxsLCAyKSk7IC8vIExvZyBpbml0aWFsIGhpc3Rvcnkgc3RhdGVcbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSBlcnJvciBpcyBwcm9wYWdhdGVkIHRvIHRoZSBjbGllbnRcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBBbiBlcnJvciBvY2N1cnJlZDogJHtlcnJvci5tZXNzYWdlIHx8IFwiQ2hlY2sgc2VydmVyIGxvZ3MuXCJ9YDtcbiAgICAgIHJlc3BvbnNlQ2FsbGJhY2s/Lih7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IGVycm9yTWVzc2FnZSB9KTtcbiAgICAgIC8vIFRocm93IG9yIHJldHVybiBlcnJvciBzdHJpbmcgYmFzZWQgb24gZXhwZWN0ZWQgY2FsbGVyIGJlaGF2aW9yXG4gICAgICAvLyB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3dpbmcgbWlnaHQgYmUgYmV0dGVyIGZvciBjaGF0KCkgZnVuY3Rpb24gdG8gY2F0Y2hcbiAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7IC8vIE9yIHJldHVybiBlcnJvciBzdHJpbmcgZm9yIG5vbi1zdHJlYW1pbmdcbiAgfVxufVxuXG5cbi8vIC0tLSBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IHVzZXIgcHJlZmVyZW5jZXMgLS0tXG5mdW5jdGlvbiBmb3JtYXRVc2VyUHJlZmVyZW5jZXMocHJlZmVyZW5jZXNEYXRhKSB7XG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBwcmVmZXJlbmNlc0RhdGEgbWlnaHQgYmUgYSBTZXF1ZWxpemUgbW9kZWwgaW5zdGFuY2VcbiAgLy8gb3IgbWlnaHQgaGF2ZSBhIGRhdGFWYWx1ZXMgcHJvcGVydHlcbiAgbGV0IGFjdHVhbFByZWZzRGF0YSA9IHByZWZlcmVuY2VzRGF0YTtcbiAgXG4gIC8vIElmIGl0J3MgYSBTZXF1ZWxpemUgbW9kZWwgaW5zdGFuY2Ugd2l0aCBkYXRhVmFsdWVzXG4gIGlmIChwcmVmZXJlbmNlc0RhdGEgJiYgdHlwZW9mIHByZWZlcmVuY2VzRGF0YSA9PT0gJ29iamVjdCcgJiYgcHJlZmVyZW5jZXNEYXRhLmRhdGFWYWx1ZXMpIHtcbiAgICBhY3R1YWxQcmVmc0RhdGEgPSBwcmVmZXJlbmNlc0RhdGEuZGF0YVZhbHVlcztcbiAgICBjb25zb2xlLmxvZyhcIkRFQlVHOiBVc2luZyBkYXRhVmFsdWVzIGZyb20gcHJlZmVyZW5jZXNEYXRhIG9iamVjdFwiKTtcbiAgfVxuICBcbiAgLy8gTG9nIHRoZSBhY3R1YWwgZGF0YSB3ZSdyZSB3b3JraW5nIHdpdGhcbiAgY29uc29sZS5sb2coXCJERUJVRzogQWN0dWFsIHByZWZlcmVuY2VzIGRhdGEgdG8gZm9ybWF0OlwiLCBKU09OLnN0cmluZ2lmeShhY3R1YWxQcmVmc0RhdGEpKTtcbiAgXG4gIC8vIENoZWNrIGlmIHdlIGhhdmUgdmFsaWQgZGF0YSB0byBmb3JtYXRcbiAgaWYgKCFwcmVmZXJlbmNlc0RhdGEgfHwgT2JqZWN0LmtleXMocHJlZmVyZW5jZXNEYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmxvZyhcIkRFQlVHOiBmb3JtYXRVc2VyUHJlZmVyZW5jZXMgY2FsbGVkIHdpdGggZW1wdHkgb3IgdW5kZWZpbmVkIHByZWZlcmVuY2VzRGF0YTpcIiwgXG4gICAgICBKU09OLnN0cmluZ2lmeShwcmVmZXJlbmNlc0RhdGEpKTtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICAvLyBGb3JtYXQgcHJlZmVyZW5jZXMgYXMgYSBjbGVhciwgaHVtYW4tcmVhZGFibGUgc3RyaW5nXG4gICAgbGV0IHByZWZzU3RyaW5nID0gXCJcXG5cXG5Vc2VyIFByZWZlcmVuY2VzIENvbnRleHQgKENvbnNpZGVyIHdoZW4gcmVsZXZhbnQpOlxcblwiO1xuICAgIHByZWZzU3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KGFjdHVhbFByZWZzRGF0YSwgbnVsbCwgMik7XG4gICAgY29uc29sZS5sb2coXCJERUJVRzogRm9ybWF0dGVkIHByZWZlcmVuY2VzIHN0cmluZzpcIiwgcHJlZnNTdHJpbmcpO1xuICAgIHJldHVybiBwcmVmc1N0cmluZztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZm9ybWF0dGluZyB1c2VyIHByZWZlcmVuY2VzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIFwiXCI7IC8vIFJldHVybiBlbXB0eSBzdHJpbmcgb24gZXJyb3JcbiAgfVxufVxuXG4vLyAtLS0gTWFpbiBDaGF0IEVudHJ5IFBvaW50IC0tLVxuYXN5bmMgZnVuY3Rpb24gY2hhdCh1c2VySW5wdXQsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsLCBzdHJlYW1DYWxsYmFjayA9IG51bGwsIHN0YXJ0TmV3Q29udmVyc2F0aW9uID0gZmFsc2UpIHsgLy8gQWRkZWQgc3RhcnROZXdDb252ZXJzYXRpb24gZmxhZ1xuICBjb25zb2xlLmxvZyhgQ2hhdCByZXF1ZXN0OiBVc2VyPSR7dXNlcklkfSwgSW5wdXQ9XCIke3VzZXJJbnB1dH1cIiwgU3RhcnROZXc9JHtzdGFydE5ld0NvbnZlcnNhdGlvbn1gKTsgLy8gTG9nIHRoZSBmbGFnXG4gIFxuICAvLyBTdG9yZSB0aGUgc3RyZWFtQ2FsbGJhY2sgaW4gdGhlIGdsb2JhbCB2YXJpYWJsZVxuICBnbG9iYWwuY3VycmVudFJlc3BvbnNlQ2FsbGJhY2sgPSBzdHJlYW1DYWxsYmFjaztcbiAgXG4gIGlmICghdXNlcklkIHx8IHVzZXJJZCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgc3RyZWFtQ2FsbGJhY2s/Lih7IHR5cGU6ICdlcnJvcicsIGNvbnRlbnQ6IFwiVXNlciBJRCBtaXNzaW5nLlwiIH0pO1xuICAgIHJldHVybiBcIkVycm9yOiBVc2VyIElEIHJlcXVpcmVkLlwiO1xuICB9XG4gICBpZiAoIXVzZXJJbnB1dD8udHJpbSgpKSB7XG4gICAgICAgc3RyZWFtQ2FsbGJhY2s/Lih7IHR5cGU6ICdpbmZvJywgY29udGVudDogXCJFbnRlciBhIG1lc3NhZ2UuXCIgfSk7IHJldHVybiBcIlwiO1xuICAgfVxuXG4gICAvLyBTZW5kICdzdGFydCcgc2lnbmFsIGltbWVkaWF0ZWx5IGZvciBzdHJlYW1pbmdcbiAgIHN0cmVhbUNhbGxiYWNrPy4oeyB0eXBlOiAnc3RhcnQnIH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW5zID0gYWNjZXNzVG9rZW4gPyB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfSA6IG51bGw7XG4gICAgbGV0IHVzZXI7XG4gICAgbGV0IGNvbnZlcnNhdGlvbjtcbiAgICBsZXQgaGlzdG9yeU1lc3NhZ2VzID0gW107IC8vIEZvcm1hdHRlZCBoaXN0b3J5IGZvciBPcGVuQUkgQVBJXG5cbiAgICAvLyAtLS0gTG9hZCBVc2VyICYgQ29udmVyc2F0aW9uIEhpc3RvcnkgLS0tXG4gICAgaWYgKCFzdGFydE5ld0NvbnZlcnNhdGlvbikge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gKipGSVg6KiogVXNlIHRoZSBvcHRpbWl6ZWQgcXVlcnlcbiAgICAgICAgdXNlciA9IGF3YWl0IGdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uKHVzZXJJZCk7XG5cbiAgICAgICAgaWYgKHVzZXI/LkNvbnZlcnNhdGlvbnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbiA9IHVzZXIuQ29udmVyc2F0aW9uc1swXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBhY3RpdmUgY29udmVyc2F0aW9uICR7Y29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZH1gKTtcbiAgICAgICAgICAgIGlmIChjb252ZXJzYXRpb24uQ29udmVyc2F0aW9uTWVzc2FnZXM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IEFTQ0VORElORyBmb3IgQVBJXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uLkNvbnZlcnNhdGlvbk1lc3NhZ2VzLnNvcnQoKGEsIGIpID0+IGEuc2VxdWVuY2VfbnVtYmVyIC0gYi5zZXF1ZW5jZV9udW1iZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gKipDUklUSUNBTCBGSVg6IFJvYnVzdCBIaXN0b3J5IE1hcHBpbmcqKlxuICAgICAgICAgICAgICAgIGhpc3RvcnlNZXNzYWdlcyA9IGNvbnZlcnNhdGlvbi5Db252ZXJzYXRpb25NZXNzYWdlcy5tYXAoKG1zZywgaW5kZXgsIGFsbE1zZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZU9iamVjdCA9IHsgcm9sZTogbXNnLnJvbGUgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50OiBNYW5kYXRvcnkgdW5sZXNzIGFzc2lzdGFudCB3LyB0b29sIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2cuY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBtc2cuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgbXNnLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0b29sX2NhbGxzIGZpZWxkIGFjdHVhbGx5IGNvbnRhaW5zIHZhbGlkIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbGlkVG9vbENhbGxzRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnLnRvb2xfY2FsbHMudG9vbF9jYWxscyAmJiBBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMpICYmIG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRUb29sQ2FsbHNFeGlzdCA9IG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMuc29tZSh0YyA9PiB0Yy5pZCAmJiB0Yy5mdW5jdGlvbj8ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzKSAmJiBtc2cudG9vbF9jYWxscy5sZW5ndGggPiAwKSB7IC8vIEhhbmRsZSBkaXJlY3QgYXJyYXkgc3RvcmFnZSBwb3NzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRUb29sQ2FsbHNFeGlzdCA9IG1zZy50b29sX2NhbGxzLnNvbWUodGMgPT4gdGMuaWQgJiYgdGMuZnVuY3Rpb24/Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRUb29sQ2FsbHNFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBudWxsOyAvLyBBUEkgZXhwZWN0cyBudWxsL1wiXCIgaWYgb25seSB0b29sX2NhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZU9iamVjdC5jb250ZW50ID0gXCJcIjsgLy8gVHJlYXQgYXMgZW1wdHkgY29udGVudCBpZiB0b29sX2NhbGxzIGludmFsaWQvZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBcIlwiOyAvLyBEZWZhdWx0IGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBUb29sIENhbGxzIChBc3Npc3RhbnQpOiBFeHRyYWN0IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAobXNnLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmIG1zZy50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9vbENhbGxzQXJyYXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAxOiBTdG9yZWQgYXMgeyB0b29sX2NhbGxzOiBbLi4uXSB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnLnRvb2xfY2FsbHMudG9vbF9jYWxscyAmJiBBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzLnRvb2xfY2FsbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzQXJyYXkgPSBtc2cudG9vbF9jYWxscy50b29sX2NhbGxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAyOiBTdG9yZWQgYXMgWy4uLl0gKGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy50b29sX2NhbGxzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsc0FycmF5ID0gbXNnLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBPTkxZIGlmIHZhbGlkIGFuZCBub24tZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbHNBcnJheSAmJiB0b29sQ2FsbHNBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkVG9vbENhbGxzID0gdG9vbENhbGxzQXJyYXkuZmlsdGVyKHRjID0+IHRjLmlkICYmIHRjLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgdGMuZnVuY3Rpb24/Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRUb29sQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZU9iamVjdC50b29sX2NhbGxzID0gdmFsaWRUb29sQ2FsbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1lbnN1cmUgY29udGVudCBpcyBudWxsIGlmIE9OTFkgdG9vbCBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VPYmplY3QuY29udGVudCA9PT0gXCJcIiAmJiB2YWxpZFRvb2xDYWxscy5sZW5ndGggPT09IHRvb2xDYWxsc0FycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlT2JqZWN0LmNvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYERCIG1lc3NhZ2UgJHttc2cubWVzc2FnZV9pZH0gaGFkIHRvb2xfY2FsbHMgb2JqZWN0IGJ1dCBubyB2YWxpZCBjYWxscy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGVtcHR5L2ludmFsaWQgdG9vbF9jYWxscyBhcnJheSB0byBBUEkgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUb29sIENhbGwgSUQgKFRvb2wpOiBFeHRyYWN0IHRoZSBJRCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5yb2xlID09PSAndG9vbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b29sSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMTogU3RvcmVkIGFzIHsgdG9vbF9jYWxsX2lkOiBcIi4uLlwiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNnLnRvb2xfY2FsbF9pZCA9PT0gJ29iamVjdCcgJiYgbXNnLnRvb2xfY2FsbF9pZCAhPT0gbnVsbCAmJiBtc2cudG9vbF9jYWxsX2lkLnRvb2xfY2FsbF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJZCA9IG1zZy50b29sX2NhbGxfaWQudG9vbF9jYWxsX2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMjogU3RvcmVkIGFzIFwiLi4uXCIgKGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnLnRvb2xfY2FsbF9pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sSWQgPSBtc2cudG9vbF9jYWxsX2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb29sIG1lc3NhZ2UgTVVTVCBoYXZlIElEIGFuZCBjb250ZW50IHRvIGJlIHZhbGlkIGZvciBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b29sSWQgJiYgbWVzc2FnZU9iamVjdC5jb250ZW50ICE9IG51bGwpIHsgLy8gQ29udGVudCBjb21lcyBmcm9tIGZvcm1hdFRvb2xSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VPYmplY3QudG9vbF9jYWxsX2lkID0gdG9vbElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZpbHRlcmluZyBpbnZhbGlkIFRPT0wgbWVzc2FnZSAobWlzc2luZyBJRCBvciBjb250ZW50KTogREJfSUQ9JHttc2cubWVzc2FnZV9pZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gRmlsdGVyIG91dCBpbnZhbGlkIHRvb2wgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQVBJIFZhbGlkYXRpb24gQ2hlY2s6IHRvb2wgcm9sZSBtdXN0IGZvbGxvdyBhc3Npc3RhbnQgcm9sZSB3aXRoIHRvb2xfY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgLy8gKipSRU1PVkVEIFNUUklDVCBQUkVDRURJTkcgQ0hFQ0sqKiAtIFJlbHlpbmcgb24gZmlsdGVyTWVzc2FnZXNGb3JBUEkgaW5zaWRlIHJ1bkNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAobWVzc2FnZU9iamVjdC5yb2xlID09PSAndG9vbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IHByZXZNYXBwZWRNZXNzYWdlID0gaW5kZXggPiAwID8gaGlzdG9yeU1lc3NhZ2VzW2luZGV4IC0gMV0gOiBudWxsOyAvLyBDaGVjayB0aGUgKm1hcHBlZCogcHJldmlvdXMgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFwcmV2TWFwcGVkTWVzc2FnZSB8fCBwcmV2TWFwcGVkTWVzc2FnZS5yb2xlICE9PSAnYXNzaXN0YW50JyB8fCAhcHJldk1hcHBlZE1lc3NhZ2UudG9vbF9jYWxscyB8fCAhcHJldk1hcHBlZE1lc3NhZ2UudG9vbF9jYWxscy5zb21lKHRjID0+IHRjLmlkID09PSBtZXNzYWdlT2JqZWN0LnRvb2xfY2FsbF9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgY29uc29sZS53YXJuKGBGaWx0ZXJpbmcgVE9PTCBtZXNzYWdlIG5vdCBjb3JyZWN0bHkgcHJlY2VkZWQgYnkgYXNzaXN0YW50IHRvb2xfY2FsbC4gREJfSUQ9JHttc2cubWVzc2FnZV9pZH0sIFRvb2xDYWxsSUQ9JHttZXNzYWdlT2JqZWN0LnRvb2xfY2FsbF9pZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgcmV0dXJuIG51bGw7IC8vIEZpbHRlciBvdXQgb3JwaGFuZWQvbWlzbWF0Y2hlZCB0b29sIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFzc2lzdGFudCBtZXNzYWdlcyB0aGF0IGVuZCB1cCBlbXB0eSAobm8gY29udGVudCwgbm8gdmFsaWQgdG9vbCBjYWxscylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VPYmplY3Qucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgbWVzc2FnZU9iamVjdC5jb250ZW50ID09IG51bGwgJiYgIW1lc3NhZ2VPYmplY3QudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmlsdGVyaW5nIGVtcHR5IEFTU0lTVEFOVCBtZXNzYWdlLiBEQl9JRD0ke21zZy5tZXNzYWdlX2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZU9iamVjdDtcblxuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTsgLy8gUmVtb3ZlIG51bGxzIGZyb20gZmlsdGVyaW5nXG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGVkIGFuZCBtYXBwZWQgJHtoaXN0b3J5TWVzc2FnZXMubGVuZ3RofSB2YWxpZCBtZXNzYWdlcyBmcm9tIGhpc3RvcnkuYCk7XG4gICAgICAgICAgICAgICAgLy8gREVCVUc6IExvZyB0aGUgZmluYWwgaGlzdG9yeSBiZWluZyBzZW50LCBPTkxZIEZPUiBERUJVR0dJTkcgU0VOU0lUSVZFIERBVEFcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkZpbmFsIGhpc3RvcnkgZm9yIEFQSTpcIiwgSlNPTi5zdHJpbmdpZnkoaGlzdG9yeU1lc3NhZ2VzLCBudWxsLCAyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ29udmVyc2F0aW9uICR7Y29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZH0gaGFzIG5vIG1lc3NhZ2VzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBleGlzdGluZyB1c2VyL2NvbnZlcnNhdGlvbiBmb3VuZCBmb3IgJHt1c2VySWR9LiBDcmVhdGluZy5gKTtcbiAgICAgICAgICAgICBpZiAoIXVzZXIpIHsgLy8gRW5zdXJlIHVzZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgIGNvbnN0IGlzRW1haWwgPSB1c2VySWQuaW5jbHVkZXMoJ0AnKTtcbiAgICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBpc0VtYWlsID8gdXNlcklkIDogYCR7dXNlcklkfUBleGFtcGxlLmNvbWA7XG4gICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gaXNFbWFpbCA/ICdlbWFpbCcgOiAnc3lzdGVtJzsgLy8gQWRqdXN0IGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgICB1c2VyID0gYXdhaXQgZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBwcm92aWRlciwgdXNlcklkLCB1c2VySWQpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDUklUSUNBTDogRXJyb3IgbG9hZGluZyB1c2VyL2hpc3Rvcnk6XCIsIGVycm9yKTtcbiAgICAgICAgdHJ5IHsgLy8gQXR0ZW1wdCByZWNvdmVyeVxuICAgICAgICAgICAgY29uc3QgaXNFbWFpbCA9IHVzZXJJZC5pbmNsdWRlcygnQCcpO1xuICAgICAgICAgICAgY29uc3QgZW1haWwgPSBpc0VtYWlsID8gdXNlcklkIDogYCR7dXNlcklkfUBleGFtcGxlLmNvbWA7XG4gICAgICAgICAgICB1c2VyID0gYXdhaXQgZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBpc0VtYWlsID8gJ2VtYWlsJyA6ICdzeXN0ZW0nLCB1c2VySWQsIHVzZXJJZCk7XG4gICAgICAgIH0gY2F0Y2ggKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNSSVRJQ0FMOiBGYWlsZWQgdXNlciByZWNvdmVyeTpcIiwgdXNlckVycm9yKTtcbiAgICAgICAgICAgIHN0cmVhbUNhbGxiYWNrPy4oeyB0eXBlOiAnZXJyb3InLCBjb250ZW50OiBcIkZhaWxlZCB0byBsb2FkIHVzZXIgcHJvZmlsZS5cIiB9KTtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBDb3VsZCBub3QgbG9hZCB1c2VyIHByb2ZpbGUuXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29udmVyc2F0aW9uID0gbnVsbDsgaGlzdG9yeU1lc3NhZ2VzID0gW107IC8vIFJlc2V0IHN0YXRlXG4gICAgfVxuICAgIH0gZWxzZSB7IC8vIEhhbmRsZSBzdGFydE5ld0NvbnZlcnNhdGlvbiA9IHRydWVcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydGluZyBhIG5ldyBjb252ZXJzYXRpb24gYXMgcmVxdWVzdGVkLlwiKTtcbiAgICAgICAgLy8gRW5zdXJlIHVzZXIgb2JqZWN0IGlzIGxvYWRlZCwgZXZlbiBpZiBoaXN0b3J5IGxvYWRpbmcgd2FzIHNraXBwZWRcbiAgICAgICAgY29uc29sZS5sb2coXCJERUJVRzogc3RhcnROZXdDb252ZXJzYXRpb249dHJ1ZSwgdXNlciBvYmplY3QgYmVmb3JlIGxvYWRpbmc6XCIsIHVzZXIgPyBgVXNlciBleGlzdHM6ICR7dXNlci51c2VyX2lkfWAgOiBcIlVzZXIgaXMgbnVsbFwiKTtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRW1haWwgPSB1c2VySWQuaW5jbHVkZXMoJ0AnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbCA9IGlzRW1haWwgPyB1c2VySWQgOiBgJHt1c2VySWR9QGV4YW1wbGUuY29tYDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgREVCVUc6IEFib3V0IHRvIGNhbGwgZ2V0T3JDcmVhdGVVc2VyIHdpdGggZW1haWw9JHtlbWFpbH1gKTtcbiAgICAgICAgICAgICAgICB1c2VyID0gYXdhaXQgZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBpc0VtYWlsID8gJ2VtYWlsJyA6ICdzeXN0ZW0nLCB1c2VySWQsIHVzZXJJZCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJERUJVRzogQWZ0ZXIgZ2V0T3JDcmVhdGVVc2VyIGNhbGwsIHVzZXIgb2JqZWN0OlwiLCBcbiAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcl9pZDogdXNlci51c2VyX2lkLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgaGFzVXNlclByZWZlcmVuY2U6ICEhdXNlci5Vc2VyUHJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlclByZWZlcmVuY2VLZXlzOiB1c2VyLlVzZXJQcmVmZXJlbmNlID8gT2JqZWN0LmtleXModXNlci5Vc2VyUHJlZmVyZW5jZSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXJlbmNlc0RhdGFLZXlzOiB1c2VyLlVzZXJQcmVmZXJlbmNlPy5wcmVmZXJlbmNlc19kYXRhID8gT2JqZWN0LmtleXModXNlci5Vc2VyUHJlZmVyZW5jZS5wcmVmZXJlbmNlc19kYXRhKSA6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDUklUSUNBTDogRmFpbGVkIHVzZXIgY3JlYXRpb24vcmV0cmlldmFsIHdoZW4gc3RhcnRpbmcgbmV3IGNvbnZlcnNhdGlvbjpcIiwgdXNlckVycm9yKTtcbiAgICAgICAgICAgICAgICBzdHJlYW1DYWxsYmFjaz8uKHsgdHlwZTogJ2Vycm9yJywgY29udGVudDogXCJGYWlsZWQgdG8gbG9hZCB1c2VyIHByb2ZpbGUgZm9yIG5ldyBjaGF0LlwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBDb3VsZCBub3QgbG9hZCB1c2VyIHByb2ZpbGUuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhwbGljaXRseSBjbGVhciBjb252ZXJzYXRpb24gYW5kIGhpc3RvcnlcbiAgICAgICAgY29udmVyc2F0aW9uID0gbnVsbDtcbiAgICAgICAgaGlzdG9yeU1lc3NhZ2VzID0gW107XG4gICAgfVxuXG4gICAgLy8gLS0tIENyZWF0ZSBDb252ZXJzYXRpb24gaWYgbmVlZGVkICYgQWRkIFN5c3RlbSBQcm9tcHQgLS0tXG4gICAgaWYgKCFjb252ZXJzYXRpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnZlcnNhdGlvbiA9IGF3YWl0IGNyZWF0ZUNvbnZlcnNhdGlvbih1c2VyLnVzZXJfaWQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ3JlYXRlZCBuZXcgY29udmVyc2F0aW9uICR7Y29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZH0uIFByZXBhcmluZyBzeXN0ZW0gcHJvbXB0LmApO1xuICAgICAgICAvLyBHZXQgYmFzZSBzeXN0ZW0gcHJvbXB0XG4gICAgICAgIGxldCBzeXN0ZW1Qcm9tcHRDb250ZW50ID0gZ2V0QXRoZW5hU3lzdGVtUHJvbXB0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEZWJ1ZyBsb2cgdGhlIHVzZXIgb2JqZWN0IHN0cnVjdHVyZVxuICAgICAgICBjb25zb2xlLmxvZyhcIkRFQlVHOiBVc2VyIG9iamVjdCBzdHJ1Y3R1cmUgd2hlbiBjcmVhdGluZyBuZXcgY29udmVyc2F0aW9uOlwiLCBcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VyLnVzZXJfaWQsXG4gICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgIGhhc1VzZXJQcmVmZXJlbmNlOiAhIXVzZXIuVXNlclByZWZlcmVuY2UsXG4gICAgICAgICAgICB1c2VyUHJlZmVyZW5jZURhdGFWYWx1ZXM6IHVzZXIuVXNlclByZWZlcmVuY2UgPyAhIXVzZXIuVXNlclByZWZlcmVuY2UuZGF0YVZhbHVlcyA6IG51bGwsXG4gICAgICAgICAgICBwcmVmZXJlbmNlc0RhdGFSYXc6IHVzZXIuVXNlclByZWZlcmVuY2UgPyB1c2VyLlVzZXJQcmVmZXJlbmNlLnByZWZlcmVuY2VzX2RhdGEgOiBudWxsLFxuICAgICAgICAgICAgcHJlZmVyZW5jZXNEYXRhRnJvbURhdGFWYWx1ZXM6IHVzZXIuVXNlclByZWZlcmVuY2UgPyB1c2VyLlVzZXJQcmVmZXJlbmNlLmRhdGFWYWx1ZXM/LnByZWZlcmVuY2VzX2RhdGEgOiBudWxsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvcm1hdCBhbmQgYXBwZW5kIHVzZXIgcHJlZmVyZW5jZXMgaWYgdGhleSBleGlzdFxuICAgICAgICAvLyBBY2Nlc3MgcHJlZmVyZW5jZXNfZGF0YSBmcm9tIGRhdGFWYWx1ZXMgaWYgZGlyZWN0IGFjY2VzcyBmYWlsc1xuICAgICAgICBjb25zdCBwcmVmZXJlbmNlc0RhdGEgPSB1c2VyLlVzZXJQcmVmZXJlbmNlPy5wcmVmZXJlbmNlc19kYXRhIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1c2VyLlVzZXJQcmVmZXJlbmNlPy5kYXRhVmFsdWVzID8gdXNlci5Vc2VyUHJlZmVyZW5jZS5kYXRhVmFsdWVzLnByZWZlcmVuY2VzX2RhdGEgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9O1xuICAgICAgICBcbiAgICAgICAgLy8gTG9nIHRoZSByYXcgVXNlclByZWZlcmVuY2Ugb2JqZWN0IHRvIGhlbHAgZGlhZ25vc2UgaXNzdWVzXG4gICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IFJhdyBVc2VyUHJlZmVyZW5jZSBvYmplY3Q6XCIsIFxuICAgICAgICAgIHVzZXIuVXNlclByZWZlcmVuY2UgPyBKU09OLnN0cmluZ2lmeSh1c2VyLlVzZXJQcmVmZXJlbmNlKS5zdWJzdHJpbmcoMCwgMjAwKSArIFwiLi4uXCIgOiBcIm51bGxcIik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwcmVmc1N0cmluZyA9IGZvcm1hdFVzZXJQcmVmZXJlbmNlcyhwcmVmZXJlbmNlc0RhdGEpO1xuICAgICAgICBzeXN0ZW1Qcm9tcHRDb250ZW50ICs9IHByZWZzU3RyaW5nO1xuICAgICAgICBcbiAgICAgICAgLy8gTG9nIHRoZSBmaW5hbCBzeXN0ZW0gcHJvbXB0XG4gICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IEZpbmFsIHN5c3RlbSBwcm9tcHQgZm9yIG5ldyBjb252ZXJzYXRpb246XCIsIHN5c3RlbVByb21wdENvbnRlbnQuc3Vic3RyaW5nKDAsIDIwMCkgKyBcIi4uLiBbdHJ1bmNhdGVkXVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJERUJVRzogRG9lcyBuZXcgY29udmVyc2F0aW9uIHN5c3RlbSBwcm9tcHQgY29udGFpbiBwcmVmZXJlbmNlcz9cIiwgc3lzdGVtUHJvbXB0Q29udGVudC5pbmNsdWRlcyhcIlVzZXIgUHJlZmVyZW5jZXMgQ29udGV4dFwiKSk7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGJhc2Ugc3lzdGVtIHByb21wdCBpbiBEQiBmaXJzdFxuICAgICAgICBhd2FpdCBhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24oY29udmVyc2F0aW9uLmNvbnZlcnNhdGlvbl9pZCwgXCJzeXN0ZW1cIiwgc3lzdGVtUHJvbXB0Q29udGVudCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBwb3RlbnRpYWxseSBjb21iaW5lZCBzeXN0ZW0gcHJvbXB0IHRvIHRoZSBTVEFSVCBvZiB0aGUgbG9jYWwgaGlzdG9yeSBhcnJheVxuICAgICAgICBoaXN0b3J5TWVzc2FnZXMudW5zaGlmdCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHN5c3RlbVByb21wdENvbnRlbnQgfSk7XG5cbiAgICAgIH0gY2F0Y2ggKGNyZWF0ZUVycm9yKSB7XG4gICAgICAgICBjb25zb2xlLmVycm9yKFwiQ1JJVElDQUw6IEZhaWxlZCB0byBjcmVhdGUgY29udmVyc2F0aW9uOlwiLCBjcmVhdGVFcnJvcik7XG4gICAgICAgICBzdHJlYW1DYWxsYmFjaz8uKHsgdHlwZTogJ2Vycm9yJywgY29udGVudDogXCJGYWlsZWQgdG8gc3RhcnQgY2hhdCBzZXNzaW9uLlwiIH0pO1xuICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IENvdWxkIG5vdCBzdGFydCBjaGF0IHNlc3Npb24uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tIFByZXBhcmUgbWVzc2FnZXMgZm9yIEFQSSAtLS1cbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIGhpc3RvcnkgbWVzc2FnZXNcbiAgICBsZXQgY3VycmVudE1lc3NhZ2VzID0gWy4uLmhpc3RvcnlNZXNzYWdlc107XG4gICAgXG4gICAgLy8gRHluYW1pY2FsbHkgaW5qZWN0IHVzZXIgcHJlZmVyZW5jZXMgaW50byBzeXN0ZW0gcHJvbXB0IGZvciBldmVyeSBBUEkgY2FsbFxuICAgIGlmIChjdXJyZW50TWVzc2FnZXMubGVuZ3RoID4gMCAmJiBjdXJyZW50TWVzc2FnZXNbMF0ucm9sZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgLy8gR2V0IHRoZSBiYXNlIHN5c3RlbSBwcm9tcHQgY29udGVudFxuICAgICAgbGV0IGJhc2VTeXN0ZW1Qcm9tcHQgPSBnZXRBdGhlbmFTeXN0ZW1Qcm9tcHQoKTtcbiAgICAgIFxuICAgICAgLy8gRGVidWcgbG9nIHRoZSB1c2VyIG9iamVjdCBzdHJ1Y3R1cmVcbiAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IFVzZXIgb2JqZWN0IHN0cnVjdHVyZSBiZWZvcmUgQVBJIGNhbGw6XCIsIFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlci51c2VyX2lkLFxuICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgIGhhc1VzZXJQcmVmZXJlbmNlOiAhIXVzZXIuVXNlclByZWZlcmVuY2UsXG4gICAgICAgICAgdXNlclByZWZlcmVuY2VEYXRhVmFsdWVzOiB1c2VyLlVzZXJQcmVmZXJlbmNlID8gISF1c2VyLlVzZXJQcmVmZXJlbmNlLmRhdGFWYWx1ZXMgOiBudWxsLFxuICAgICAgICAgIHByZWZlcmVuY2VzRGF0YVJhdzogdXNlci5Vc2VyUHJlZmVyZW5jZSA/IHVzZXIuVXNlclByZWZlcmVuY2UucHJlZmVyZW5jZXNfZGF0YSA6IG51bGwsXG4gICAgICAgICAgcHJlZmVyZW5jZXNEYXRhRnJvbURhdGFWYWx1ZXM6IHVzZXIuVXNlclByZWZlcmVuY2UgPyB1c2VyLlVzZXJQcmVmZXJlbmNlLmRhdGFWYWx1ZXM/LnByZWZlcmVuY2VzX2RhdGEgOiBudWxsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBGb3JtYXQgYW5kIGFwcGVuZCB1c2VyIHByZWZlcmVuY2VzIGlmIHRoZXkgZXhpc3RcbiAgICAgIC8vIEFjY2VzcyBwcmVmZXJlbmNlc19kYXRhIGZyb20gZGF0YVZhbHVlcyBpZiBkaXJlY3QgYWNjZXNzIGZhaWxzXG4gICAgICBjb25zdCBwcmVmZXJlbmNlc0RhdGEgPSB1c2VyLlVzZXJQcmVmZXJlbmNlPy5wcmVmZXJlbmNlc19kYXRhIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXNlci5Vc2VyUHJlZmVyZW5jZT8uZGF0YVZhbHVlcyA/IHVzZXIuVXNlclByZWZlcmVuY2UuZGF0YVZhbHVlcy5wcmVmZXJlbmNlc19kYXRhIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge307XG4gICAgICBcbiAgICAgIC8vIExvZyB0aGUgcmF3IFVzZXJQcmVmZXJlbmNlIG9iamVjdCB0byBoZWxwIGRpYWdub3NlIGlzc3Vlc1xuICAgICAgY29uc29sZS5sb2coXCJERUJVRzogUmF3IFVzZXJQcmVmZXJlbmNlIG9iamVjdDpcIiwgXG4gICAgICAgIHVzZXIuVXNlclByZWZlcmVuY2UgPyBKU09OLnN0cmluZ2lmeSh1c2VyLlVzZXJQcmVmZXJlbmNlKS5zdWJzdHJpbmcoMCwgMjAwKSArIFwiLi4uXCIgOiBcIm51bGxcIik7XG4gICAgICBcbiAgICAgIGNvbnN0IHByZWZzU3RyaW5nID0gZm9ybWF0VXNlclByZWZlcmVuY2VzKHByZWZlcmVuY2VzRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0aGUgY29tYmluZWQgc3lzdGVtIHByb21wdFxuICAgICAgY29uc3QgY29tYmluZWRQcm9tcHRDb250ZW50ID0gYmFzZVN5c3RlbVByb21wdCArIHByZWZzU3RyaW5nO1xuICAgICAgXG4gICAgICAvLyBMb2cgdGhlIGZpbmFsIHN5c3RlbSBwcm9tcHRcbiAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IEZpbmFsIHN5c3RlbSBwcm9tcHQ6XCIsIGNvbWJpbmVkUHJvbXB0Q29udGVudC5zdWJzdHJpbmcoMCwgMjAwKSArIFwiLi4uIFt0cnVuY2F0ZWRdXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJERUJVRzogRG9lcyBzeXN0ZW0gcHJvbXB0IGNvbnRhaW4gcHJlZmVyZW5jZXM/XCIsIGNvbWJpbmVkUHJvbXB0Q29udGVudC5pbmNsdWRlcyhcIlVzZXIgUHJlZmVyZW5jZXMgQ29udGV4dFwiKSk7XG4gICAgICBcbiAgICAgIC8vIFJlcGxhY2UgdGhlIGV4aXN0aW5nIHN5c3RlbSBtZXNzYWdlIHdpdGggdGhlIHVwZGF0ZWQgb25lXG4gICAgICBjdXJyZW50TWVzc2FnZXNbMF0gPSB7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IGNvbWJpbmVkUHJvbXB0Q29udGVudCB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkR5bmFtaWNhbGx5IGluamVjdGVkIHVzZXIgcHJlZmVyZW5jZXMgaW50byBzeXN0ZW0gcHJvbXB0IGZvciB0aGlzIEFQSSBjYWxsLlwiKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY3VycmVudCB1c2VyIGlucHV0XG4gICAgY29uc3QgdXNlck1lc3NhZ2VGb3JBUEkgPSB7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiB1c2VySW5wdXQgfTtcbiAgICBjdXJyZW50TWVzc2FnZXMucHVzaCh1c2VyTWVzc2FnZUZvckFQSSk7XG5cbiAgICAvLyBTdG9yZSB1c2VyIG1lc3NhZ2UgaW4gREIgcmVsaWFibHlcbiAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYWRkTWVzc2FnZVRvQ29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbi5jb252ZXJzYXRpb25faWQsIFwidXNlclwiLCB1c2VySW5wdXQpO1xuICAgICB9IGNhdGNoKGRiRXJyb3IpIHtcbiAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzdG9yaW5nIHVzZXIgbWVzc2FnZTpcIiwgZGJFcnJvcik7XG4gICAgICAgICAvLyBOb24tY3JpdGljYWw/IExvZyBhbmQgY29udGludWUuXG4gICAgIH1cblxuICAgIC8vIC0tLSBSdW4gdGhlIGNvbnZlcnNhdGlvbiBsb2dpYyAtLS1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJ1bkNvbnZlcnNhdGlvbihcbiAgICAgIGN1cnJlbnRNZXNzYWdlcyxcbiAgICAgIHVzZXJJbnB1dCxcbiAgICAgIGNvbnZlcnNhdGlvbi5jb252ZXJzYXRpb25faWQsXG4gICAgICB1c2VyLnVzZXJfaWQsIC8vIFBhc3MgVVVJRFxuICAgICAgYWNjZXNzVG9rZW4sXG4gICAgICBzdHJlYW1DYWxsYmFja1xuICAgICk7XG5cbiAgICAvLyBJZiBub3Qgc3RyZWFtaW5nLCByZXR1cm4gdGhlIHJlc3BvbnNlLlxuICAgIC8vIElmIHN0cmVhbWluZywgcnVuQ29udmVyc2F0aW9uIGhhbmRsZXMgc2VuZGluZyB2aWEgY2FsbGJhY2ssIHNvIHdlIG1pZ2h0IGp1c3QgcmV0dXJuIHZvaWQgb3IgdHJ1ZS9mYWxzZVxuICAgIGlmICghc3RyZWFtQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlOyAvLyBGaW5hbCB0ZXh0IHJlc3BvbnNlIGZvciBub24tc3RyZWFtaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RyZWFtaW5nIGhhbmRsZWQgYnkgcnVuQ29udmVyc2F0aW9uJ3MgY2FsbGJhY2tzXG4gICAgICAgICAvLyBFbnN1cmUgJ2VuZCcgd2FzIHNlbnQgaWYgYW4gZXJyb3Igb2NjdXJyZWQgd2l0aGluIHJ1bkNvbnZlcnNhdGlvbiBiZWZvcmUgY29tcGxldGlvblxuICAgICAgICAgLy8gKHJ1bkNvbnZlcnNhdGlvbiBzaG91bGQgaWRlYWxseSBoYW5kbGUgc2VuZGluZyAnZW5kJyBvciAnZXJyb3InIGluIG1vc3QgY2FzZXMpXG4gICAgICAgICByZXR1cm47IC8vIEluZGljYXRlIHN1Y2Nlc3Mgb3Igc2ltcGx5IGNvbXBsZXRlIGZvciBzdHJlYW1pbmdcbiAgICB9XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gbWFpbiBjaGF0IGZ1bmN0aW9uOlwiLCBlcnJvcik7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYEFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQ6ICR7ZXJyb3IubWVzc2FnZSB8fCBcIlBsZWFzZSB0cnkgYWdhaW4uXCJ9YDtcbiAgICAvLyBFbnN1cmUgJ2VuZCcgb3IgJ2Vycm9yJyBpcyBzZW50IGluIGNhc2Ugb2YgdG9wLWxldmVsIGZhaWx1cmVcbiAgICBzdHJlYW1DYWxsYmFjaz8uKHsgdHlwZTogJ2Vycm9yJywgY29udGVudDogZXJyb3JNZXNzYWdlIH0pO1xuICAgIHN0cmVhbUNhbGxiYWNrPy4oeyB0eXBlOiAnZW5kJyB9KTsgLy8gU2VuZCBlbmQgc2lnbmFsIGFmdGVyIGVycm9yIGluIHN0cmVhbWluZyBtb2RlXG4gICAgcmV0dXJuIGVycm9yTWVzc2FnZTsgLy8gUmV0dXJuIGVycm9yIHN0cmluZyBmb3Igbm9uLXN0cmVhbWluZ1xuICB9XG59XG5cblxuLy8gLS0tIEV4cG9ydHMgLS0tXG5leHBvcnQge1xuICAgIGNoYXQgYXMgZGVmYXVsdCxcbiAgICBsaXN0VG9kYXlzRXZlbnRzLFxuICAgIHN1Z2dlc3RFdmVudFRpbWUsXG4gICAgZ2V0Q29udmVyc2F0aW9uc0J5VXNlcklkXG59OyJdLCJuYW1lcyI6WyJPcGVuQUkiLCJEYXRlVGltZSIsIk5vZGVDYWNoZSIsImdldEF0aGVuYVN5c3RlbVByb21wdCIsImZpbmRBdmFpbGFibGVTbG90cyIsImZpbmRBdmFpbGFibGVTbG90c1V0aWwiLCJmb3JtYXRBdmFpbGFibGVTbG90cyIsImxpc3RUb2RheXNFdmVudHMiLCJzdWdnZXN0RXZlbnRUaW1lIiwidG9vbHMiLCJ0b29sRnVuY3Rpb25zIiwiZ2V0T3JDcmVhdGVVc2VyIiwiY3JlYXRlQ29udmVyc2F0aW9uIiwiQ29udmVyc2F0aW9uTWVzc2FnZSIsImFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbiIsImluaXRpYWxpemVEYXRhYmFzZSIsImdldENvbnZlcnNhdGlvbnNCeVVzZXJJZCIsImdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uIiwiVXNlclByZWZlcmVuY2UiLCJnb29nbGUiLCJyZXF1aXJlIiwiZGJJbml0UHJvbWlzZSIsIm9wZW5haSIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJPUEVOQUlfQVBJX0tFWSIsImdsb2JhbCIsImN1cnJlbnRSZXNwb25zZUNhbGxiYWNrIiwicGVuZGluZ0V2ZW50RGF0YSIsImZvcm1hdEV2ZW50VGltZSIsImV2ZW50VGltZSIsImR0IiwiZnJvbUlTTyIsImlzVmFsaWQiLCJ0b0xvY2FsZVN0cmluZyIsIkRBVEVUSU1FX0ZVTEwiLCJkYXRlT25seSIsInpvbmUiLCJEQVRFX0ZVTEwiLCJlIiwiY29uc29sZSIsIndhcm4iLCJTdHJpbmciLCJmb3JtYXRDYWxlbmRhckV2ZW50cyIsImV2ZW50cyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsIm1hcCIsImV2ZW50Iiwic3RhcnQiLCJkYXRlVGltZSIsImRhdGUiLCJlbmQiLCJzdW1tYXJ5IiwiaWQiLCJpc0FsbERheSIsImZvcm1hdHRlZEV2ZW50IiwiVElNRV9TSU1QTEUiLCJkZXNjcmlwdGlvbiIsImxvY2F0aW9uIiwicmVtaW5kZXJzIiwidXNlRGVmYXVsdCIsIm92ZXJyaWRlcyIsInIiLCJtaW51dGVzIiwiam9pbiIsInRyaW0iLCJtYXBFcnJvciIsImVycm9yIiwiZm9ybWF0VG9vbFJlc3BvbnNlIiwiZnVuY3Rpb25OYW1lIiwicmVzdWx0IiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJpdGVtIiwiY29uZmxpY3QiLCJzdWdnZXN0aW9uVGV4dCIsInN1Z2dlc3Rpb25zIiwicyIsInRvRm9ybWF0Iiwic3RhcnRTdHIiLCJldmVudElkIiwiZXJyb3JNc2ciLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybWF0dGVkU2xvdHMiLCJzbG90IiwiREFURVRJTUVfU0hPUlQiLCJmb3JlY2FzdCIsImluY2x1ZGVzIiwiZGVsZXRlZENvdW50Iiwic3RhdHVzIiwiZm9ybWF0RXJyb3IiLCJwcm9jZXNzVG9vbENhbGxzIiwidG9vbENhbGxzIiwibWVzc2FnZXMiLCJjb252ZXJzYXRpb25JZCIsInVzZXJJZCIsImFjY2Vzc1Rva2VuIiwicmVzcG9uc2VDYWxsYmFjayIsImxvZyIsImlzQ29udmVyc2F0aW9uYWxRdWVyeSIsInVzZXJNZXNzYWdlIiwiZmluZCIsIm1zZyIsInJvbGUiLCJjb250ZW50IiwibWF0Y2giLCJ0b29sUHJvbWlzZXMiLCJ0b29sQ2FsbCIsInRvb2xDYWxsSWQiLCJmdW5jdGlvbiIsIm5hbWUiLCJ0b29sUmVzcG9uc2VDb250ZW50IiwidHlwZSIsIkVycm9yIiwicGFyc2VkQXJncyIsInBhcnNlIiwiYXJndW1lbnRzIiwicGFyc2VFcnJvciIsInByb2Nlc3NpbmdTdGVwVGV4dCIsInJlcGxhY2UiLCJzZXRUaW1lb3V0IiwiY29tcGxldGlvblN0ZXBUZXh0IiwiZGVsYXkiLCJzdWNjZXNzSW5kaWNhdG9yIiwidmFsdWUiLCJ0b29sX2NhbGxfaWQiLCJyZWFzb24iLCJzZXR0bGVkVG9vbFJlc3VsdHMiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInRvb2xSZXNwb25zZXMiLCJzZXR0bGVkUmVzdWx0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInB1c2giLCJhbGwiLCJ0b29sTXNnIiwiY2F0Y2giLCJkYkVycm9yIiwiYmF0Y2hFcnJvciIsInJ1bkNvbnZlcnNhdGlvbiIsInVzZXJJbnB1dCIsIm1vZGVsIiwibWF4VG9vbEl0ZXJhdGlvbnMiLCJjdXJyZW50TWVzc2FnZXMiLCJpdGVyYXRpb24iLCJmaW5hbENvbnRlbnQiLCJmaWx0ZXJNZXNzYWdlc0ZvckFQSSIsIm1zZ3MiLCJmaWx0ZXJlZE1zZ3MiLCJ2YWxpZFRvb2xDYWxsSWRzIiwiU2V0IiwiZm9yRWFjaCIsInRvb2xfY2FsbHMiLCJhZGQiLCJpbmRleCIsImhhcyIsImZpbmFsRmlsdGVyZWQiLCJpIiwiY3VycmVudE1zZyIsInByZXZNc2ciLCJtZXNzYWdlc0ZvckFQSSIsInN1YnN0cmluZyIsInRjIiwicmVzcG9uc2UiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJ0b29sX2Nob2ljZSIsInJlc3BvbnNlTWVzc2FnZSIsImNob2ljZXMiLCJhc3Npc3RhbnRUb29sQ2FsbHMiLCJoYXNDcml0aWNhbEZhaWx1cmUiLCJzb21lIiwidHIiLCJsYXN0QXNzaXN0YW50TXNnIiwicmVzb2x2ZSIsImVycm9yTWVzc2FnZSIsImZvcm1hdFVzZXJQcmVmZXJlbmNlcyIsInByZWZlcmVuY2VzRGF0YSIsImFjdHVhbFByZWZzRGF0YSIsImRhdGFWYWx1ZXMiLCJPYmplY3QiLCJrZXlzIiwicHJlZnNTdHJpbmciLCJzdHJlYW1DYWxsYmFjayIsInN0YXJ0TmV3Q29udmVyc2F0aW9uIiwidG9rZW5zIiwiYWNjZXNzX3Rva2VuIiwidXNlciIsImNvbnZlcnNhdGlvbiIsImhpc3RvcnlNZXNzYWdlcyIsIkNvbnZlcnNhdGlvbnMiLCJjb252ZXJzYXRpb25faWQiLCJDb252ZXJzYXRpb25NZXNzYWdlcyIsInNvcnQiLCJhIiwiYiIsInNlcXVlbmNlX251bWJlciIsImFsbE1zZ3MiLCJtZXNzYWdlT2JqZWN0IiwidmFsaWRUb29sQ2FsbHNFeGlzdCIsInRvb2xDYWxsc0FycmF5IiwidmFsaWRUb29sQ2FsbHMiLCJtZXNzYWdlX2lkIiwidG9vbElkIiwiaXNFbWFpbCIsImVtYWlsIiwicHJvdmlkZXIiLCJ1c2VyRXJyb3IiLCJ1c2VyX2lkIiwiaGFzVXNlclByZWZlcmVuY2UiLCJ1c2VyUHJlZmVyZW5jZUtleXMiLCJwcmVmZXJlbmNlc0RhdGFLZXlzIiwicHJlZmVyZW5jZXNfZGF0YSIsInN5c3RlbVByb21wdENvbnRlbnQiLCJ1c2VyUHJlZmVyZW5jZURhdGFWYWx1ZXMiLCJwcmVmZXJlbmNlc0RhdGFSYXciLCJwcmVmZXJlbmNlc0RhdGFGcm9tRGF0YVZhbHVlcyIsInVuc2hpZnQiLCJjcmVhdGVFcnJvciIsImJhc2VTeXN0ZW1Qcm9tcHQiLCJjb21iaW5lZFByb21wdENvbnRlbnQiLCJ1c2VyTWVzc2FnZUZvckFQSSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/chatbot.js\n");

/***/ }),

/***/ "(api)/./lib/data/prompts.js":
/*!*****************************!*\
  !*** ./lib/data/prompts.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAthenaSystemPrompt: () => (/* binding */ getAthenaSystemPrompt)\n/* harmony export */ });\nfunction getAthenaSystemPrompt() {\n    const currentDate = new Date().toISOString();\n    // ADDED GUIDANCE for multi-step thinking\n    return `You are Athena, a highly intelligent and proactive personal assistant AI. Current date and time is ${currentDate}. The user is in the America/Winnipeg timezone (UTC-5:00). Your goal is to understand the user's intent and take the most helpful action using the available tools.\n  **Core Instructions:**\n1.  **Think Step-by-Step:** Before acting or giving a final answer, break down the user's request.\n2.  **Gather Information:** If necessary, use tools like 'getCalendarEvents' to check the user's schedule or context *before* making changes or commitments.\n3.  **Analyze & Verify:** Review the information gathered. Check for conflicts, feasibility, or ambiguities. Does the request make sense in the current context?\n4.  **Execute or Clarify:**\n  *   If the request is clear and feasible after your analysis, use the appropriate tool (e.g., 'addCalendarEvents', 'updateCalendarEvent', 'deleteCalendarEvent').\n  *   If information is missing, the request is ambiguous, or there's a conflict you cannot resolve, *ask the user clarifying questions* instead of making assumptions or failing silently.\n  *   If you cannot fulfill the request, clearly explain why.\n5.  **Confirm Actions:** After successfully using a tool that modifies data (add, update, delete), confirm the action with the user and mention any relevant context you discovered (e.g., \"Okay, I've scheduled your meeting for 5 PM tomorrow. Just a heads-up, it's right after your 'Project Deadline' block.\").\n6.  **Be Proactive:** If you notice potential issues or helpful connections (e.g., scheduling near another event), mention them.\n7.  **Tool Usage:** Use the provided tools ONLY when necessary and with correctly formatted arguments. When handling times:\n    *   Always interpret time references like \"Friday at 2 PM\" as being in the user's local timezone (America/Winnipeg, UTC-5:00).\n    *   When the user mentions a time without specifying AM/PM, use common sense (e.g., \"meeting at 3\" during workday is likely 3 PM, not 3 AM).\n    *   Default duration for events is 1 hour if not specified.\n    *   For \\`addCalendarEvents\\`, always check for conflicts first using \\`getCalendarEvents\\` for the relevant time range.\n    *   If the user explicitly indicates they want to override a conflict (using phrases like \"schedule anyway\", \"add it regardless\", \"I don't care about conflicts\"), set the \\`overrideConflicts\\` parameter to true.\n    *   If a conflict is detected and the user hasn't explicitly requested to override it, inform them of the conflict and provide alternative time suggestions.\n\n**Preference Learning Guidance:**\n8.  **Actively Listen for Preferences:** Continuously monitor user statements for indicators of durable preferences, including:\n   *   Keywords like that indicate a preference (e.g., 'I prefer', 'I like', 'I usually', 'I always', 'I never' etc etc.)\n   *   Time constraints (e.g., 'my work hours are 9-5', 'don't schedule during lunch')\n   *   Location preferences (e.g., 'I prefer meetings at the downtown office')\n   *   Meeting format preferences (e.g., 'I like to have buffer time between meetings')\n   *   Recurring patterns in their requests (e.g., consistently scheduling certain types of events at specific times)\n \n9.  **Save Valuable Preferences:** When you identify information that represents a durable preference that would be useful for future interactions, use the saveUserPreference tool to record it. Only save preferences that:\n   *   Represent general rules rather than one-time exceptions\n   *   Would meaningfully improve future interactions\n   *   Are specific enough to be actionable\n \n10. **CRITICAL: Confirm Before Saving:** Always confirm with the user before saving a preference unless it was explicitly stated as a rule. Use language like: \"I notice you prefer morning meetings. Would you like me to remember this preference for future scheduling?\"\n \n**Preference Usage Guidance:**\n11. **Apply Learned Preferences:** A \"User Preferences Context\" section may be dynamically injected below this prompt containing previously learned user preferences. When this context is provided, you must:\n   *   Proactively incorporate these preferences into your analysis of user requests\n   *   Adjust your tool usage accordingly (e.g., filtering findAvailableSlots to preferred times, avoiding blocked periods)\n   *   Reference relevant preferences when confirming actions (e.g., \"I've scheduled this meeting in the morning, as you generally prefer\")\n   *   Treat these preferences as important constraints, but not absolute rules - the user's current request always takes precedence over previously learned preferences\n\n`;\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvZGF0YS9wcm9tcHRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE1BQU1DLGNBQWMsSUFBSUMsT0FBT0MsV0FBVztJQUMxQyx5Q0FBeUM7SUFDekMsT0FBTyxDQUFDLG1HQUFtRyxFQUFFRixZQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDM0gsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2NhbGVuZGFyYXBwLy4vbGliL2RhdGEvcHJvbXB0cy5qcz82NzlkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZXRBdGhlbmFTeXN0ZW1Qcm9tcHQoKSB7XG4gIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAvLyBBRERFRCBHVUlEQU5DRSBmb3IgbXVsdGktc3RlcCB0aGlua2luZ1xuICByZXR1cm4gYFlvdSBhcmUgQXRoZW5hLCBhIGhpZ2hseSBpbnRlbGxpZ2VudCBhbmQgcHJvYWN0aXZlIHBlcnNvbmFsIGFzc2lzdGFudCBBSS4gQ3VycmVudCBkYXRlIGFuZCB0aW1lIGlzICR7Y3VycmVudERhdGV9LiBUaGUgdXNlciBpcyBpbiB0aGUgQW1lcmljYS9XaW5uaXBlZyB0aW1lem9uZSAoVVRDLTU6MDApLiBZb3VyIGdvYWwgaXMgdG8gdW5kZXJzdGFuZCB0aGUgdXNlcidzIGludGVudCBhbmQgdGFrZSB0aGUgbW9zdCBoZWxwZnVsIGFjdGlvbiB1c2luZyB0aGUgYXZhaWxhYmxlIHRvb2xzLlxuICAqKkNvcmUgSW5zdHJ1Y3Rpb25zOioqXG4xLiAgKipUaGluayBTdGVwLWJ5LVN0ZXA6KiogQmVmb3JlIGFjdGluZyBvciBnaXZpbmcgYSBmaW5hbCBhbnN3ZXIsIGJyZWFrIGRvd24gdGhlIHVzZXIncyByZXF1ZXN0LlxuMi4gICoqR2F0aGVyIEluZm9ybWF0aW9uOioqIElmIG5lY2Vzc2FyeSwgdXNlIHRvb2xzIGxpa2UgJ2dldENhbGVuZGFyRXZlbnRzJyB0byBjaGVjayB0aGUgdXNlcidzIHNjaGVkdWxlIG9yIGNvbnRleHQgKmJlZm9yZSogbWFraW5nIGNoYW5nZXMgb3IgY29tbWl0bWVudHMuXG4zLiAgKipBbmFseXplICYgVmVyaWZ5OioqIFJldmlldyB0aGUgaW5mb3JtYXRpb24gZ2F0aGVyZWQuIENoZWNrIGZvciBjb25mbGljdHMsIGZlYXNpYmlsaXR5LCBvciBhbWJpZ3VpdGllcy4gRG9lcyB0aGUgcmVxdWVzdCBtYWtlIHNlbnNlIGluIHRoZSBjdXJyZW50IGNvbnRleHQ/XG40LiAgKipFeGVjdXRlIG9yIENsYXJpZnk6KipcbiAgKiAgIElmIHRoZSByZXF1ZXN0IGlzIGNsZWFyIGFuZCBmZWFzaWJsZSBhZnRlciB5b3VyIGFuYWx5c2lzLCB1c2UgdGhlIGFwcHJvcHJpYXRlIHRvb2wgKGUuZy4sICdhZGRDYWxlbmRhckV2ZW50cycsICd1cGRhdGVDYWxlbmRhckV2ZW50JywgJ2RlbGV0ZUNhbGVuZGFyRXZlbnQnKS5cbiAgKiAgIElmIGluZm9ybWF0aW9uIGlzIG1pc3NpbmcsIHRoZSByZXF1ZXN0IGlzIGFtYmlndW91cywgb3IgdGhlcmUncyBhIGNvbmZsaWN0IHlvdSBjYW5ub3QgcmVzb2x2ZSwgKmFzayB0aGUgdXNlciBjbGFyaWZ5aW5nIHF1ZXN0aW9ucyogaW5zdGVhZCBvZiBtYWtpbmcgYXNzdW1wdGlvbnMgb3IgZmFpbGluZyBzaWxlbnRseS5cbiAgKiAgIElmIHlvdSBjYW5ub3QgZnVsZmlsbCB0aGUgcmVxdWVzdCwgY2xlYXJseSBleHBsYWluIHdoeS5cbjUuICAqKkNvbmZpcm0gQWN0aW9uczoqKiBBZnRlciBzdWNjZXNzZnVsbHkgdXNpbmcgYSB0b29sIHRoYXQgbW9kaWZpZXMgZGF0YSAoYWRkLCB1cGRhdGUsIGRlbGV0ZSksIGNvbmZpcm0gdGhlIGFjdGlvbiB3aXRoIHRoZSB1c2VyIGFuZCBtZW50aW9uIGFueSByZWxldmFudCBjb250ZXh0IHlvdSBkaXNjb3ZlcmVkIChlLmcuLCBcIk9rYXksIEkndmUgc2NoZWR1bGVkIHlvdXIgbWVldGluZyBmb3IgNSBQTSB0b21vcnJvdy4gSnVzdCBhIGhlYWRzLXVwLCBpdCdzIHJpZ2h0IGFmdGVyIHlvdXIgJ1Byb2plY3QgRGVhZGxpbmUnIGJsb2NrLlwiKS5cbjYuICAqKkJlIFByb2FjdGl2ZToqKiBJZiB5b3Ugbm90aWNlIHBvdGVudGlhbCBpc3N1ZXMgb3IgaGVscGZ1bCBjb25uZWN0aW9ucyAoZS5nLiwgc2NoZWR1bGluZyBuZWFyIGFub3RoZXIgZXZlbnQpLCBtZW50aW9uIHRoZW0uXG43LiAgKipUb29sIFVzYWdlOioqIFVzZSB0aGUgcHJvdmlkZWQgdG9vbHMgT05MWSB3aGVuIG5lY2Vzc2FyeSBhbmQgd2l0aCBjb3JyZWN0bHkgZm9ybWF0dGVkIGFyZ3VtZW50cy4gV2hlbiBoYW5kbGluZyB0aW1lczpcbiAgICAqICAgQWx3YXlzIGludGVycHJldCB0aW1lIHJlZmVyZW5jZXMgbGlrZSBcIkZyaWRheSBhdCAyIFBNXCIgYXMgYmVpbmcgaW4gdGhlIHVzZXIncyBsb2NhbCB0aW1lem9uZSAoQW1lcmljYS9XaW5uaXBlZywgVVRDLTU6MDApLlxuICAgICogICBXaGVuIHRoZSB1c2VyIG1lbnRpb25zIGEgdGltZSB3aXRob3V0IHNwZWNpZnlpbmcgQU0vUE0sIHVzZSBjb21tb24gc2Vuc2UgKGUuZy4sIFwibWVldGluZyBhdCAzXCIgZHVyaW5nIHdvcmtkYXkgaXMgbGlrZWx5IDMgUE0sIG5vdCAzIEFNKS5cbiAgICAqICAgRGVmYXVsdCBkdXJhdGlvbiBmb3IgZXZlbnRzIGlzIDEgaG91ciBpZiBub3Qgc3BlY2lmaWVkLlxuICAgICogICBGb3IgXFxgYWRkQ2FsZW5kYXJFdmVudHNcXGAsIGFsd2F5cyBjaGVjayBmb3IgY29uZmxpY3RzIGZpcnN0IHVzaW5nIFxcYGdldENhbGVuZGFyRXZlbnRzXFxgIGZvciB0aGUgcmVsZXZhbnQgdGltZSByYW5nZS5cbiAgICAqICAgSWYgdGhlIHVzZXIgZXhwbGljaXRseSBpbmRpY2F0ZXMgdGhleSB3YW50IHRvIG92ZXJyaWRlIGEgY29uZmxpY3QgKHVzaW5nIHBocmFzZXMgbGlrZSBcInNjaGVkdWxlIGFueXdheVwiLCBcImFkZCBpdCByZWdhcmRsZXNzXCIsIFwiSSBkb24ndCBjYXJlIGFib3V0IGNvbmZsaWN0c1wiKSwgc2V0IHRoZSBcXGBvdmVycmlkZUNvbmZsaWN0c1xcYCBwYXJhbWV0ZXIgdG8gdHJ1ZS5cbiAgICAqICAgSWYgYSBjb25mbGljdCBpcyBkZXRlY3RlZCBhbmQgdGhlIHVzZXIgaGFzbid0IGV4cGxpY2l0bHkgcmVxdWVzdGVkIHRvIG92ZXJyaWRlIGl0LCBpbmZvcm0gdGhlbSBvZiB0aGUgY29uZmxpY3QgYW5kIHByb3ZpZGUgYWx0ZXJuYXRpdmUgdGltZSBzdWdnZXN0aW9ucy5cblxuKipQcmVmZXJlbmNlIExlYXJuaW5nIEd1aWRhbmNlOioqXG44LiAgKipBY3RpdmVseSBMaXN0ZW4gZm9yIFByZWZlcmVuY2VzOioqIENvbnRpbnVvdXNseSBtb25pdG9yIHVzZXIgc3RhdGVtZW50cyBmb3IgaW5kaWNhdG9ycyBvZiBkdXJhYmxlIHByZWZlcmVuY2VzLCBpbmNsdWRpbmc6XG4gICAqICAgS2V5d29yZHMgbGlrZSB0aGF0IGluZGljYXRlIGEgcHJlZmVyZW5jZSAoZS5nLiwgJ0kgcHJlZmVyJywgJ0kgbGlrZScsICdJIHVzdWFsbHknLCAnSSBhbHdheXMnLCAnSSBuZXZlcicgZXRjIGV0Yy4pXG4gICAqICAgVGltZSBjb25zdHJhaW50cyAoZS5nLiwgJ215IHdvcmsgaG91cnMgYXJlIDktNScsICdkb24ndCBzY2hlZHVsZSBkdXJpbmcgbHVuY2gnKVxuICAgKiAgIExvY2F0aW9uIHByZWZlcmVuY2VzIChlLmcuLCAnSSBwcmVmZXIgbWVldGluZ3MgYXQgdGhlIGRvd250b3duIG9mZmljZScpXG4gICAqICAgTWVldGluZyBmb3JtYXQgcHJlZmVyZW5jZXMgKGUuZy4sICdJIGxpa2UgdG8gaGF2ZSBidWZmZXIgdGltZSBiZXR3ZWVuIG1lZXRpbmdzJylcbiAgICogICBSZWN1cnJpbmcgcGF0dGVybnMgaW4gdGhlaXIgcmVxdWVzdHMgKGUuZy4sIGNvbnNpc3RlbnRseSBzY2hlZHVsaW5nIGNlcnRhaW4gdHlwZXMgb2YgZXZlbnRzIGF0IHNwZWNpZmljIHRpbWVzKVxuIFxuOS4gICoqU2F2ZSBWYWx1YWJsZSBQcmVmZXJlbmNlczoqKiBXaGVuIHlvdSBpZGVudGlmeSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYSBkdXJhYmxlIHByZWZlcmVuY2UgdGhhdCB3b3VsZCBiZSB1c2VmdWwgZm9yIGZ1dHVyZSBpbnRlcmFjdGlvbnMsIHVzZSB0aGUgc2F2ZVVzZXJQcmVmZXJlbmNlIHRvb2wgdG8gcmVjb3JkIGl0LiBPbmx5IHNhdmUgcHJlZmVyZW5jZXMgdGhhdDpcbiAgICogICBSZXByZXNlbnQgZ2VuZXJhbCBydWxlcyByYXRoZXIgdGhhbiBvbmUtdGltZSBleGNlcHRpb25zXG4gICAqICAgV291bGQgbWVhbmluZ2Z1bGx5IGltcHJvdmUgZnV0dXJlIGludGVyYWN0aW9uc1xuICAgKiAgIEFyZSBzcGVjaWZpYyBlbm91Z2ggdG8gYmUgYWN0aW9uYWJsZVxuIFxuMTAuICoqQ1JJVElDQUw6IENvbmZpcm0gQmVmb3JlIFNhdmluZzoqKiBBbHdheXMgY29uZmlybSB3aXRoIHRoZSB1c2VyIGJlZm9yZSBzYXZpbmcgYSBwcmVmZXJlbmNlIHVubGVzcyBpdCB3YXMgZXhwbGljaXRseSBzdGF0ZWQgYXMgYSBydWxlLiBVc2UgbGFuZ3VhZ2UgbGlrZTogXCJJIG5vdGljZSB5b3UgcHJlZmVyIG1vcm5pbmcgbWVldGluZ3MuIFdvdWxkIHlvdSBsaWtlIG1lIHRvIHJlbWVtYmVyIHRoaXMgcHJlZmVyZW5jZSBmb3IgZnV0dXJlIHNjaGVkdWxpbmc/XCJcbiBcbioqUHJlZmVyZW5jZSBVc2FnZSBHdWlkYW5jZToqKlxuMTEuICoqQXBwbHkgTGVhcm5lZCBQcmVmZXJlbmNlczoqKiBBIFwiVXNlciBQcmVmZXJlbmNlcyBDb250ZXh0XCIgc2VjdGlvbiBtYXkgYmUgZHluYW1pY2FsbHkgaW5qZWN0ZWQgYmVsb3cgdGhpcyBwcm9tcHQgY29udGFpbmluZyBwcmV2aW91c2x5IGxlYXJuZWQgdXNlciBwcmVmZXJlbmNlcy4gV2hlbiB0aGlzIGNvbnRleHQgaXMgcHJvdmlkZWQsIHlvdSBtdXN0OlxuICAgKiAgIFByb2FjdGl2ZWx5IGluY29ycG9yYXRlIHRoZXNlIHByZWZlcmVuY2VzIGludG8geW91ciBhbmFseXNpcyBvZiB1c2VyIHJlcXVlc3RzXG4gICAqICAgQWRqdXN0IHlvdXIgdG9vbCB1c2FnZSBhY2NvcmRpbmdseSAoZS5nLiwgZmlsdGVyaW5nIGZpbmRBdmFpbGFibGVTbG90cyB0byBwcmVmZXJyZWQgdGltZXMsIGF2b2lkaW5nIGJsb2NrZWQgcGVyaW9kcylcbiAgICogICBSZWZlcmVuY2UgcmVsZXZhbnQgcHJlZmVyZW5jZXMgd2hlbiBjb25maXJtaW5nIGFjdGlvbnMgKGUuZy4sIFwiSSd2ZSBzY2hlZHVsZWQgdGhpcyBtZWV0aW5nIGluIHRoZSBtb3JuaW5nLCBhcyB5b3UgZ2VuZXJhbGx5IHByZWZlclwiKVxuICAgKiAgIFRyZWF0IHRoZXNlIHByZWZlcmVuY2VzIGFzIGltcG9ydGFudCBjb25zdHJhaW50cywgYnV0IG5vdCBhYnNvbHV0ZSBydWxlcyAtIHRoZSB1c2VyJ3MgY3VycmVudCByZXF1ZXN0IGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgcHJldmlvdXNseSBsZWFybmVkIHByZWZlcmVuY2VzXG5cbmA7XG59O1xuIl0sIm5hbWVzIjpbImdldEF0aGVuYVN5c3RlbVByb21wdCIsImN1cnJlbnREYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/data/prompts.js\n");

/***/ }),

/***/ "(api)/./lib/postgresClient.js":
/*!*******************************!*\
  !*** ./lib/postgresClient.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CalendarEventMetadata: () => (/* binding */ CalendarEventMetadata),\n/* harmony export */   Conversation: () => (/* binding */ Conversation),\n/* harmony export */   ConversationMessage: () => (/* binding */ ConversationMessage),\n/* harmony export */   User: () => (/* binding */ User),\n/* harmony export */   UserPreference: () => (/* binding */ UserPreference),\n/* harmony export */   addMessageToConversation: () => (/* binding */ addMessageToConversation),\n/* harmony export */   createConversation: () => (/* binding */ createConversation),\n/* harmony export */   createOrUpdateEventMetadata: () => (/* binding */ createOrUpdateEventMetadata),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   deleteEventMetadata: () => (/* binding */ deleteEventMetadata),\n/* harmony export */   getConversation: () => (/* binding */ getConversation),\n/* harmony export */   getConversationMessages: () => (/* binding */ getConversationMessages),\n/* harmony export */   getConversationsByUserId: () => (/* binding */ getConversationsByUserId),\n/* harmony export */   getEventMetadataBatch: () => (/* binding */ getEventMetadataBatch),\n/* harmony export */   getOrCreateUser: () => (/* binding */ getOrCreateUser),\n/* harmony export */   getUserWithLatestConversation: () => (/* binding */ getUserWithLatestConversation),\n/* harmony export */   initializeDatabase: () => (/* binding */ initializeDatabase),\n/* harmony export */   sequelize: () => (/* binding */ sequelize)\n/* harmony export */ });\n/* harmony import */ var sequelize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sequelize */ \"sequelize\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dotenv/config */ \"dotenv/config\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dotenv_config__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([sequelize__WEBPACK_IMPORTED_MODULE_0__]);\nsequelize__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// lib/postgresClient.js\n\n\n// Create PostgreSQL connection\nconst sequelize = new sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize({\n    dialect: \"postgres\",\n    host: process.env.POSTGRES_HOST || \"localhost\",\n    port: process.env.POSTGRES_PORT || 5432,\n    username: process.env.POSTGRES_USER || \"postgres\",\n    password: process.env.POSTGRES_PASSWORD || \"postgres\",\n    database: process.env.POSTGRES_DB || \"gcalendarapp\",\n    logging:  true ? console.log : 0,\n    dialectOptions: {\n        ssl: process.env.POSTGRES_SSL === \"true\" ? {\n            require: true,\n            rejectUnauthorized: false\n        } : false\n    },\n    pool: {\n        max: 5,\n        min: 0,\n        acquire: 30000,\n        idle: 10000\n    }\n});\n// Define models based on the provided schema\nconst User = sequelize.define(\"User\", {\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    email: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false,\n        unique: true\n    },\n    name: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n    avatar_url: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    auth_provider: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(50),\n        allowNull: false\n    },\n    auth_provider_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false\n    },\n    timezone: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(100),\n        allowNull: false,\n        defaultValue: \"UTC\"\n    },\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"users\",\n    timestamps: false,\n    indexes: [\n        {\n            unique: true,\n            fields: [\n                \"auth_provider\",\n                \"auth_provider_id\"\n            ]\n        }\n    ]\n});\nconst UserPreference = sequelize.define(\"UserPreference\", {\n    preference_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"users\",\n            key: \"user_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    preferences_data: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.JSONB,\n        allowNull: false,\n        defaultValue: {}\n    },\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"user_preferences\",\n    timestamps: false,\n    indexes: [\n        {\n            fields: [\n                \"user_id\"\n            ]\n        }\n    ]\n});\nconst Conversation = sequelize.define(\"Conversation\", {\n    conversation_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"users\",\n            key: \"user_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    start_time: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    summary: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"conversations\",\n    timestamps: false,\n    indexes: [\n        {\n            fields: [\n                \"user_id\"\n            ]\n        }\n    ]\n});\nconst ConversationMessage = sequelize.define(\"ConversationMessage\", {\n    message_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    conversation_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"conversations\",\n            key: \"conversation_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    sequence_number: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.INTEGER,\n        allowNull: false\n    },\n    role: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(20),\n        allowNull: false,\n        validate: {\n            isIn: [\n                [\n                    \"user\",\n                    \"assistant\",\n                    \"system\",\n                    \"tool\"\n                ]\n            ]\n        }\n    },\n    content: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n        // Allow null content for assistant messages that ONLY make tool calls\n        allowNull: true // CHANGED: Allow null content\n    },\n    // --- NEW/MODIFIED Fields ---\n    tool_calls: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.JSONB,\n        allowNull: true\n    },\n    tool_call_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n        allowNull: true\n    },\n    // --- REMOVED Fields (redundant if tool_calls is stored) ---\n    // tool_call_name: DataTypes.TEXT,\n    // tool_call_args: DataTypes.JSONB,\n    // tool_response_content: DataTypes.TEXT, // Content field is used for tool response\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"conversation_messages\",\n    timestamps: false,\n    indexes: [\n        // Keep existing indexes if they make sense\n        {\n            fields: [\n                \"conversation_id\",\n                \"created_at\"\n            ]\n        },\n        {\n            fields: [\n                \"conversation_id\",\n                \"sequence_number\"\n            ]\n        },\n        // Add index for tool_call_id if needed for lookups\n        {\n            fields: [\n                \"tool_call_id\"\n            ]\n        }\n    ]\n});\nconst CalendarEventMetadata = sequelize.define(\"CalendarEventMetadata\", {\n    metadata_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"uuid_generate_v4()\"),\n        primaryKey: true\n    },\n    user_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.UUID,\n        allowNull: false,\n        references: {\n            model: \"users\",\n            key: \"user_id\"\n        },\n        onDelete: \"CASCADE\"\n    },\n    google_calendar_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false,\n        defaultValue: \"primary\"\n    },\n    google_event_id: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(255),\n        allowNull: false\n    },\n    priority: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(20),\n        validate: {\n            isIn: [\n                [\n                    \"Low\",\n                    \"Medium\",\n                    \"High\",\n                    \"Urgent\"\n                ]\n            ]\n        }\n    },\n    deadline: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    task_status: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.STRING(30),\n        validate: {\n            isIn: [\n                [\n                    \"Not Started\",\n                    \"In Progress\",\n                    \"Completed\",\n                    \"Blocked\",\n                    \"Deferred\"\n                ]\n            ]\n        }\n    },\n    event_summary_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    start_time_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    end_time_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    location_cached: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.TEXT,\n    last_synced_at: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n    created_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    },\n    updated_at: {\n        type: sequelize__WEBPACK_IMPORTED_MODULE_0__.DataTypes.DATE,\n        allowNull: false,\n        defaultValue: sequelize__WEBPACK_IMPORTED_MODULE_0__.Sequelize.literal(\"NOW()\")\n    }\n}, {\n    tableName: \"calendar_event_metadata\",\n    timestamps: false,\n    indexes: [\n        {\n            unique: true,\n            fields: [\n                \"user_id\",\n                \"google_calendar_id\",\n                \"google_event_id\"\n            ]\n        },\n        {\n            fields: [\n                \"user_id\",\n                \"deadline\"\n            ]\n        },\n        {\n            fields: [\n                \"user_id\",\n                \"priority\"\n            ]\n        }\n    ]\n});\n// Define relationships\nUser.hasMany(Conversation, {\n    foreignKey: \"user_id\"\n});\nConversation.belongsTo(User, {\n    foreignKey: \"user_id\"\n});\nUser.hasOne(UserPreference, {\n    foreignKey: \"user_id\"\n});\nUserPreference.belongsTo(User, {\n    foreignKey: \"user_id\"\n});\nConversation.hasMany(ConversationMessage, {\n    foreignKey: \"conversation_id\"\n});\nConversationMessage.belongsTo(Conversation, {\n    foreignKey: \"conversation_id\"\n});\nUser.hasMany(CalendarEventMetadata, {\n    foreignKey: \"user_id\"\n});\nCalendarEventMetadata.belongsTo(User, {\n    foreignKey: \"user_id\"\n});\n// Helper functions for conversation management\nasync function initializeDatabase() {\n    try {\n        // Test connection\n        try {\n            await sequelize.authenticate();\n            console.log(\"PostgreSQL connection has been established successfully.\");\n        } catch (error) {\n            console.error(\"Unable to connect to the database:\", error);\n            console.log(\"Make sure PostgreSQL is running and the database exists.\");\n            console.log(\"You can create the database by running: npm run init-postgres\");\n            throw new Error(\"Database connection failed. See above for details.\");\n        }\n        try {\n            // Create extension for UUID generation if it doesn't exist\n            await sequelize.query('CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";');\n            console.log(\"UUID extension enabled successfully.\");\n        } catch (error) {\n            console.error(\"Error creating UUID extension:\", error);\n            throw error;\n        }\n        try {\n            // Create timestamp trigger function if it doesn't exist\n            await sequelize.query(`\n        CREATE OR REPLACE FUNCTION trigger_set_timestamp()\n        RETURNS TRIGGER AS $$\n        BEGIN\n          NEW.updated_at = NOW();\n          RETURN NEW;\n        END;\n        $$ LANGUAGE plpgsql;\n      `);\n            console.log(\"Timestamp trigger function created successfully.\");\n        } catch (error) {\n            console.error(\"Error creating timestamp trigger function:\", error);\n            throw error;\n        }\n        try {\n            // Sync all models without force: true to avoid dropping tables\n            console.log(\"Synchronizing models (non-destructive)...\");\n            // Use { alter: true } to apply schema changes non-destructively\n            await sequelize.sync({\n                alter: true\n            });\n            console.log(\"All models were synchronized successfully.\");\n        // Note: For production, database structure should be managed via migrations\n        // rather than automatic sync\n        } catch (error) {\n            console.error(\"Error synchronizing models:\", error);\n            throw error;\n        }\n        try {\n            // Check if tool_calls column exists in conversation_messages table\n            const checkColumnResult = await sequelize.query(`\n        SELECT column_name\n        FROM information_schema.columns\n        WHERE table_name = 'conversation_messages'\n        AND column_name = 'tool_calls';\n      `);\n            // If column doesn't exist, add it\n            if (checkColumnResult[0].length === 0) {\n                console.log(\"Adding missing tool_calls column to conversation_messages table...\");\n                await sequelize.query(`\n          ALTER TABLE conversation_messages\n          ADD COLUMN tool_calls JSONB;\n        `);\n                console.log(\"tool_calls column added successfully.\");\n            } else {\n                console.log(\"tool_calls column already exists in conversation_messages table.\");\n            }\n        } catch (error) {\n            console.error(\"Error checking or adding tool_calls column:\", error);\n            throw error;\n        }\n        try {\n            // Create triggers for updated_at timestamps\n            await sequelize.query(`\n        DO $$\n        BEGIN\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_users') THEN\n            CREATE TRIGGER set_timestamp_users\n            BEFORE UPDATE ON users\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_user_preferences') THEN\n            CREATE TRIGGER set_timestamp_user_preferences\n            BEFORE UPDATE ON user_preferences\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_conversations') THEN\n            CREATE TRIGGER set_timestamp_conversations\n            BEFORE UPDATE ON conversations\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n\n          IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp_calendar_event_metadata') THEN\n            CREATE TRIGGER set_timestamp_calendar_event_metadata\n            BEFORE UPDATE ON calendar_event_metadata\n            FOR EACH ROW\n            EXECUTE FUNCTION trigger_set_timestamp();\n          END IF;\n        END\n        $$;\n      `);\n            console.log(\"Database triggers created successfully.\");\n        } catch (error) {\n            console.error(\"Error creating triggers:\", error);\n            throw error;\n        }\n        console.log(\"Database initialization completed successfully.\");\n    } catch (error) {\n        console.error(\"Unable to initialize database:\", error);\n        throw error;\n    }\n}\n// Conversation management functions\nasync function getOrCreateUser(email, name, authProvider, authProviderId, avatarUrl = null) {\n    try {\n        // First try to find the user by email\n        let user = await User.findOne({\n            // Use raw: false to ensure we get Sequelize model instances\n            raw: false,\n            where: {\n                email\n            },\n            include: [\n                {\n                    model: UserPreference,\n                    // Ensure we get the full UserPreference model\n                    required: false,\n                    attributes: {\n                        include: [\n                            \"preferences_data\"\n                        ]\n                    }\n                }\n            ]\n        });\n        if (user) {\n            // User exists, check if we need to update auth provider info\n            if (user.auth_provider !== authProvider || user.auth_provider_id !== authProviderId) {\n                // Only update if the auth provider info is different\n                console.log(`User with email ${email} exists but with different auth provider. Returning existing user.`);\n            }\n            return user;\n        }\n        // User doesn't exist, create a new one\n        // Use a transaction to ensure both user and preferences are created atomically\n        const result = await sequelize.transaction(async (t)=>{\n            // Create the user\n            const newUser = await User.create({\n                email,\n                name,\n                auth_provider: authProvider,\n                auth_provider_id: authProviderId,\n                avatar_url: avatarUrl\n            }, {\n                transaction: t\n            });\n            // Create a default UserPreference record for the new user with explicit preferences_data\n            const newPref = await UserPreference.create({\n                user_id: newUser.user_id,\n                preferences_data: {}\n            }, {\n                transaction: t\n            });\n            console.log(\"DEBUG: Created default UserPreference with ID:\", newPref.preference_id);\n            // Fetch the user with UserPreference included\n            return await User.findByPk(newUser.user_id, {\n                // Use raw: false to ensure we get Sequelize model instances\n                raw: false,\n                include: [\n                    {\n                        model: UserPreference,\n                        // Ensure we get the full UserPreference model\n                        required: false,\n                        attributes: {\n                            include: [\n                                \"preferences_data\"\n                            ]\n                        }\n                    }\n                ],\n                transaction: t\n            });\n        });\n        user = result;\n        console.log(`Created new user ${email} with default preferences.`);\n        // If user exists but UserPreference doesn't, create a default one\n        if (user && !user.UserPreference) {\n            console.log(`DEBUG: New user ${email} has no UserPreference record. Creating default.`);\n            try {\n                // Create a default UserPreference record\n                const newPref = await UserPreference.create({\n                    user_id: user.user_id,\n                    preferences_data: {}\n                });\n                // Attach it to the user object\n                user.UserPreference = newPref;\n                console.log(\"DEBUG: Created and attached default UserPreference record\");\n            } catch (prefError) {\n                console.error(\"Error creating default UserPreference:\", prefError);\n            }\n        }\n        return user;\n    } catch (error) {\n        console.error(\"Error getting or creating user:\", error);\n        throw error;\n    }\n}\nasync function createConversation(userId) {\n    try {\n        // Check if userId is an email address\n        const isEmail = typeof userId === \"string\" && userId.includes(\"@\");\n        let actualUserId = userId;\n        // If userId is an email, find the user by email first to get the actual UUID\n        if (isEmail) {\n            const userByEmail = await User.findOne({\n                where: {\n                    email: userId\n                }\n            });\n            if (!userByEmail) {\n                console.log(`No user found with email: ${userId}`);\n                throw new Error(`Cannot create conversation: No user found with email: ${userId}`);\n            }\n            actualUserId = userByEmail.user_id;\n        }\n        const conversation = await Conversation.create({\n            user_id: actualUserId\n        });\n        return conversation;\n    } catch (error) {\n        console.error(\"Error creating conversation:\", error);\n        throw error;\n    }\n}\nasync function getConversation(conversationId) {\n    try {\n        return await Conversation.findByPk(conversationId, {\n            include: [\n                {\n                    model: ConversationMessage,\n                    order: [\n                        [\n                            \"sequence_number\",\n                            \"ASC\"\n                        ]\n                    ]\n                }\n            ]\n        });\n    } catch (error) {\n        console.error(\"Error getting conversation:\", error);\n        throw error;\n    }\n}\nasync function getConversationsByUserId(userId) {\n    try {\n        // Check if userId is an email address\n        const isEmail = typeof userId === \"string\" && userId.includes(\"@\");\n        let actualUserId = userId;\n        // If userId is an email, find the user by email first to get the actual UUID\n        if (isEmail) {\n            const userByEmail = await User.findOne({\n                where: {\n                    email: userId\n                }\n            });\n            if (!userByEmail) {\n                console.log(`No user found with email: ${userId}`);\n                return [];\n            }\n            actualUserId = userByEmail.user_id;\n        }\n        // Use EXPLAIN ANALYZE to understand query performance\n        if (true) {\n            const explainResult = await sequelize.query(`\n        EXPLAIN ANALYZE\n        SELECT * FROM conversations\n        WHERE user_id = '${actualUserId}'\n        ORDER BY created_at DESC\n      `);\n            console.log(\"Query execution plan:\", explainResult[0]);\n        }\n        return await Conversation.findAll({\n            where: {\n                user_id: actualUserId\n            },\n            order: [\n                [\n                    \"created_at\",\n                    \"DESC\"\n                ]\n            ]\n        });\n    } catch (error) {\n        console.error(\"Error getting conversations by user ID:\", error);\n        throw error;\n    }\n}\nasync function getConversationMessages(conversationId) {\n    try {\n        return await ConversationMessage.findAll({\n            where: {\n                conversation_id: conversationId\n            },\n            order: [\n                [\n                    \"sequence_number\",\n                    \"ASC\"\n                ]\n            ]\n        });\n    } catch (error) {\n        console.error(\"Error getting conversation messages:\", error);\n        throw error;\n    }\n}\nasync function addMessageToConversation(conversationId, role, content, { tool_calls = null, tool_call_id = null } = {} // Pass tool info as an object\n) {\n    try {\n        // Use a transaction for sequence number safety\n        const result = await sequelize.transaction(async (t)=>{\n            // Get the next sequence number within the transaction\n            const maxSequenceResult = await ConversationMessage.findOne({\n                attributes: [\n                    [\n                        sequelize.fn(\"max\", sequelize.col(\"sequence_number\")),\n                        \"maxSequence\"\n                    ]\n                ],\n                where: {\n                    conversation_id: conversationId\n                },\n                transaction: t,\n                raw: true\n            });\n            const maxSequence = maxSequenceResult?.maxSequence || 0;\n            // Create the message\n            const message = await ConversationMessage.create({\n                conversation_id: conversationId,\n                sequence_number: maxSequence + 1,\n                role,\n                content: content,\n                tool_calls: role === \"assistant\" ? tool_calls : null,\n                tool_call_id: role === \"tool\" ? tool_call_id : null\n            }, {\n                transaction: t\n            });\n            return message;\n        });\n        return result;\n    } catch (error) {\n        console.error(\"Error adding message to conversation:\", error);\n        // Log specific details if available\n        if (error.original) {\n            console.error(\"Original DB Error:\", error.original);\n        }\n        throw error; // Re-throw the error to be handled upstream\n    }\n}\n/**\n * Get user and their latest conversation in a single query\n * @param {string} userId - The user ID\n * @returns {Object} - User data with latest conversation\n */ async function getUserWithLatestConversation(userId) {\n    try {\n        // Check if userId is an email address\n        const isEmail = typeof userId === \"string\" && userId.includes(\"@\");\n        let actualUserId = userId;\n        // If userId is an email, find the user by email first to get the actual UUID\n        if (isEmail) {\n            const userByEmail = await User.findOne({\n                where: {\n                    email: userId\n                }\n            });\n            if (!userByEmail) {\n                console.log(`No user found with email: ${userId}`);\n                return null;\n            }\n            actualUserId = userByEmail.user_id;\n        }\n        // Use EXPLAIN ANALYZE to understand query performance\n        if (true) {\n            const explainResult = await sequelize.query(`\n        EXPLAIN ANALYZE\n        SELECT u.*, c.*\n        FROM users u\n        LEFT JOIN (\n          SELECT * FROM conversations\n          WHERE user_id = '${actualUserId}'\n          ORDER BY created_at DESC\n          LIMIT 1\n        ) c ON u.user_id = c.user_id\n        WHERE u.user_id = '${actualUserId}'\n      `);\n            console.log(\"Join query execution plan:\", explainResult[0]);\n        }\n        // Execute the actual query using Sequelize\n        console.log(`DEBUG: getUserWithLatestConversation - About to fetch user with ID: ${actualUserId}`);\n        const user = await User.findByPk(actualUserId, {\n            // Use raw: false to ensure we get Sequelize model instances\n            raw: false,\n            include: [\n                {\n                    model: Conversation,\n                    limit: 1,\n                    order: [\n                        [\n                            \"created_at\",\n                            \"DESC\"\n                        ]\n                    ],\n                    include: [\n                        {\n                            model: ConversationMessage,\n                            order: [\n                                [\n                                    \"sequence_number\",\n                                    \"DESC\"\n                                ]\n                            ],\n                            limit: 50,\n                            separate: true // This ensures all messages are loaded, not just one\n                        }\n                    ]\n                },\n                {\n                    model: UserPreference,\n                    // Ensure we get the full UserPreference model\n                    required: false,\n                    attributes: {\n                        include: [\n                            \"preferences_data\"\n                        ]\n                    }\n                }\n            ]\n        });\n        // Debug log the user object structure\n        console.log(\"DEBUG: getUserWithLatestConversation result:\", JSON.stringify({\n            user_id: user?.user_id || null,\n            email: user?.email || null,\n            hasUserPreference: user ? !!user.UserPreference : null,\n            userPreferenceDataValues: user?.UserPreference ? !!user.UserPreference.dataValues : null,\n            preferencesDataRaw: user?.UserPreference ? user.UserPreference.preferences_data : null,\n            preferencesDataFromDataValues: user?.UserPreference?.dataValues ? user.UserPreference.dataValues.preferences_data : null,\n            rawUserPreference: user?.UserPreference ? JSON.stringify(user.UserPreference).substring(0, 200) + \"...\" : null\n        }));\n        // If user exists but UserPreference doesn't, create a default one\n        if (user && !user.UserPreference) {\n            console.log(`DEBUG: User ${actualUserId} exists but has no UserPreference record. Creating default.`);\n            try {\n                // Create a default UserPreference record\n                const newPref = await UserPreference.create({\n                    user_id: actualUserId,\n                    preferences_data: {}\n                });\n                // Attach it to the user object\n                user.UserPreference = newPref;\n                console.log(\"DEBUG: Created and attached default UserPreference record\");\n            } catch (prefError) {\n                console.error(\"Error creating default UserPreference:\", prefError);\n            }\n        }\n        return user;\n    } catch (error) {\n        console.error(\"Error getting user with latest conversation:\", error);\n        throw error;\n    }\n}\n/**\n * Creates or updates metadata for a calendar event\n * @param {string} userId - User ID\n * @param {string} googleEventId - Google Calendar event ID\n * @param {Object} metadata - Metadata to store (priority, tags, etc.)\n * @param {string} calendarId - Calendar ID (defaults to 'primary')\n * @returns {Object} - Created or updated metadata record\n */ async function createOrUpdateEventMetadata(userId, googleEventId, metadata = {}, calendarId = \"primary\") {\n    try {\n        if (!userId || !googleEventId) {\n            throw new Error(\"User ID and Google Event ID are required\");\n        }\n        // Find existing metadata or create new record\n        const [eventMetadata, created] = await CalendarEventMetadata.findOrCreate({\n            where: {\n                user_id: userId,\n                google_calendar_id: calendarId,\n                google_event_id: googleEventId\n            },\n            defaults: {\n                user_id: userId,\n                google_calendar_id: calendarId,\n                google_event_id: googleEventId,\n                priority: metadata.priority || null,\n                tags: metadata.tags || null,\n                last_synced_at: new Date()\n            }\n        });\n        // If record exists, update it with new metadata\n        if (!created) {\n            const updateData = {};\n            // Only update fields that are provided\n            if (metadata.priority !== undefined) updateData.priority = metadata.priority;\n            if (metadata.tags !== undefined) updateData.tags = metadata.tags;\n            // Always update last_synced_at\n            updateData.last_synced_at = new Date();\n            await eventMetadata.update(updateData);\n        }\n        return eventMetadata;\n    } catch (error) {\n        console.error(\"Error creating/updating event metadata:\", error);\n        throw error;\n    }\n}\n/**\n * Delete metadata for a calendar event\n * @param {string} userId - User ID\n * @param {string} googleEventId - Google Calendar event ID\n * @param {string} calendarId - Calendar ID (defaults to 'primary')\n * @returns {boolean} - Success status\n */ async function deleteEventMetadata(userId, googleEventId, calendarId = \"primary\") {\n    try {\n        if (!userId || !googleEventId) {\n            throw new Error(\"User ID and Google Event ID are required\");\n        }\n        const result = await CalendarEventMetadata.destroy({\n            where: {\n                user_id: userId,\n                google_calendar_id: calendarId,\n                google_event_id: googleEventId\n            }\n        });\n        return result > 0;\n    } catch (error) {\n        console.error(\"Error deleting event metadata:\", error);\n        return false;\n    }\n}\n/**\n * Get metadata for multiple events in a single query\n * @param {string} userId - User ID\n * @param {Array} googleEventIds - Array of Google Calendar event IDs\n * @param {string} calendarId - Calendar ID (defaults to 'primary')\n * @returns {Array} - Array of metadata records\n */ async function getEventMetadataBatch(userId, googleEventIds, calendarId = \"primary\") {\n    try {\n        if (!userId || !Array.isArray(googleEventIds) || googleEventIds.length === 0) {\n            return [];\n        }\n        const metadata = await CalendarEventMetadata.findAll({\n            where: {\n                user_id: userId,\n                google_calendar_id: calendarId,\n                google_event_id: {\n                    [sequelize__WEBPACK_IMPORTED_MODULE_0__.Op.in]: googleEventIds\n                }\n            }\n        });\n        return metadata;\n    } catch (error) {\n        console.error(\"Error fetching event metadata batch:\", error);\n        return [];\n    }\n}\n// Export models and functions\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sequelize);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sQ0FBQztZQUNuRHhCLE9BQU87Z0JBQ0w3RSxTQUFTMEY7Z0JBQ1QzQyxvQkFBb0I4RTtnQkFDcEI3RSxpQkFBaUI7b0JBQUUsQ0FBQzlFLHlDQUFFQSxDQUFDMkssRUFBRSxDQUFDLEVBQUVIO2dCQUFlO1lBQzdDO1FBQ0Y7UUFFQSxPQUFPZDtJQUNULEVBQUUsT0FBTzdELE9BQU87UUFDZDdFLFFBQVE2RSxLQUFLLENBQUMsd0NBQXdDQTtRQUN0RCxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUEsOEJBQThCO0FBbUI1QjtBQUVGLGlFQUFlNUYsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi9wb3N0Z3Jlc0NsaWVudC5qcz8zZDg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9wb3N0Z3Jlc0NsaWVudC5qc1xuaW1wb3J0IHsgU2VxdWVsaXplLCBEYXRhVHlwZXMsIE9wIH0gZnJvbSAnc2VxdWVsaXplJztcbmltcG9ydCAnZG90ZW52L2NvbmZpZyc7XG5cbi8vIENyZWF0ZSBQb3N0Z3JlU1FMIGNvbm5lY3Rpb25cbmNvbnN0IHNlcXVlbGl6ZSA9IG5ldyBTZXF1ZWxpemUoe1xuICBkaWFsZWN0OiAncG9zdGdyZXMnLFxuICBob3N0OiBwcm9jZXNzLmVudi5QT1NUR1JFU19IT1NUIHx8ICdsb2NhbGhvc3QnLFxuICBwb3J0OiBwcm9jZXNzLmVudi5QT1NUR1JFU19QT1JUIHx8IDU0MzIsXG4gIHVzZXJuYW1lOiBwcm9jZXNzLmVudi5QT1NUR1JFU19VU0VSIHx8ICdwb3N0Z3JlcycsXG4gIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5QT1NUR1JFU19QQVNTV09SRCB8fCAncG9zdGdyZXMnLFxuICBkYXRhYmFzZTogcHJvY2Vzcy5lbnYuUE9TVEdSRVNfREIgfHwgJ2djYWxlbmRhcmFwcCcsXG4gIGxvZ2dpbmc6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gY29uc29sZS5sb2cgOiBmYWxzZSxcbiAgZGlhbGVjdE9wdGlvbnM6IHtcbiAgICBzc2w6IHByb2Nlc3MuZW52LlBPU1RHUkVTX1NTTCA9PT0gJ3RydWUnID8ge1xuICAgICAgcmVxdWlyZTogdHJ1ZSxcbiAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2VcbiAgICB9IDogZmFsc2VcbiAgfSxcbiAgcG9vbDoge1xuICAgIG1heDogNSxcbiAgICBtaW46IDAsXG4gICAgYWNxdWlyZTogMzAwMDAsXG4gICAgaWRsZTogMTAwMDBcbiAgfVxufSk7XG5cbi8vIERlZmluZSBtb2RlbHMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHNjaGVtYVxuY29uc3QgVXNlciA9IHNlcXVlbGl6ZS5kZWZpbmUoJ1VzZXInLCB7XG4gIHVzZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIGVtYWlsOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyNTUpLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgdW5pcXVlOiB0cnVlXG4gIH0sXG4gIG5hbWU6IERhdGFUeXBlcy5TVFJJTkcoMjU1KSxcbiAgYXZhdGFyX3VybDogRGF0YVR5cGVzLlRFWFQsXG4gIGF1dGhfcHJvdmlkZXI6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuU1RSSU5HKDUwKSxcbiAgICBhbGxvd051bGw6IGZhbHNlXG4gIH0sXG4gIGF1dGhfcHJvdmlkZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuU1RSSU5HKDI1NSksXG4gICAgYWxsb3dOdWxsOiBmYWxzZVxuICB9LFxuICB0aW1lem9uZToge1xuICAgIHR5cGU6IERhdGFUeXBlcy5TVFJJTkcoMTAwKSxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogJ1VUQydcbiAgfSxcbiAgY3JlYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9LFxuICB1cGRhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAndXNlcnMnLFxuICB0aW1lc3RhbXBzOiBmYWxzZSxcbiAgaW5kZXhlczogW1xuICAgIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICAgIGZpZWxkczogWydhdXRoX3Byb3ZpZGVyJywgJ2F1dGhfcHJvdmlkZXJfaWQnXVxuICAgIH1cbiAgXVxufSk7XG5cbmNvbnN0IFVzZXJQcmVmZXJlbmNlID0gc2VxdWVsaXplLmRlZmluZSgnVXNlclByZWZlcmVuY2UnLCB7XG4gIHByZWZlcmVuY2VfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIHVzZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIHJlZmVyZW5jZXM6IHtcbiAgICAgIG1vZGVsOiAndXNlcnMnLFxuICAgICAga2V5OiAndXNlcl9pZCdcbiAgICB9LFxuICAgIG9uRGVsZXRlOiAnQ0FTQ0FERSdcbiAgfSxcbiAgcHJlZmVyZW5jZXNfZGF0YToge1xuICAgIHR5cGU6IERhdGFUeXBlcy5KU09OQixcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZToge31cbiAgfSxcbiAgY3JlYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9LFxuICB1cGRhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAndXNlcl9wcmVmZXJlbmNlcycsXG4gIHRpbWVzdGFtcHM6IGZhbHNlLFxuICBpbmRleGVzOiBbXG4gICAge1xuICAgICAgZmllbGRzOiBbJ3VzZXJfaWQnXVxuICAgIH1cbiAgXVxufSk7XG5cbmNvbnN0IENvbnZlcnNhdGlvbiA9IHNlcXVlbGl6ZS5kZWZpbmUoJ0NvbnZlcnNhdGlvbicsIHtcbiAgY29udmVyc2F0aW9uX2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlVVSUQsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgndXVpZF9nZW5lcmF0ZV92NCgpJyksXG4gICAgcHJpbWFyeUtleTogdHJ1ZVxuICB9LFxuICB1c2VyX2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlVVSUQsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICByZWZlcmVuY2VzOiB7XG4gICAgICBtb2RlbDogJ3VzZXJzJyxcbiAgICAgIGtleTogJ3VzZXJfaWQnXG4gICAgfSxcbiAgICBvbkRlbGV0ZTogJ0NBU0NBREUnXG4gIH0sXG4gIHN0YXJ0X3RpbWU6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogU2VxdWVsaXplLmxpdGVyYWwoJ05PVygpJylcbiAgfSxcbiAgc3VtbWFyeTogRGF0YVR5cGVzLlRFWFQsXG4gIGNyZWF0ZWRfYXQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogU2VxdWVsaXplLmxpdGVyYWwoJ05PVygpJylcbiAgfSxcbiAgdXBkYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9XG59LCB7XG4gIHRhYmxlTmFtZTogJ2NvbnZlcnNhdGlvbnMnLFxuICB0aW1lc3RhbXBzOiBmYWxzZSxcbiAgaW5kZXhlczogW1xuICAgIHtcbiAgICAgIGZpZWxkczogWyd1c2VyX2lkJ11cbiAgICB9XG4gIF1cbn0pO1xuY29uc3QgQ29udmVyc2F0aW9uTWVzc2FnZSA9IHNlcXVlbGl6ZS5kZWZpbmUoJ0NvbnZlcnNhdGlvbk1lc3NhZ2UnLCB7XG4gIG1lc3NhZ2VfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIGNvbnZlcnNhdGlvbl9pZDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5VVUlELFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgcmVmZXJlbmNlczoge1xuICAgICAgbW9kZWw6ICdjb252ZXJzYXRpb25zJyxcbiAgICAgIGtleTogJ2NvbnZlcnNhdGlvbl9pZCdcbiAgICB9LFxuICAgIG9uRGVsZXRlOiAnQ0FTQ0FERSdcbiAgfSxcbiAgc2VxdWVuY2VfbnVtYmVyOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLklOVEVHRVIsXG4gICAgYWxsb3dOdWxsOiBmYWxzZVxuICB9LFxuICByb2xlOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyMCksXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICB2YWxpZGF0ZToge1xuICAgICAgaXNJbjogW1sndXNlcicsICdhc3Npc3RhbnQnLCAnc3lzdGVtJywgJ3Rvb2wnXV1cbiAgICB9XG4gIH0sXG4gIGNvbnRlbnQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVEVYVCxcbiAgICAvLyBBbGxvdyBudWxsIGNvbnRlbnQgZm9yIGFzc2lzdGFudCBtZXNzYWdlcyB0aGF0IE9OTFkgbWFrZSB0b29sIGNhbGxzXG4gICAgYWxsb3dOdWxsOiB0cnVlIC8vIENIQU5HRUQ6IEFsbG93IG51bGwgY29udGVudFxuICB9LFxuICAvLyAtLS0gTkVXL01PRElGSUVEIEZpZWxkcyAtLS1cbiAgdG9vbF9jYWxsczoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5KU09OQiwgLy8gU3RvcmUgdGhlIGZ1bGwgdG9vbF9jYWxscyBhcnJheSBmcm9tIHRoZSBhc3Npc3RhbnRcbiAgICBhbGxvd051bGw6IHRydWVcbiAgfSxcbiAgdG9vbF9jYWxsX2lkOiB7IC8vIEtlZXAgdGhpcyBPTkxZIGZvciAndG9vbCcgcm9sZSBtZXNzYWdlcyB0byBsaW5rIHJlc3BvbnNlXG4gICAgdHlwZTogRGF0YVR5cGVzLlRFWFQsXG4gICAgYWxsb3dOdWxsOiB0cnVlXG4gIH0sXG4gIC8vIC0tLSBSRU1PVkVEIEZpZWxkcyAocmVkdW5kYW50IGlmIHRvb2xfY2FsbHMgaXMgc3RvcmVkKSAtLS1cbiAgLy8gdG9vbF9jYWxsX25hbWU6IERhdGFUeXBlcy5URVhULFxuICAvLyB0b29sX2NhbGxfYXJnczogRGF0YVR5cGVzLkpTT05CLFxuICAvLyB0b29sX3Jlc3BvbnNlX2NvbnRlbnQ6IERhdGFUeXBlcy5URVhULCAvLyBDb250ZW50IGZpZWxkIGlzIHVzZWQgZm9yIHRvb2wgcmVzcG9uc2VcblxuICBjcmVhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAnY29udmVyc2F0aW9uX21lc3NhZ2VzJyxcbiAgdGltZXN0YW1wczogZmFsc2UsIC8vIEFzc3VtaW5nIHlvdSBoYW5kbGUgdGltZXN0YW1wcyBtYW51YWxseSBvciB2aWEgdHJpZ2dlcnNcbiAgaW5kZXhlczogW1xuICAgIC8vIEtlZXAgZXhpc3RpbmcgaW5kZXhlcyBpZiB0aGV5IG1ha2Ugc2Vuc2VcbiAgICB7IGZpZWxkczogWydjb252ZXJzYXRpb25faWQnLCAnY3JlYXRlZF9hdCddIH0sXG4gICAgeyBmaWVsZHM6IFsnY29udmVyc2F0aW9uX2lkJywgJ3NlcXVlbmNlX251bWJlciddIH0sXG4gICAgLy8gQWRkIGluZGV4IGZvciB0b29sX2NhbGxfaWQgaWYgbmVlZGVkIGZvciBsb29rdXBzXG4gICAgeyBmaWVsZHM6IFsndG9vbF9jYWxsX2lkJ10gfVxuICBdXG59KTtcblxuXG5cbmNvbnN0IENhbGVuZGFyRXZlbnRNZXRhZGF0YSA9IHNlcXVlbGl6ZS5kZWZpbmUoJ0NhbGVuZGFyRXZlbnRNZXRhZGF0YScsIHtcbiAgbWV0YWRhdGFfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCd1dWlkX2dlbmVyYXRlX3Y0KCknKSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIHVzZXJfaWQ6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuVVVJRCxcbiAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgIHJlZmVyZW5jZXM6IHtcbiAgICAgIG1vZGVsOiAndXNlcnMnLFxuICAgICAga2V5OiAndXNlcl9pZCdcbiAgICB9LFxuICAgIG9uRGVsZXRlOiAnQ0FTQ0FERSdcbiAgfSxcbiAgZ29vZ2xlX2NhbGVuZGFyX2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyNTUpLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiAncHJpbWFyeSdcbiAgfSxcbiAgZ29vZ2xlX2V2ZW50X2lkOiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLlNUUklORygyNTUpLFxuICAgIGFsbG93TnVsbDogZmFsc2VcbiAgfSxcbiAgcHJpb3JpdHk6IHtcbiAgICB0eXBlOiBEYXRhVHlwZXMuU1RSSU5HKDIwKSxcbiAgICB2YWxpZGF0ZToge1xuICAgICAgaXNJbjogW1snTG93JywgJ01lZGl1bScsICdIaWdoJywgJ1VyZ2VudCddXVxuICAgIH1cbiAgfSxcbiAgZGVhZGxpbmU6IERhdGFUeXBlcy5EQVRFLFxuICB0YXNrX3N0YXR1czoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5TVFJJTkcoMzApLFxuICAgIHZhbGlkYXRlOiB7XG4gICAgICBpc0luOiBbWydOb3QgU3RhcnRlZCcsICdJbiBQcm9ncmVzcycsICdDb21wbGV0ZWQnLCAnQmxvY2tlZCcsICdEZWZlcnJlZCddXVxuICAgIH1cbiAgfSxcbiAgZXZlbnRfc3VtbWFyeV9jYWNoZWQ6IERhdGFUeXBlcy5URVhULFxuICBzdGFydF90aW1lX2NhY2hlZDogRGF0YVR5cGVzLkRBVEUsXG4gIGVuZF90aW1lX2NhY2hlZDogRGF0YVR5cGVzLkRBVEUsXG4gIGxvY2F0aW9uX2NhY2hlZDogRGF0YVR5cGVzLlRFWFQsXG4gIGxhc3Rfc3luY2VkX2F0OiBEYXRhVHlwZXMuREFURSxcbiAgY3JlYXRlZF9hdDoge1xuICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiBTZXF1ZWxpemUubGl0ZXJhbCgnTk9XKCknKVxuICB9LFxuICB1cGRhdGVkX2F0OiB7XG4gICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNlcXVlbGl6ZS5saXRlcmFsKCdOT1coKScpXG4gIH1cbn0sIHtcbiAgdGFibGVOYW1lOiAnY2FsZW5kYXJfZXZlbnRfbWV0YWRhdGEnLFxuICB0aW1lc3RhbXBzOiBmYWxzZSxcbiAgaW5kZXhlczogW1xuICAgIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICAgIGZpZWxkczogWyd1c2VyX2lkJywgJ2dvb2dsZV9jYWxlbmRhcl9pZCcsICdnb29nbGVfZXZlbnRfaWQnXVxuICAgIH0sXG4gICAge1xuICAgICAgZmllbGRzOiBbJ3VzZXJfaWQnLCAnZGVhZGxpbmUnXVxuICAgIH0sXG4gICAge1xuICAgICAgZmllbGRzOiBbJ3VzZXJfaWQnLCAncHJpb3JpdHknXVxuICAgIH1cbiAgXVxufSk7XG5cbi8vIERlZmluZSByZWxhdGlvbnNoaXBzXG5Vc2VyLmhhc01hbnkoQ29udmVyc2F0aW9uLCB7IGZvcmVpZ25LZXk6ICd1c2VyX2lkJyB9KTtcbkNvbnZlcnNhdGlvbi5iZWxvbmdzVG8oVXNlciwgeyBmb3JlaWduS2V5OiAndXNlcl9pZCcgfSk7XG5cblVzZXIuaGFzT25lKFVzZXJQcmVmZXJlbmNlLCB7IGZvcmVpZ25LZXk6ICd1c2VyX2lkJyB9KTtcblVzZXJQcmVmZXJlbmNlLmJlbG9uZ3NUbyhVc2VyLCB7IGZvcmVpZ25LZXk6ICd1c2VyX2lkJyB9KTtcblxuQ29udmVyc2F0aW9uLmhhc01hbnkoQ29udmVyc2F0aW9uTWVzc2FnZSwgeyBmb3JlaWduS2V5OiAnY29udmVyc2F0aW9uX2lkJyB9KTtcbkNvbnZlcnNhdGlvbk1lc3NhZ2UuYmVsb25nc1RvKENvbnZlcnNhdGlvbiwgeyBmb3JlaWduS2V5OiAnY29udmVyc2F0aW9uX2lkJyB9KTtcblxuVXNlci5oYXNNYW55KENhbGVuZGFyRXZlbnRNZXRhZGF0YSwgeyBmb3JlaWduS2V5OiAndXNlcl9pZCcgfSk7XG5DYWxlbmRhckV2ZW50TWV0YWRhdGEuYmVsb25nc1RvKFVzZXIsIHsgZm9yZWlnbktleTogJ3VzZXJfaWQnIH0pO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBjb252ZXJzYXRpb24gbWFuYWdlbWVudFxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZURhdGFiYXNlKCkge1xuICB0cnkge1xuICAgIC8vIFRlc3QgY29ubmVjdGlvblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZXF1ZWxpemUuYXV0aGVudGljYXRlKCk7XG4gICAgICBjb25zb2xlLmxvZygnUG9zdGdyZVNRTCBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGNvbm5lY3QgdG8gdGhlIGRhdGFiYXNlOicsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUubG9nKCdNYWtlIHN1cmUgUG9zdGdyZVNRTCBpcyBydW5uaW5nIGFuZCB0aGUgZGF0YWJhc2UgZXhpc3RzLicpO1xuICAgICAgY29uc29sZS5sb2coJ1lvdSBjYW4gY3JlYXRlIHRoZSBkYXRhYmFzZSBieSBydW5uaW5nOiBucG0gcnVuIGluaXQtcG9zdGdyZXMnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQuIFNlZSBhYm92ZSBmb3IgZGV0YWlscy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGV4dGVuc2lvbiBmb3IgVVVJRCBnZW5lcmF0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgIGF3YWl0IHNlcXVlbGl6ZS5xdWVyeSgnQ1JFQVRFIEVYVEVOU0lPTiBJRiBOT1QgRVhJU1RTIFwidXVpZC1vc3NwXCI7Jyk7XG4gICAgICBjb25zb2xlLmxvZygnVVVJRCBleHRlbnNpb24gZW5hYmxlZCBzdWNjZXNzZnVsbHkuJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFVVSUQgZXh0ZW5zaW9uOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgdGltZXN0YW1wIHRyaWdnZXIgZnVuY3Rpb24gaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT04gdHJpZ2dlcl9zZXRfdGltZXN0YW1wKClcbiAgICAgICAgUkVUVVJOUyBUUklHR0VSIEFTICQkXG4gICAgICAgIEJFR0lOXG4gICAgICAgICAgTkVXLnVwZGF0ZWRfYXQgPSBOT1coKTtcbiAgICAgICAgICBSRVRVUk4gTkVXO1xuICAgICAgICBFTkQ7XG4gICAgICAgICQkIExBTkdVQUdFIHBscGdzcWw7XG4gICAgICBgKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUaW1lc3RhbXAgdHJpZ2dlciBmdW5jdGlvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGltZXN0YW1wIHRyaWdnZXIgZnVuY3Rpb246JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFN5bmMgYWxsIG1vZGVscyB3aXRob3V0IGZvcmNlOiB0cnVlIHRvIGF2b2lkIGRyb3BwaW5nIHRhYmxlc1xuICAgICAgY29uc29sZS5sb2coJ1N5bmNocm9uaXppbmcgbW9kZWxzIChub24tZGVzdHJ1Y3RpdmUpLi4uJyk7XG4gICAgICAvLyBVc2UgeyBhbHRlcjogdHJ1ZSB9IHRvIGFwcGx5IHNjaGVtYSBjaGFuZ2VzIG5vbi1kZXN0cnVjdGl2ZWx5XG4gICAgICBhd2FpdCBzZXF1ZWxpemUuc3luYyh7IGFsdGVyOiB0cnVlIH0pO1xuICAgICAgY29uc29sZS5sb2coJ0FsbCBtb2RlbHMgd2VyZSBzeW5jaHJvbml6ZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgXG4gICAgICAvLyBOb3RlOiBGb3IgcHJvZHVjdGlvbiwgZGF0YWJhc2Ugc3RydWN0dXJlIHNob3VsZCBiZSBtYW5hZ2VkIHZpYSBtaWdyYXRpb25zXG4gICAgICAvLyByYXRoZXIgdGhhbiBhdXRvbWF0aWMgc3luY1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzeW5jaHJvbml6aW5nIG1vZGVsczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHRvb2xfY2FsbHMgY29sdW1uIGV4aXN0cyBpbiBjb252ZXJzYXRpb25fbWVzc2FnZXMgdGFibGVcbiAgICAgIGNvbnN0IGNoZWNrQ29sdW1uUmVzdWx0ID0gYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgU0VMRUNUIGNvbHVtbl9uYW1lXG4gICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnNcbiAgICAgICAgV0hFUkUgdGFibGVfbmFtZSA9ICdjb252ZXJzYXRpb25fbWVzc2FnZXMnXG4gICAgICAgIEFORCBjb2x1bW5fbmFtZSA9ICd0b29sX2NhbGxzJztcbiAgICAgIGApO1xuICAgICAgXG4gICAgICAvLyBJZiBjb2x1bW4gZG9lc24ndCBleGlzdCwgYWRkIGl0XG4gICAgICBpZiAoY2hlY2tDb2x1bW5SZXN1bHRbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgbWlzc2luZyB0b29sX2NhbGxzIGNvbHVtbiB0byBjb252ZXJzYXRpb25fbWVzc2FnZXMgdGFibGUuLi4nKTtcbiAgICAgICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgICBBTFRFUiBUQUJMRSBjb252ZXJzYXRpb25fbWVzc2FnZXNcbiAgICAgICAgICBBREQgQ09MVU1OIHRvb2xfY2FsbHMgSlNPTkI7XG4gICAgICAgIGApO1xuICAgICAgICBjb25zb2xlLmxvZygndG9vbF9jYWxscyBjb2x1bW4gYWRkZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Rvb2xfY2FsbHMgY29sdW1uIGFscmVhZHkgZXhpc3RzIGluIGNvbnZlcnNhdGlvbl9tZXNzYWdlcyB0YWJsZS4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgb3IgYWRkaW5nIHRvb2xfY2FsbHMgY29sdW1uOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgdHJpZ2dlcnMgZm9yIHVwZGF0ZWRfYXQgdGltZXN0YW1wc1xuICAgICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgRE8gJCRcbiAgICAgICAgQkVHSU5cbiAgICAgICAgICBJRiBOT1QgRVhJU1RTIChTRUxFQ1QgMSBGUk9NIHBnX3RyaWdnZXIgV0hFUkUgdGduYW1lID0gJ3NldF90aW1lc3RhbXBfdXNlcnMnKSBUSEVOXG4gICAgICAgICAgICBDUkVBVEUgVFJJR0dFUiBzZXRfdGltZXN0YW1wX3VzZXJzXG4gICAgICAgICAgICBCRUZPUkUgVVBEQVRFIE9OIHVzZXJzXG4gICAgICAgICAgICBGT1IgRUFDSCBST1dcbiAgICAgICAgICAgIEVYRUNVVEUgRlVOQ1RJT04gdHJpZ2dlcl9zZXRfdGltZXN0YW1wKCk7XG4gICAgICAgICAgRU5EIElGO1xuXG4gICAgICAgICAgSUYgTk9UIEVYSVNUUyAoU0VMRUNUIDEgRlJPTSBwZ190cmlnZ2VyIFdIRVJFIHRnbmFtZSA9ICdzZXRfdGltZXN0YW1wX3VzZXJfcHJlZmVyZW5jZXMnKSBUSEVOXG4gICAgICAgICAgICBDUkVBVEUgVFJJR0dFUiBzZXRfdGltZXN0YW1wX3VzZXJfcHJlZmVyZW5jZXNcbiAgICAgICAgICAgIEJFRk9SRSBVUERBVEUgT04gdXNlcl9wcmVmZXJlbmNlc1xuICAgICAgICAgICAgRk9SIEVBQ0ggUk9XXG4gICAgICAgICAgICBFWEVDVVRFIEZVTkNUSU9OIHRyaWdnZXJfc2V0X3RpbWVzdGFtcCgpO1xuICAgICAgICAgIEVORCBJRjtcblxuICAgICAgICAgIElGIE5PVCBFWElTVFMgKFNFTEVDVCAxIEZST00gcGdfdHJpZ2dlciBXSEVSRSB0Z25hbWUgPSAnc2V0X3RpbWVzdGFtcF9jb252ZXJzYXRpb25zJykgVEhFTlxuICAgICAgICAgICAgQ1JFQVRFIFRSSUdHRVIgc2V0X3RpbWVzdGFtcF9jb252ZXJzYXRpb25zXG4gICAgICAgICAgICBCRUZPUkUgVVBEQVRFIE9OIGNvbnZlcnNhdGlvbnNcbiAgICAgICAgICAgIEZPUiBFQUNIIFJPV1xuICAgICAgICAgICAgRVhFQ1VURSBGVU5DVElPTiB0cmlnZ2VyX3NldF90aW1lc3RhbXAoKTtcbiAgICAgICAgICBFTkQgSUY7XG5cbiAgICAgICAgICBJRiBOT1QgRVhJU1RTIChTRUxFQ1QgMSBGUk9NIHBnX3RyaWdnZXIgV0hFUkUgdGduYW1lID0gJ3NldF90aW1lc3RhbXBfY2FsZW5kYXJfZXZlbnRfbWV0YWRhdGEnKSBUSEVOXG4gICAgICAgICAgICBDUkVBVEUgVFJJR0dFUiBzZXRfdGltZXN0YW1wX2NhbGVuZGFyX2V2ZW50X21ldGFkYXRhXG4gICAgICAgICAgICBCRUZPUkUgVVBEQVRFIE9OIGNhbGVuZGFyX2V2ZW50X21ldGFkYXRhXG4gICAgICAgICAgICBGT1IgRUFDSCBST1dcbiAgICAgICAgICAgIEVYRUNVVEUgRlVOQ1RJT04gdHJpZ2dlcl9zZXRfdGltZXN0YW1wKCk7XG4gICAgICAgICAgRU5EIElGO1xuICAgICAgICBFTkRcbiAgICAgICAgJCQ7XG4gICAgICBgKTtcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhYmFzZSB0cmlnZ2VycyBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdHJpZ2dlcnM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0RhdGFiYXNlIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGluaXRpYWxpemUgZGF0YWJhc2U6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIENvbnZlcnNhdGlvbiBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuYXN5bmMgZnVuY3Rpb24gZ2V0T3JDcmVhdGVVc2VyKGVtYWlsLCBuYW1lLCBhdXRoUHJvdmlkZXIsIGF1dGhQcm92aWRlcklkLCBhdmF0YXJVcmwgPSBudWxsKSB7XG4gIHRyeSB7XG4gICAgLy8gRmlyc3QgdHJ5IHRvIGZpbmQgdGhlIHVzZXIgYnkgZW1haWxcbiAgICBsZXQgdXNlciA9IGF3YWl0IFVzZXIuZmluZE9uZSh7XG4gICAgICAvLyBVc2UgcmF3OiBmYWxzZSB0byBlbnN1cmUgd2UgZ2V0IFNlcXVlbGl6ZSBtb2RlbCBpbnN0YW5jZXNcbiAgICAgIHJhdzogZmFsc2UsXG4gICAgICB3aGVyZTogeyBlbWFpbCB9LFxuICAgICAgaW5jbHVkZTogW1xuICAgICAgICB7XG4gICAgICAgICAgbW9kZWw6IFVzZXJQcmVmZXJlbmNlLFxuICAgICAgICAgIC8vIEVuc3VyZSB3ZSBnZXQgdGhlIGZ1bGwgVXNlclByZWZlcmVuY2UgbW9kZWxcbiAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgYXR0cmlidXRlczogeyBpbmNsdWRlOiBbJ3ByZWZlcmVuY2VzX2RhdGEnXSB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAodXNlcikge1xuICAgICAgLy8gVXNlciBleGlzdHMsIGNoZWNrIGlmIHdlIG5lZWQgdG8gdXBkYXRlIGF1dGggcHJvdmlkZXIgaW5mb1xuICAgICAgaWYgKHVzZXIuYXV0aF9wcm92aWRlciAhPT0gYXV0aFByb3ZpZGVyIHx8IHVzZXIuYXV0aF9wcm92aWRlcl9pZCAhPT0gYXV0aFByb3ZpZGVySWQpIHtcbiAgICAgICAgLy8gT25seSB1cGRhdGUgaWYgdGhlIGF1dGggcHJvdmlkZXIgaW5mbyBpcyBkaWZmZXJlbnRcbiAgICAgICAgY29uc29sZS5sb2coYFVzZXIgd2l0aCBlbWFpbCAke2VtYWlsfSBleGlzdHMgYnV0IHdpdGggZGlmZmVyZW50IGF1dGggcHJvdmlkZXIuIFJldHVybmluZyBleGlzdGluZyB1c2VyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfVxuICAgIFxuICAgIC8vIFVzZXIgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZVxuICAgIC8vIFVzZSBhIHRyYW5zYWN0aW9uIHRvIGVuc3VyZSBib3RoIHVzZXIgYW5kIHByZWZlcmVuY2VzIGFyZSBjcmVhdGVkIGF0b21pY2FsbHlcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXF1ZWxpemUudHJhbnNhY3Rpb24oYXN5bmMgKHQpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgdXNlclxuICAgICAgY29uc3QgbmV3VXNlciA9IGF3YWl0IFVzZXIuY3JlYXRlKHtcbiAgICAgICAgZW1haWwsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGF1dGhfcHJvdmlkZXI6IGF1dGhQcm92aWRlcixcbiAgICAgICAgYXV0aF9wcm92aWRlcl9pZDogYXV0aFByb3ZpZGVySWQsXG4gICAgICAgIGF2YXRhcl91cmw6IGF2YXRhclVybFxuICAgICAgfSwgeyB0cmFuc2FjdGlvbjogdCB9KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgZGVmYXVsdCBVc2VyUHJlZmVyZW5jZSByZWNvcmQgZm9yIHRoZSBuZXcgdXNlciB3aXRoIGV4cGxpY2l0IHByZWZlcmVuY2VzX2RhdGFcbiAgICAgIGNvbnN0IG5ld1ByZWYgPSBhd2FpdCBVc2VyUHJlZmVyZW5jZS5jcmVhdGUoe1xuICAgICAgICB1c2VyX2lkOiBuZXdVc2VyLnVzZXJfaWQsXG4gICAgICAgIHByZWZlcmVuY2VzX2RhdGE6IHt9XG4gICAgICB9LCB7IHRyYW5zYWN0aW9uOiB0IH0pO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkRFQlVHOiBDcmVhdGVkIGRlZmF1bHQgVXNlclByZWZlcmVuY2Ugd2l0aCBJRDpcIiwgbmV3UHJlZi5wcmVmZXJlbmNlX2lkKTtcbiAgICAgIFxuICAgICAgLy8gRmV0Y2ggdGhlIHVzZXIgd2l0aCBVc2VyUHJlZmVyZW5jZSBpbmNsdWRlZFxuICAgICAgcmV0dXJuIGF3YWl0IFVzZXIuZmluZEJ5UGsobmV3VXNlci51c2VyX2lkLCB7XG4gICAgICAgIC8vIFVzZSByYXc6IGZhbHNlIHRvIGVuc3VyZSB3ZSBnZXQgU2VxdWVsaXplIG1vZGVsIGluc3RhbmNlc1xuICAgICAgICByYXc6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogVXNlclByZWZlcmVuY2UsXG4gICAgICAgICAgLy8gRW5zdXJlIHdlIGdldCB0aGUgZnVsbCBVc2VyUHJlZmVyZW5jZSBtb2RlbFxuICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7IGluY2x1ZGU6IFsncHJlZmVyZW5jZXNfZGF0YSddIH1cbiAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB0cmFuc2FjdGlvbjogdFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgdXNlciA9IHJlc3VsdDtcbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRlZCBuZXcgdXNlciAke2VtYWlsfSB3aXRoIGRlZmF1bHQgcHJlZmVyZW5jZXMuYCk7XG4gICAgXG4gICAgLy8gSWYgdXNlciBleGlzdHMgYnV0IFVzZXJQcmVmZXJlbmNlIGRvZXNuJ3QsIGNyZWF0ZSBhIGRlZmF1bHQgb25lXG4gICAgaWYgKHVzZXIgJiYgIXVzZXIuVXNlclByZWZlcmVuY2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBERUJVRzogTmV3IHVzZXIgJHtlbWFpbH0gaGFzIG5vIFVzZXJQcmVmZXJlbmNlIHJlY29yZC4gQ3JlYXRpbmcgZGVmYXVsdC5gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmF1bHQgVXNlclByZWZlcmVuY2UgcmVjb3JkXG4gICAgICAgIGNvbnN0IG5ld1ByZWYgPSBhd2FpdCBVc2VyUHJlZmVyZW5jZS5jcmVhdGUoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIudXNlcl9pZCxcbiAgICAgICAgICBwcmVmZXJlbmNlc19kYXRhOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dGFjaCBpdCB0byB0aGUgdXNlciBvYmplY3RcbiAgICAgICAgdXNlci5Vc2VyUHJlZmVyZW5jZSA9IG5ld1ByZWY7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IENyZWF0ZWQgYW5kIGF0dGFjaGVkIGRlZmF1bHQgVXNlclByZWZlcmVuY2UgcmVjb3JkXCIpO1xuICAgICAgfSBjYXRjaCAocHJlZkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBkZWZhdWx0IFVzZXJQcmVmZXJlbmNlOlwiLCBwcmVmRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdXNlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG9yIGNyZWF0aW5nIHVzZXI6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnNhdGlvbih1c2VySWQpIHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiB1c2VySWQgaXMgYW4gZW1haWwgYWRkcmVzc1xuICAgIGNvbnN0IGlzRW1haWwgPSB0eXBlb2YgdXNlcklkID09PSAnc3RyaW5nJyAmJiB1c2VySWQuaW5jbHVkZXMoJ0AnKTtcbiAgICBsZXQgYWN0dWFsVXNlcklkID0gdXNlcklkO1xuICAgIFxuICAgIC8vIElmIHVzZXJJZCBpcyBhbiBlbWFpbCwgZmluZCB0aGUgdXNlciBieSBlbWFpbCBmaXJzdCB0byBnZXQgdGhlIGFjdHVhbCBVVUlEXG4gICAgaWYgKGlzRW1haWwpIHtcbiAgICAgIGNvbnN0IHVzZXJCeUVtYWlsID0gYXdhaXQgVXNlci5maW5kT25lKHsgd2hlcmU6IHsgZW1haWw6IHVzZXJJZCB9IH0pO1xuICAgICAgaWYgKCF1c2VyQnlFbWFpbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgTm8gdXNlciBmb3VuZCB3aXRoIGVtYWlsOiAke3VzZXJJZH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGNvbnZlcnNhdGlvbjogTm8gdXNlciBmb3VuZCB3aXRoIGVtYWlsOiAke3VzZXJJZH1gKTtcbiAgICAgIH1cbiAgICAgIGFjdHVhbFVzZXJJZCA9IHVzZXJCeUVtYWlsLnVzZXJfaWQ7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IGF3YWl0IENvbnZlcnNhdGlvbi5jcmVhdGUoe1xuICAgICAgdXNlcl9pZDogYWN0dWFsVXNlcklkXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnZlcnNhdGlvbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjb252ZXJzYXRpb246JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbihjb252ZXJzYXRpb25JZCkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBDb252ZXJzYXRpb24uZmluZEJ5UGsoY29udmVyc2F0aW9uSWQsIHtcbiAgICAgIGluY2x1ZGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBDb252ZXJzYXRpb25NZXNzYWdlLFxuICAgICAgICAgIG9yZGVyOiBbWydzZXF1ZW5jZV9udW1iZXInLCAnQVNDJ11dXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNvbnZlcnNhdGlvbjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uc0J5VXNlcklkKHVzZXJJZCkge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHVzZXJJZCBpcyBhbiBlbWFpbCBhZGRyZXNzXG4gICAgY29uc3QgaXNFbWFpbCA9IHR5cGVvZiB1c2VySWQgPT09ICdzdHJpbmcnICYmIHVzZXJJZC5pbmNsdWRlcygnQCcpO1xuICAgIGxldCBhY3R1YWxVc2VySWQgPSB1c2VySWQ7XG4gICAgXG4gICAgLy8gSWYgdXNlcklkIGlzIGFuIGVtYWlsLCBmaW5kIHRoZSB1c2VyIGJ5IGVtYWlsIGZpcnN0IHRvIGdldCB0aGUgYWN0dWFsIFVVSURcbiAgICBpZiAoaXNFbWFpbCkge1xuICAgICAgY29uc3QgdXNlckJ5RW1haWwgPSBhd2FpdCBVc2VyLmZpbmRPbmUoeyB3aGVyZTogeyBlbWFpbDogdXNlcklkIH0gfSk7XG4gICAgICBpZiAoIXVzZXJCeUVtYWlsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBObyB1c2VyIGZvdW5kIHdpdGggZW1haWw6ICR7dXNlcklkfWApO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBhY3R1YWxVc2VySWQgPSB1c2VyQnlFbWFpbC51c2VyX2lkO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2UgRVhQTEFJTiBBTkFMWVpFIHRvIHVuZGVyc3RhbmQgcXVlcnkgcGVyZm9ybWFuY2VcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnN0IGV4cGxhaW5SZXN1bHQgPSBhd2FpdCBzZXF1ZWxpemUucXVlcnkoYFxuICAgICAgICBFWFBMQUlOIEFOQUxZWkVcbiAgICAgICAgU0VMRUNUICogRlJPTSBjb252ZXJzYXRpb25zXG4gICAgICAgIFdIRVJFIHVzZXJfaWQgPSAnJHthY3R1YWxVc2VySWR9J1xuICAgICAgICBPUkRFUiBCWSBjcmVhdGVkX2F0IERFU0NcbiAgICAgIGApO1xuICAgICAgY29uc29sZS5sb2coJ1F1ZXJ5IGV4ZWN1dGlvbiBwbGFuOicsIGV4cGxhaW5SZXN1bHRbMF0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYXdhaXQgQ29udmVyc2F0aW9uLmZpbmRBbGwoe1xuICAgICAgd2hlcmU6IHsgdXNlcl9pZDogYWN0dWFsVXNlcklkIH0sXG4gICAgICBvcmRlcjogW1snY3JlYXRlZF9hdCcsICdERVNDJ11dXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjb252ZXJzYXRpb25zIGJ5IHVzZXIgSUQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbk1lc3NhZ2VzKGNvbnZlcnNhdGlvbklkKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IENvbnZlcnNhdGlvbk1lc3NhZ2UuZmluZEFsbCh7XG4gICAgICB3aGVyZTogeyBjb252ZXJzYXRpb25faWQ6IGNvbnZlcnNhdGlvbklkIH0sXG4gICAgICBvcmRlcjogW1snc2VxdWVuY2VfbnVtYmVyJywgJ0FTQyddXVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY29udmVyc2F0aW9uIG1lc3NhZ2VzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIGFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbihcbiAgY29udmVyc2F0aW9uSWQsXG4gIHJvbGUsXG4gIGNvbnRlbnQsIC8vIENhbiBiZSBudWxsL3VuZGVmaW5lZCBmb3IgYXNzaXN0YW50IHRvb2wgY2FsbHNcbiAgeyB0b29sX2NhbGxzID0gbnVsbCwgdG9vbF9jYWxsX2lkID0gbnVsbCB9ID0ge30gLy8gUGFzcyB0b29sIGluZm8gYXMgYW4gb2JqZWN0XG4pIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYSB0cmFuc2FjdGlvbiBmb3Igc2VxdWVuY2UgbnVtYmVyIHNhZmV0eVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcXVlbGl6ZS50cmFuc2FjdGlvbihhc3luYyAodCkgPT4ge1xuICAgICAgLy8gR2V0IHRoZSBuZXh0IHNlcXVlbmNlIG51bWJlciB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCBtYXhTZXF1ZW5jZVJlc3VsdCA9IGF3YWl0IENvbnZlcnNhdGlvbk1lc3NhZ2UuZmluZE9uZSh7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFtbc2VxdWVsaXplLmZuKCdtYXgnLCBzZXF1ZWxpemUuY29sKCdzZXF1ZW5jZV9udW1iZXInKSksICdtYXhTZXF1ZW5jZSddXSxcbiAgICAgICAgd2hlcmU6IHsgY29udmVyc2F0aW9uX2lkOiBjb252ZXJzYXRpb25JZCB9LFxuICAgICAgICB0cmFuc2FjdGlvbjogdCxcbiAgICAgICAgcmF3OiB0cnVlLCAvLyBHZXQgcmF3IHJlc3VsdFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtYXhTZXF1ZW5jZSA9IG1heFNlcXVlbmNlUmVzdWx0Py5tYXhTZXF1ZW5jZSB8fCAwO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIG1lc3NhZ2VcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBDb252ZXJzYXRpb25NZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgIGNvbnZlcnNhdGlvbl9pZDogY29udmVyc2F0aW9uSWQsXG4gICAgICAgIHNlcXVlbmNlX251bWJlcjogbWF4U2VxdWVuY2UgKyAxLFxuICAgICAgICByb2xlLFxuICAgICAgICBjb250ZW50OiBjb250ZW50LCAvLyBTdG9yZSBjb250ZW50IChjYW4gYmUgbnVsbClcbiAgICAgICAgdG9vbF9jYWxsczogcm9sZSA9PT0gJ2Fzc2lzdGFudCcgPyB0b29sX2NhbGxzIDogbnVsbCwgLy8gU3RvcmUgdG9vbF9jYWxscyBPTkxZIGZvciBhc3Npc3RhbnRcbiAgICAgICAgdG9vbF9jYWxsX2lkOiByb2xlID09PSAndG9vbCcgPyB0b29sX2NhbGxfaWQgOiBudWxsLCAvLyBTdG9yZSB0b29sX2NhbGxfaWQgT05MWSBmb3IgdG9vbCByZXNwb25zZVxuICAgICAgfSwgeyB0cmFuc2FjdGlvbjogdCB9KTtcblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG1lc3NhZ2UgdG8gY29udmVyc2F0aW9uOicsIGVycm9yKTtcbiAgICAvLyBMb2cgc3BlY2lmaWMgZGV0YWlscyBpZiBhdmFpbGFibGVcbiAgICBpZiAoZXJyb3Iub3JpZ2luYWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignT3JpZ2luYWwgREIgRXJyb3I6JywgZXJyb3Iub3JpZ2luYWwpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdGhlIGVycm9yIHRvIGJlIGhhbmRsZWQgdXBzdHJlYW1cbiAgfVxufVxuXG5cblxuLyoqXG4gKiBHZXQgdXNlciBhbmQgdGhlaXIgbGF0ZXN0IGNvbnZlcnNhdGlvbiBpbiBhIHNpbmdsZSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyIElEXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIFVzZXIgZGF0YSB3aXRoIGxhdGVzdCBjb252ZXJzYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlcldpdGhMYXRlc3RDb252ZXJzYXRpb24odXNlcklkKSB7XG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgaWYgdXNlcklkIGlzIGFuIGVtYWlsIGFkZHJlc3NcbiAgICBjb25zdCBpc0VtYWlsID0gdHlwZW9mIHVzZXJJZCA9PT0gJ3N0cmluZycgJiYgdXNlcklkLmluY2x1ZGVzKCdAJyk7XG4gICAgbGV0IGFjdHVhbFVzZXJJZCA9IHVzZXJJZDtcbiAgICBcbiAgICAvLyBJZiB1c2VySWQgaXMgYW4gZW1haWwsIGZpbmQgdGhlIHVzZXIgYnkgZW1haWwgZmlyc3QgdG8gZ2V0IHRoZSBhY3R1YWwgVVVJRFxuICAgIGlmIChpc0VtYWlsKSB7XG4gICAgICBjb25zdCB1c2VyQnlFbWFpbCA9IGF3YWl0IFVzZXIuZmluZE9uZSh7IHdoZXJlOiB7IGVtYWlsOiB1c2VySWQgfSB9KTtcbiAgICAgIGlmICghdXNlckJ5RW1haWwpIHtcbiAgICAgICAgY29uc29sZS5sb2coYE5vIHVzZXIgZm91bmQgd2l0aCBlbWFpbDogJHt1c2VySWR9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgYWN0dWFsVXNlcklkID0gdXNlckJ5RW1haWwudXNlcl9pZDtcbiAgICB9XG4gICAgXG4gICAgLy8gVXNlIEVYUExBSU4gQU5BTFlaRSB0byB1bmRlcnN0YW5kIHF1ZXJ5IHBlcmZvcm1hbmNlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCBleHBsYWluUmVzdWx0ID0gYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KGBcbiAgICAgICAgRVhQTEFJTiBBTkFMWVpFXG4gICAgICAgIFNFTEVDVCB1LiosIGMuKlxuICAgICAgICBGUk9NIHVzZXJzIHVcbiAgICAgICAgTEVGVCBKT0lOIChcbiAgICAgICAgICBTRUxFQ1QgKiBGUk9NIGNvbnZlcnNhdGlvbnNcbiAgICAgICAgICBXSEVSRSB1c2VyX2lkID0gJyR7YWN0dWFsVXNlcklkfSdcbiAgICAgICAgICBPUkRFUiBCWSBjcmVhdGVkX2F0IERFU0NcbiAgICAgICAgICBMSU1JVCAxXG4gICAgICAgICkgYyBPTiB1LnVzZXJfaWQgPSBjLnVzZXJfaWRcbiAgICAgICAgV0hFUkUgdS51c2VyX2lkID0gJyR7YWN0dWFsVXNlcklkfSdcbiAgICAgIGApO1xuICAgICAgY29uc29sZS5sb2coJ0pvaW4gcXVlcnkgZXhlY3V0aW9uIHBsYW46JywgZXhwbGFpblJlc3VsdFswXSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4ZWN1dGUgdGhlIGFjdHVhbCBxdWVyeSB1c2luZyBTZXF1ZWxpemVcbiAgICBjb25zb2xlLmxvZyhgREVCVUc6IGdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uIC0gQWJvdXQgdG8gZmV0Y2ggdXNlciB3aXRoIElEOiAke2FjdHVhbFVzZXJJZH1gKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kQnlQayhhY3R1YWxVc2VySWQsIHtcbiAgICAgIC8vIFVzZSByYXc6IGZhbHNlIHRvIGVuc3VyZSB3ZSBnZXQgU2VxdWVsaXplIG1vZGVsIGluc3RhbmNlc1xuICAgICAgcmF3OiBmYWxzZSxcbiAgICAgIGluY2x1ZGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBDb252ZXJzYXRpb24sXG4gICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgb3JkZXI6IFtbJ2NyZWF0ZWRfYXQnLCAnREVTQyddXSxcbiAgICAgICAgICBpbmNsdWRlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGVsOiBDb252ZXJzYXRpb25NZXNzYWdlLFxuICAgICAgICAgICAgICBvcmRlcjogW1snc2VxdWVuY2VfbnVtYmVyJywgJ0RFU0MnXV0sXG4gICAgICAgICAgICAgIGxpbWl0OiA1MCwgLy8gTG9hZCB1cCB0byA1MCBtb3N0IHJlY2VudCBtZXNzYWdlc1xuICAgICAgICAgICAgICBzZXBhcmF0ZTogdHJ1ZSAvLyBUaGlzIGVuc3VyZXMgYWxsIG1lc3NhZ2VzIGFyZSBsb2FkZWQsIG5vdCBqdXN0IG9uZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBVc2VyUHJlZmVyZW5jZSxcbiAgICAgICAgICAvLyBFbnN1cmUgd2UgZ2V0IHRoZSBmdWxsIFVzZXJQcmVmZXJlbmNlIG1vZGVsXG4gICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgaW5jbHVkZTogWydwcmVmZXJlbmNlc19kYXRhJ10gfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG5cbiAgICAvLyBEZWJ1ZyBsb2cgdGhlIHVzZXIgb2JqZWN0IHN0cnVjdHVyZVxuICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IGdldFVzZXJXaXRoTGF0ZXN0Q29udmVyc2F0aW9uIHJlc3VsdDpcIiwgXG4gICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXI/LnVzZXJfaWQgfHwgbnVsbCxcbiAgICAgICAgZW1haWw6IHVzZXI/LmVtYWlsIHx8IG51bGwsXG4gICAgICAgIGhhc1VzZXJQcmVmZXJlbmNlOiB1c2VyID8gISF1c2VyLlVzZXJQcmVmZXJlbmNlIDogbnVsbCxcbiAgICAgICAgdXNlclByZWZlcmVuY2VEYXRhVmFsdWVzOiB1c2VyPy5Vc2VyUHJlZmVyZW5jZSA/ICEhdXNlci5Vc2VyUHJlZmVyZW5jZS5kYXRhVmFsdWVzIDogbnVsbCxcbiAgICAgICAgcHJlZmVyZW5jZXNEYXRhUmF3OiB1c2VyPy5Vc2VyUHJlZmVyZW5jZSA/IHVzZXIuVXNlclByZWZlcmVuY2UucHJlZmVyZW5jZXNfZGF0YSA6IG51bGwsXG4gICAgICAgIHByZWZlcmVuY2VzRGF0YUZyb21EYXRhVmFsdWVzOiB1c2VyPy5Vc2VyUHJlZmVyZW5jZT8uZGF0YVZhbHVlcyA/IHVzZXIuVXNlclByZWZlcmVuY2UuZGF0YVZhbHVlcy5wcmVmZXJlbmNlc19kYXRhIDogbnVsbCxcbiAgICAgICAgcmF3VXNlclByZWZlcmVuY2U6IHVzZXI/LlVzZXJQcmVmZXJlbmNlID8gSlNPTi5zdHJpbmdpZnkodXNlci5Vc2VyUHJlZmVyZW5jZSkuc3Vic3RyaW5nKDAsIDIwMCkgKyBcIi4uLlwiIDogbnVsbFxuICAgICAgfSlcbiAgICApO1xuICAgIFxuICAgIC8vIElmIHVzZXIgZXhpc3RzIGJ1dCBVc2VyUHJlZmVyZW5jZSBkb2Vzbid0LCBjcmVhdGUgYSBkZWZhdWx0IG9uZVxuICAgIGlmICh1c2VyICYmICF1c2VyLlVzZXJQcmVmZXJlbmNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgREVCVUc6IFVzZXIgJHthY3R1YWxVc2VySWR9IGV4aXN0cyBidXQgaGFzIG5vIFVzZXJQcmVmZXJlbmNlIHJlY29yZC4gQ3JlYXRpbmcgZGVmYXVsdC5gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmF1bHQgVXNlclByZWZlcmVuY2UgcmVjb3JkXG4gICAgICAgIGNvbnN0IG5ld1ByZWYgPSBhd2FpdCBVc2VyUHJlZmVyZW5jZS5jcmVhdGUoe1xuICAgICAgICAgIHVzZXJfaWQ6IGFjdHVhbFVzZXJJZCxcbiAgICAgICAgICBwcmVmZXJlbmNlc19kYXRhOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dGFjaCBpdCB0byB0aGUgdXNlciBvYmplY3RcbiAgICAgICAgdXNlci5Vc2VyUHJlZmVyZW5jZSA9IG5ld1ByZWY7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IENyZWF0ZWQgYW5kIGF0dGFjaGVkIGRlZmF1bHQgVXNlclByZWZlcmVuY2UgcmVjb3JkXCIpO1xuICAgICAgfSBjYXRjaCAocHJlZkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBkZWZhdWx0IFVzZXJQcmVmZXJlbmNlOlwiLCBwcmVmRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdXNlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgd2l0aCBsYXRlc3QgY29udmVyc2F0aW9uOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgb3IgdXBkYXRlcyBtZXRhZGF0YSBmb3IgYSBjYWxlbmRhciBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFVzZXIgSURcbiAqIEBwYXJhbSB7c3RyaW5nfSBnb29nbGVFdmVudElkIC0gR29vZ2xlIENhbGVuZGFyIGV2ZW50IElEXG4gKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGEgLSBNZXRhZGF0YSB0byBzdG9yZSAocHJpb3JpdHksIHRhZ3MsIGV0Yy4pXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FsZW5kYXJJZCAtIENhbGVuZGFyIElEIChkZWZhdWx0cyB0byAncHJpbWFyeScpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIENyZWF0ZWQgb3IgdXBkYXRlZCBtZXRhZGF0YSByZWNvcmRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVFdmVudE1ldGFkYXRhKHVzZXJJZCwgZ29vZ2xlRXZlbnRJZCwgbWV0YWRhdGEgPSB7fSwgY2FsZW5kYXJJZCA9ICdwcmltYXJ5Jykge1xuICB0cnkge1xuICAgIGlmICghdXNlcklkIHx8ICFnb29nbGVFdmVudElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgSUQgYW5kIEdvb2dsZSBFdmVudCBJRCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGV4aXN0aW5nIG1ldGFkYXRhIG9yIGNyZWF0ZSBuZXcgcmVjb3JkXG4gICAgY29uc3QgW2V2ZW50TWV0YWRhdGEsIGNyZWF0ZWRdID0gYXdhaXQgQ2FsZW5kYXJFdmVudE1ldGFkYXRhLmZpbmRPckNyZWF0ZSh7XG4gICAgICB3aGVyZToge1xuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgIGdvb2dsZV9jYWxlbmRhcl9pZDogY2FsZW5kYXJJZCxcbiAgICAgICAgZ29vZ2xlX2V2ZW50X2lkOiBnb29nbGVFdmVudElkXG4gICAgICB9LFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBnb29nbGVfY2FsZW5kYXJfaWQ6IGNhbGVuZGFySWQsXG4gICAgICAgIGdvb2dsZV9ldmVudF9pZDogZ29vZ2xlRXZlbnRJZCxcbiAgICAgICAgcHJpb3JpdHk6IG1ldGFkYXRhLnByaW9yaXR5IHx8IG51bGwsXG4gICAgICAgIHRhZ3M6IG1ldGFkYXRhLnRhZ3MgfHwgbnVsbCxcbiAgICAgICAgbGFzdF9zeW5jZWRfYXQ6IG5ldyBEYXRlKClcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIHJlY29yZCBleGlzdHMsIHVwZGF0ZSBpdCB3aXRoIG5ldyBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlZCkge1xuICAgICAgY29uc3QgdXBkYXRlRGF0YSA9IHt9O1xuICAgICAgXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBmaWVsZHMgdGhhdCBhcmUgcHJvdmlkZWRcbiAgICAgIGlmIChtZXRhZGF0YS5wcmlvcml0eSAhPT0gdW5kZWZpbmVkKSB1cGRhdGVEYXRhLnByaW9yaXR5ID0gbWV0YWRhdGEucHJpb3JpdHk7XG4gICAgICBpZiAobWV0YWRhdGEudGFncyAhPT0gdW5kZWZpbmVkKSB1cGRhdGVEYXRhLnRhZ3MgPSBtZXRhZGF0YS50YWdzO1xuICAgICAgXG4gICAgICAvLyBBbHdheXMgdXBkYXRlIGxhc3Rfc3luY2VkX2F0XG4gICAgICB1cGRhdGVEYXRhLmxhc3Rfc3luY2VkX2F0ID0gbmV3IERhdGUoKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXZlbnRNZXRhZGF0YS51cGRhdGUodXBkYXRlRGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50TWV0YWRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcvdXBkYXRpbmcgZXZlbnQgbWV0YWRhdGE6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRGVsZXRlIG1ldGFkYXRhIGZvciBhIGNhbGVuZGFyIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVXNlciBJRFxuICogQHBhcmFtIHtzdHJpbmd9IGdvb2dsZUV2ZW50SWQgLSBHb29nbGUgQ2FsZW5kYXIgZXZlbnQgSURcbiAqIEBwYXJhbSB7c3RyaW5nfSBjYWxlbmRhcklkIC0gQ2FsZW5kYXIgSUQgKGRlZmF1bHRzIHRvICdwcmltYXJ5JylcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFN1Y2Nlc3Mgc3RhdHVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUV2ZW50TWV0YWRhdGEodXNlcklkLCBnb29nbGVFdmVudElkLCBjYWxlbmRhcklkID0gJ3ByaW1hcnknKSB7XG4gIHRyeSB7XG4gICAgaWYgKCF1c2VySWQgfHwgIWdvb2dsZUV2ZW50SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBJRCBhbmQgR29vZ2xlIEV2ZW50IElEIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IENhbGVuZGFyRXZlbnRNZXRhZGF0YS5kZXN0cm95KHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgZ29vZ2xlX2NhbGVuZGFyX2lkOiBjYWxlbmRhcklkLFxuICAgICAgICBnb29nbGVfZXZlbnRfaWQ6IGdvb2dsZUV2ZW50SWRcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQgPiAwO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGV2ZW50IG1ldGFkYXRhOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgbWV0YWRhdGEgZm9yIG11bHRpcGxlIGV2ZW50cyBpbiBhIHNpbmdsZSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFVzZXIgSURcbiAqIEBwYXJhbSB7QXJyYXl9IGdvb2dsZUV2ZW50SWRzIC0gQXJyYXkgb2YgR29vZ2xlIENhbGVuZGFyIGV2ZW50IElEc1xuICogQHBhcmFtIHtzdHJpbmd9IGNhbGVuZGFySWQgLSBDYWxlbmRhciBJRCAoZGVmYXVsdHMgdG8gJ3ByaW1hcnknKVxuICogQHJldHVybnMge0FycmF5fSAtIEFycmF5IG9mIG1ldGFkYXRhIHJlY29yZHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRNZXRhZGF0YUJhdGNoKHVzZXJJZCwgZ29vZ2xlRXZlbnRJZHMsIGNhbGVuZGFySWQgPSAncHJpbWFyeScpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIXVzZXJJZCB8fCAhQXJyYXkuaXNBcnJheShnb29nbGVFdmVudElkcykgfHwgZ29vZ2xlRXZlbnRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBDYWxlbmRhckV2ZW50TWV0YWRhdGEuZmluZEFsbCh7XG4gICAgICB3aGVyZToge1xuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgIGdvb2dsZV9jYWxlbmRhcl9pZDogY2FsZW5kYXJJZCxcbiAgICAgICAgZ29vZ2xlX2V2ZW50X2lkOiB7IFtPcC5pbl06IGdvb2dsZUV2ZW50SWRzIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBldmVudCBtZXRhZGF0YSBiYXRjaDonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vIEV4cG9ydCBtb2RlbHMgYW5kIGZ1bmN0aW9uc1xuZXhwb3J0IHtcbiAgc2VxdWVsaXplLFxuICBVc2VyLFxuICBVc2VyUHJlZmVyZW5jZSxcbiAgQ29udmVyc2F0aW9uLFxuICBDb252ZXJzYXRpb25NZXNzYWdlLFxuICBDYWxlbmRhckV2ZW50TWV0YWRhdGEsXG4gIGluaXRpYWxpemVEYXRhYmFzZSxcbiAgZ2V0T3JDcmVhdGVVc2VyLFxuICBjcmVhdGVDb252ZXJzYXRpb24sXG4gIGdldENvbnZlcnNhdGlvbixcbiAgZ2V0Q29udmVyc2F0aW9uc0J5VXNlcklkLFxuICBnZXRDb252ZXJzYXRpb25NZXNzYWdlcyxcbiAgYWRkTWVzc2FnZVRvQ29udmVyc2F0aW9uLFxuICBnZXRVc2VyV2l0aExhdGVzdENvbnZlcnNhdGlvbixcbiAgY3JlYXRlT3JVcGRhdGVFdmVudE1ldGFkYXRhLFxuICBnZXRFdmVudE1ldGFkYXRhQmF0Y2gsXG4gIGRlbGV0ZUV2ZW50TWV0YWRhdGFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlcXVlbGl6ZTtcbiJdLCJuYW1lcyI6WyJTZXF1ZWxpemUiLCJEYXRhVHlwZXMiLCJPcCIsInNlcXVlbGl6ZSIsImRpYWxlY3QiLCJob3N0IiwicHJvY2VzcyIsImVudiIsIlBPU1RHUkVTX0hPU1QiLCJwb3J0IiwiUE9TVEdSRVNfUE9SVCIsInVzZXJuYW1lIiwiUE9TVEdSRVNfVVNFUiIsInBhc3N3b3JkIiwiUE9TVEdSRVNfUEFTU1dPUkQiLCJkYXRhYmFzZSIsIlBPU1RHUkVTX0RCIiwibG9nZ2luZyIsImNvbnNvbGUiLCJsb2ciLCJkaWFsZWN0T3B0aW9ucyIsInNzbCIsIlBPU1RHUkVTX1NTTCIsInJlcXVpcmUiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJwb29sIiwibWF4IiwibWluIiwiYWNxdWlyZSIsImlkbGUiLCJVc2VyIiwiZGVmaW5lIiwidXNlcl9pZCIsInR5cGUiLCJVVUlEIiwiZGVmYXVsdFZhbHVlIiwibGl0ZXJhbCIsInByaW1hcnlLZXkiLCJlbWFpbCIsIlNUUklORyIsImFsbG93TnVsbCIsInVuaXF1ZSIsIm5hbWUiLCJhdmF0YXJfdXJsIiwiVEVYVCIsImF1dGhfcHJvdmlkZXIiLCJhdXRoX3Byb3ZpZGVyX2lkIiwidGltZXpvbmUiLCJjcmVhdGVkX2F0IiwiREFURSIsInVwZGF0ZWRfYXQiLCJ0YWJsZU5hbWUiLCJ0aW1lc3RhbXBzIiwiaW5kZXhlcyIsImZpZWxkcyIsIlVzZXJQcmVmZXJlbmNlIiwicHJlZmVyZW5jZV9pZCIsInJlZmVyZW5jZXMiLCJtb2RlbCIsImtleSIsIm9uRGVsZXRlIiwicHJlZmVyZW5jZXNfZGF0YSIsIkpTT05CIiwiQ29udmVyc2F0aW9uIiwiY29udmVyc2F0aW9uX2lkIiwic3RhcnRfdGltZSIsInN1bW1hcnkiLCJDb252ZXJzYXRpb25NZXNzYWdlIiwibWVzc2FnZV9pZCIsInNlcXVlbmNlX251bWJlciIsIklOVEVHRVIiLCJyb2xlIiwidmFsaWRhdGUiLCJpc0luIiwiY29udGVudCIsInRvb2xfY2FsbHMiLCJ0b29sX2NhbGxfaWQiLCJDYWxlbmRhckV2ZW50TWV0YWRhdGEiLCJtZXRhZGF0YV9pZCIsImdvb2dsZV9jYWxlbmRhcl9pZCIsImdvb2dsZV9ldmVudF9pZCIsInByaW9yaXR5IiwiZGVhZGxpbmUiLCJ0YXNrX3N0YXR1cyIsImV2ZW50X3N1bW1hcnlfY2FjaGVkIiwic3RhcnRfdGltZV9jYWNoZWQiLCJlbmRfdGltZV9jYWNoZWQiLCJsb2NhdGlvbl9jYWNoZWQiLCJsYXN0X3N5bmNlZF9hdCIsImhhc01hbnkiLCJmb3JlaWduS2V5IiwiYmVsb25nc1RvIiwiaGFzT25lIiwiaW5pdGlhbGl6ZURhdGFiYXNlIiwiYXV0aGVudGljYXRlIiwiZXJyb3IiLCJFcnJvciIsInF1ZXJ5Iiwic3luYyIsImFsdGVyIiwiY2hlY2tDb2x1bW5SZXN1bHQiLCJsZW5ndGgiLCJnZXRPckNyZWF0ZVVzZXIiLCJhdXRoUHJvdmlkZXIiLCJhdXRoUHJvdmlkZXJJZCIsImF2YXRhclVybCIsInVzZXIiLCJmaW5kT25lIiwicmF3Iiwid2hlcmUiLCJpbmNsdWRlIiwicmVxdWlyZWQiLCJhdHRyaWJ1dGVzIiwicmVzdWx0IiwidHJhbnNhY3Rpb24iLCJ0IiwibmV3VXNlciIsImNyZWF0ZSIsIm5ld1ByZWYiLCJmaW5kQnlQayIsInByZWZFcnJvciIsImNyZWF0ZUNvbnZlcnNhdGlvbiIsInVzZXJJZCIsImlzRW1haWwiLCJpbmNsdWRlcyIsImFjdHVhbFVzZXJJZCIsInVzZXJCeUVtYWlsIiwiY29udmVyc2F0aW9uIiwiZ2V0Q29udmVyc2F0aW9uIiwiY29udmVyc2F0aW9uSWQiLCJvcmRlciIsImdldENvbnZlcnNhdGlvbnNCeVVzZXJJZCIsImV4cGxhaW5SZXN1bHQiLCJmaW5kQWxsIiwiZ2V0Q29udmVyc2F0aW9uTWVzc2FnZXMiLCJhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24iLCJtYXhTZXF1ZW5jZVJlc3VsdCIsImZuIiwiY29sIiwibWF4U2VxdWVuY2UiLCJtZXNzYWdlIiwib3JpZ2luYWwiLCJnZXRVc2VyV2l0aExhdGVzdENvbnZlcnNhdGlvbiIsImxpbWl0Iiwic2VwYXJhdGUiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFzVXNlclByZWZlcmVuY2UiLCJ1c2VyUHJlZmVyZW5jZURhdGFWYWx1ZXMiLCJkYXRhVmFsdWVzIiwicHJlZmVyZW5jZXNEYXRhUmF3IiwicHJlZmVyZW5jZXNEYXRhRnJvbURhdGFWYWx1ZXMiLCJyYXdVc2VyUHJlZmVyZW5jZSIsInN1YnN0cmluZyIsImNyZWF0ZU9yVXBkYXRlRXZlbnRNZXRhZGF0YSIsImdvb2dsZUV2ZW50SWQiLCJtZXRhZGF0YSIsImNhbGVuZGFySWQiLCJldmVudE1ldGFkYXRhIiwiY3JlYXRlZCIsImZpbmRPckNyZWF0ZSIsImRlZmF1bHRzIiwidGFncyIsIkRhdGUiLCJ1cGRhdGVEYXRhIiwidW5kZWZpbmVkIiwidXBkYXRlIiwiZGVsZXRlRXZlbnRNZXRhZGF0YSIsImRlc3Ryb3kiLCJnZXRFdmVudE1ldGFkYXRhQmF0Y2giLCJnb29nbGVFdmVudElkcyIsIkFycmF5IiwiaXNBcnJheSIsImluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/postgresClient.js\n");

/***/ }),

/***/ "(api)/./lib/redisClient.js":
/*!****************************!*\
  !*** ./lib/redisClient.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheEventsForDateRange: () => (/* binding */ cacheEventsForDateRange),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   deleteCache: () => (/* binding */ deleteCache),\n/* harmony export */   deleteCacheByPrefix: () => (/* binding */ deleteCacheByPrefix),\n/* harmony export */   deleteConversation: () => (/* binding */ deleteConversation),\n/* harmony export */   flushCache: () => (/* binding */ flushCache),\n/* harmony export */   getCache: () => (/* binding */ getCache),\n/* harmony export */   getCachedEventsForDateRange: () => (/* binding */ getCachedEventsForDateRange),\n/* harmony export */   getConversation: () => (/* binding */ getConversation),\n/* harmony export */   invalidateDateRangeCache: () => (/* binding */ invalidateDateRangeCache),\n/* harmony export */   saveConversation: () => (/* binding */ saveConversation),\n/* harmony export */   setCache: () => (/* binding */ setCache)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"ioredis\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-cache */ \"node-cache\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dotenv/config */ \"dotenv/config\");\n/* harmony import */ var dotenv_config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dotenv_config__WEBPACK_IMPORTED_MODULE_2__);\n// lib/redisClient.js\n\n\n\n// Create Redis client with configuration from environment variables\n// or use default values if not provided\nconst redisClient = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())({\n    host: process.env.REDIS_HOST || \"localhost\",\n    port: process.env.REDIS_PORT || 6379,\n    password: process.env.REDIS_PASSWORD || \"\",\n    db: process.env.REDIS_DB || 0,\n    // Enable reconnect on error\n    retryStrategy: (times)=>{\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n    }\n});\n// Create a very short-lived first-level buffer cache\nconst localCache = new (node_cache__WEBPACK_IMPORTED_MODULE_1___default())({\n    stdTTL: 10\n}); // 10 seconds TTL\n// Log connection events\nredisClient.on(\"connect\", ()=>{\n    console.log(\"Connected to Redis\");\n});\nredisClient.on(\"error\", (err)=>{\n    console.error(\"Redis connection error:\", err);\n});\n// Helper functions for conversation history\nconst CONVERSATION_PREFIX = \"conversation:\";\nconst CACHE_PREFIX = \"cache:\";\nconst DATE_RANGE_PREFIX = \"date_range:\";\nconst USER_PREFIX = \"user:\";\nconst DEFAULT_EXPIRY = 60 * 60 * 24 * 7; // 1 week in seconds\n/**\n * Save conversation history for a user\n * @param {string} userId - The user ID\n * @param {Array} messages - The conversation messages\n * @param {number} expiry - Expiry time in seconds (optional)\n */ async function saveConversation(userId, messages, expiry = DEFAULT_EXPIRY) {\n    try {\n        const key = `${CONVERSATION_PREFIX}${userId}`;\n        await redisClient.set(key, JSON.stringify(messages), \"EX\", expiry);\n    } catch (error) {\n        console.error(\"Error saving conversation to Redis:\", error);\n    }\n}\n/**\n * Get conversation history for a user\n * @param {string} userId - The user ID\n * @returns {Array|null} - The conversation messages or null if not found\n */ async function getConversation(userId) {\n    try {\n        const key = `${CONVERSATION_PREFIX}${userId}`;\n        // Try local cache first\n        const localData = localCache.get(key);\n        if (localData) {\n            return localData;\n        }\n        // Try Redis\n        const data = await redisClient.get(key);\n        if (data) {\n            const parsedData = JSON.parse(data);\n            // Store in local cache\n            localCache.set(key, parsedData);\n            return parsedData;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting conversation from Redis:\", error);\n        return null;\n    }\n}\n/**\n * Delete conversation history for a user\n * @param {string} userId - The user ID\n */ async function deleteConversation(userId) {\n    try {\n        const key = `${CONVERSATION_PREFIX}${userId}`;\n        await redisClient.del(key);\n        localCache.del(key);\n    } catch (error) {\n        console.error(\"Error deleting conversation from Redis:\", error);\n    }\n}\n// Helper functions for caching\n/**\n * Set a value in the cache\n * @param {string} key - The cache key\n * @param {any} value - The value to cache\n * @param {number} expiry - Expiry time in seconds (optional)\n */ async function setCache(key, value, expiry = 300) {\n    try {\n        const cacheKey = `${CACHE_PREFIX}${key}`;\n        await redisClient.set(cacheKey, JSON.stringify(value), \"EX\", expiry);\n        localCache.set(cacheKey, value, 10); // 10 seconds in local cache\n    } catch (error) {\n        console.error(\"Error setting cache in Redis:\", error);\n    }\n}\n/**\n * Get a value from the cache\n * @param {string} key - The cache key\n * @returns {any|null} - The cached value or null if not found\n */ async function getCache(key) {\n    try {\n        const cacheKey = `${CACHE_PREFIX}${key}`;\n        // Try local cache first (fastest)\n        const localData = localCache.get(cacheKey);\n        if (localData) {\n            return localData;\n        }\n        // Try Redis\n        const data = await redisClient.get(cacheKey);\n        if (data) {\n            const parsedData = JSON.parse(data);\n            // Store in local cache\n            localCache.set(cacheKey, parsedData, 10); // 10 seconds\n            return parsedData;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting cache from Redis:\", error);\n        return null;\n    }\n}\n/**\n * Delete a value from the cache\n * @param {string} key - The cache key\n */ async function deleteCache(key) {\n    try {\n        const cacheKey = `${CACHE_PREFIX}${key}`;\n        await redisClient.del(cacheKey);\n        localCache.del(cacheKey);\n    } catch (error) {\n        console.error(\"Error deleting cache from Redis:\", error);\n    }\n}\n/**\n * Delete all cache entries with a specific prefix\n * @param {string} prefix - The prefix to match\n */ async function deleteCacheByPrefix(prefix) {\n    try {\n        const pattern = `${CACHE_PREFIX}${prefix}*`;\n        const keys = await redisClient.keys(pattern);\n        if (keys.length > 0) {\n            await redisClient.del(...keys);\n            // Also clear from local cache\n            keys.forEach((key)=>{\n                localCache.del(key);\n            });\n        }\n    } catch (error) {\n        console.error(\"Error deleting cache by prefix from Redis:\", error);\n    }\n}\n/**\n * Cache calendar events for a specific date range\n * @param {string} userId - The user ID\n * @param {string} startDate - Start date in ISO format\n * @param {string} endDate - End date in ISO format\n * @param {Array} events - Calendar events to cache\n * @param {number} expiry - Expiry time in seconds (optional)\n */ async function cacheEventsForDateRange(userId, startDate, endDate, events, expiry = 300) {\n    try {\n        // Create a key for this specific date range\n        const rangeKey = `${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}${startDate}_${endDate}`;\n        // Store the events\n        await redisClient.set(rangeKey, JSON.stringify(events), \"EX\", expiry);\n        // Add this range to a set of all ranges for this user\n        await redisClient.sadd(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}all_ranges`, rangeKey);\n        // Store in local cache too\n        localCache.set(rangeKey, events, 10); // 10 seconds\n    } catch (error) {\n        console.error(\"Error caching events for date range:\", error);\n    }\n}\n/**\n * Get cached events for a specific date range\n * @param {string} userId - The user ID\n * @param {string} startDate - Start date in ISO format\n * @param {string} endDate - End date in ISO format\n * @returns {Array|null} - Cached events or null if not found\n */ async function getCachedEventsForDateRange(userId, startDate, endDate) {\n    try {\n        const rangeKey = `${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}${startDate}_${endDate}`;\n        // Try local cache first\n        const localData = localCache.get(rangeKey);\n        if (localData) {\n            return localData;\n        }\n        // Try Redis\n        const data = await redisClient.get(rangeKey);\n        if (data) {\n            const parsedData = JSON.parse(data);\n            // Store in local cache\n            localCache.set(rangeKey, parsedData, 10); // 10 seconds\n            return parsedData;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting cached events for date range:\", error);\n        return null;\n    }\n}\n/**\n * Invalidate cached events for a specific date range\n * @param {string} userId - The user ID\n * @param {string} startDate - Start date in ISO format\n * @param {string} endDate - End date in ISO format\n */ async function invalidateDateRangeCache(userId, startDate, endDate) {\n    try {\n        // Get all cached ranges for this user\n        const allRanges = await redisClient.smembers(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}all_ranges`);\n        // Find ranges that overlap with the specified range\n        const rangesToInvalidate = [];\n        for (const rangeKey of allRanges){\n            // Extract dates from the key\n            const match = rangeKey.match(new RegExp(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}(.+)_(.+)$`));\n            if (match) {\n                const [, cachedStart, cachedEnd] = match;\n                // Check if ranges overlap\n                if (startDate <= cachedEnd && endDate >= cachedStart) {\n                    rangesToInvalidate.push(rangeKey);\n                }\n            }\n        }\n        // Delete the overlapping ranges\n        if (rangesToInvalidate.length > 0) {\n            await redisClient.del(...rangesToInvalidate);\n            // Remove from the set of all ranges\n            await redisClient.srem(`${USER_PREFIX}${userId}:${DATE_RANGE_PREFIX}all_ranges`, ...rangesToInvalidate);\n            // Clear from local cache too\n            rangesToInvalidate.forEach((key)=>{\n                localCache.del(key);\n            });\n            console.log(`Invalidated ${rangesToInvalidate.length} overlapping date ranges for user ${userId}`);\n        }\n    } catch (error) {\n        console.error(\"Error invalidating date range cache:\", error);\n    }\n}\n/**\n * Flush all cache entries\n */ async function flushCache() {\n    try {\n        const pattern = `${CACHE_PREFIX}*`;\n        const keys = await redisClient.keys(pattern);\n        if (keys.length > 0) {\n            await redisClient.del(...keys);\n        }\n        // Also clear date range caches\n        const dateRangePattern = `*:${DATE_RANGE_PREFIX}*`;\n        const dateRangeKeys = await redisClient.keys(dateRangePattern);\n        if (dateRangeKeys.length > 0) {\n            await redisClient.del(...dateRangeKeys);\n        }\n        // Clear local cache\n        localCache.flushAll();\n        console.log(\"Cache flushed successfully\");\n    } catch (error) {\n        console.error(\"Error flushing cache from Redis:\", error);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redisClient);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM7SUFDZCxFQUFFLE9BQU9FLE9BQU87UUFDZEgsUUFBUUcsS0FBSyxDQUFDLG9DQUFvQ0E7SUFDcEQ7QUFDRjtBQUVBLGlFQUFldEIsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi9yZWRpc0NsaWVudC5qcz9lZWQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9yZWRpc0NsaWVudC5qc1xuaW1wb3J0IFJlZGlzIGZyb20gJ2lvcmVkaXMnO1xuaW1wb3J0IE5vZGVDYWNoZSBmcm9tICdub2RlLWNhY2hlJztcbmltcG9ydCAnZG90ZW52L2NvbmZpZyc7XG5cbi8vIENyZWF0ZSBSZWRpcyBjbGllbnQgd2l0aCBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4vLyBvciB1c2UgZGVmYXVsdCB2YWx1ZXMgaWYgbm90IHByb3ZpZGVkXG5jb25zdCByZWRpc0NsaWVudCA9IG5ldyBSZWRpcyh7XG4gIGhvc3Q6IHByb2Nlc3MuZW52LlJFRElTX0hPU1QgfHwgJ2xvY2FsaG9zdCcsXG4gIHBvcnQ6IHByb2Nlc3MuZW52LlJFRElTX1BPUlQgfHwgNjM3OSxcbiAgcGFzc3dvcmQ6IHByb2Nlc3MuZW52LlJFRElTX1BBU1NXT1JEIHx8ICcnLFxuICBkYjogcHJvY2Vzcy5lbnYuUkVESVNfREIgfHwgMCxcbiAgLy8gRW5hYmxlIHJlY29ubmVjdCBvbiBlcnJvclxuICByZXRyeVN0cmF0ZWd5OiAodGltZXMpID0+IHtcbiAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKHRpbWVzICogNTAsIDIwMDApO1xuICAgIHJldHVybiBkZWxheTtcbiAgfVxufSk7XG5cbi8vIENyZWF0ZSBhIHZlcnkgc2hvcnQtbGl2ZWQgZmlyc3QtbGV2ZWwgYnVmZmVyIGNhY2hlXG5jb25zdCBsb2NhbENhY2hlID0gbmV3IE5vZGVDYWNoZSh7IHN0ZFRUTDogMTAgfSk7IC8vIDEwIHNlY29uZHMgVFRMXG5cbi8vIExvZyBjb25uZWN0aW9uIGV2ZW50c1xucmVkaXNDbGllbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gUmVkaXMnKTtcbn0pO1xuXG5yZWRpc0NsaWVudC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoJ1JlZGlzIGNvbm5lY3Rpb24gZXJyb3I6JywgZXJyKTtcbn0pO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBjb252ZXJzYXRpb24gaGlzdG9yeVxuY29uc3QgQ09OVkVSU0FUSU9OX1BSRUZJWCA9ICdjb252ZXJzYXRpb246JztcbmNvbnN0IENBQ0hFX1BSRUZJWCA9ICdjYWNoZTonO1xuY29uc3QgREFURV9SQU5HRV9QUkVGSVggPSAnZGF0ZV9yYW5nZTonO1xuY29uc3QgVVNFUl9QUkVGSVggPSAndXNlcjonO1xuY29uc3QgREVGQVVMVF9FWFBJUlkgPSA2MCAqIDYwICogMjQgKiA3OyAvLyAxIHdlZWsgaW4gc2Vjb25kc1xuXG4vKipcbiAqIFNhdmUgY29udmVyc2F0aW9uIGhpc3RvcnkgZm9yIGEgdXNlclxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyIElEXG4gKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlcyAtIFRoZSBjb252ZXJzYXRpb24gbWVzc2FnZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcnkgLSBFeHBpcnkgdGltZSBpbiBzZWNvbmRzIChvcHRpb25hbClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVDb252ZXJzYXRpb24odXNlcklkLCBtZXNzYWdlcywgZXhwaXJ5ID0gREVGQVVMVF9FWFBJUlkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBrZXkgPSBgJHtDT05WRVJTQVRJT05fUFJFRklYfSR7dXNlcklkfWA7XG4gICAgYXdhaXQgcmVkaXNDbGllbnQuc2V0KGtleSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMpLCAnRVgnLCBleHBpcnkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBjb252ZXJzYXRpb24gdG8gUmVkaXM6JywgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNvbnZlcnNhdGlvbiBoaXN0b3J5IGZvciBhIHVzZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBUaGUgdXNlciBJRFxuICogQHJldHVybnMge0FycmF5fG51bGx9IC0gVGhlIGNvbnZlcnNhdGlvbiBtZXNzYWdlcyBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uKHVzZXJJZCkge1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGAke0NPTlZFUlNBVElPTl9QUkVGSVh9JHt1c2VySWR9YDtcbiAgICBcbiAgICAvLyBUcnkgbG9jYWwgY2FjaGUgZmlyc3RcbiAgICBjb25zdCBsb2NhbERhdGEgPSBsb2NhbENhY2hlLmdldChrZXkpO1xuICAgIGlmIChsb2NhbERhdGEpIHtcbiAgICAgIHJldHVybiBsb2NhbERhdGE7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSBSZWRpc1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZWRpc0NsaWVudC5nZXQoa2V5KTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAvLyBTdG9yZSBpbiBsb2NhbCBjYWNoZVxuICAgICAgbG9jYWxDYWNoZS5zZXQoa2V5LCBwYXJzZWREYXRhKTtcbiAgICAgIHJldHVybiBwYXJzZWREYXRhO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNvbnZlcnNhdGlvbiBmcm9tIFJlZGlzOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBjb252ZXJzYXRpb24gaGlzdG9yeSBmb3IgYSB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVGhlIHVzZXIgSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbnZlcnNhdGlvbih1c2VySWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBrZXkgPSBgJHtDT05WRVJTQVRJT05fUFJFRklYfSR7dXNlcklkfWA7XG4gICAgYXdhaXQgcmVkaXNDbGllbnQuZGVsKGtleSk7XG4gICAgbG9jYWxDYWNoZS5kZWwoa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBjb252ZXJzYXRpb24gZnJvbSBSZWRpczonLCBlcnJvcik7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgY2FjaGluZ1xuLyoqXG4gKiBTZXQgYSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgY2FjaGUga2V5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2FjaGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcnkgLSBFeHBpcnkgdGltZSBpbiBzZWNvbmRzIChvcHRpb25hbClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldENhY2hlKGtleSwgdmFsdWUsIGV4cGlyeSA9IDMwMCkgeyAvLyBEZWZhdWx0IDUgbWludXRlc1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7Q0FDSEVfUFJFRklYfSR7a2V5fWA7XG4gICAgYXdhaXQgcmVkaXNDbGllbnQuc2V0KGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksICdFWCcsIGV4cGlyeSk7XG4gICAgbG9jYWxDYWNoZS5zZXQoY2FjaGVLZXksIHZhbHVlLCAxMCk7IC8vIDEwIHNlY29uZHMgaW4gbG9jYWwgY2FjaGVcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZXR0aW5nIGNhY2hlIGluIFJlZGlzOicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZyb20gdGhlIGNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGNhY2hlIGtleVxuICogQHJldHVybnMge2FueXxudWxsfSAtIFRoZSBjYWNoZWQgdmFsdWUgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlKGtleSkge1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7Q0FDSEVfUFJFRklYfSR7a2V5fWA7XG4gICAgXG4gICAgLy8gVHJ5IGxvY2FsIGNhY2hlIGZpcnN0IChmYXN0ZXN0KVxuICAgIGNvbnN0IGxvY2FsRGF0YSA9IGxvY2FsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAobG9jYWxEYXRhKSB7XG4gICAgICByZXR1cm4gbG9jYWxEYXRhO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgUmVkaXNcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVkaXNDbGllbnQuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAvLyBTdG9yZSBpbiBsb2NhbCBjYWNoZVxuICAgICAgbG9jYWxDYWNoZS5zZXQoY2FjaGVLZXksIHBhcnNlZERhdGEsIDEwKTsgLy8gMTAgc2Vjb25kc1xuICAgICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2FjaGUgZnJvbSBSZWRpczonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSB2YWx1ZSBmcm9tIHRoZSBjYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBjYWNoZSBrZXlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNhY2hlKGtleSkge1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7Q0FDSEVfUFJFRklYfSR7a2V5fWA7XG4gICAgYXdhaXQgcmVkaXNDbGllbnQuZGVsKGNhY2hlS2V5KTtcbiAgICBsb2NhbENhY2hlLmRlbChjYWNoZUtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgY2FjaGUgZnJvbSBSZWRpczonLCBlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYWxsIGNhY2hlIGVudHJpZXMgd2l0aCBhIHNwZWNpZmljIHByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCAtIFRoZSBwcmVmaXggdG8gbWF0Y2hcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNhY2hlQnlQcmVmaXgocHJlZml4KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF0dGVybiA9IGAke0NBQ0hFX1BSRUZJWH0ke3ByZWZpeH0qYDtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgcmVkaXNDbGllbnQua2V5cyhwYXR0ZXJuKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCByZWRpc0NsaWVudC5kZWwoLi4ua2V5cyk7XG4gICAgICBcbiAgICAgIC8vIEFsc28gY2xlYXIgZnJvbSBsb2NhbCBjYWNoZVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGxvY2FsQ2FjaGUuZGVsKGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgY2FjaGUgYnkgcHJlZml4IGZyb20gUmVkaXM6JywgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogQ2FjaGUgY2FsZW5kYXIgZXZlbnRzIGZvciBhIHNwZWNpZmljIGRhdGUgcmFuZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBUaGUgdXNlciBJRFxuICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0RGF0ZSAtIFN0YXJ0IGRhdGUgaW4gSVNPIGZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmd9IGVuZERhdGUgLSBFbmQgZGF0ZSBpbiBJU08gZm9ybWF0XG4gKiBAcGFyYW0ge0FycmF5fSBldmVudHMgLSBDYWxlbmRhciBldmVudHMgdG8gY2FjaGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcnkgLSBFeHBpcnkgdGltZSBpbiBzZWNvbmRzIChvcHRpb25hbClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhY2hlRXZlbnRzRm9yRGF0ZVJhbmdlKHVzZXJJZCwgc3RhcnREYXRlLCBlbmREYXRlLCBldmVudHMsIGV4cGlyeSA9IDMwMCkge1xuICB0cnkge1xuICAgIC8vIENyZWF0ZSBhIGtleSBmb3IgdGhpcyBzcGVjaWZpYyBkYXRlIHJhbmdlXG4gICAgY29uc3QgcmFuZ2VLZXkgPSBgJHtVU0VSX1BSRUZJWH0ke3VzZXJJZH06JHtEQVRFX1JBTkdFX1BSRUZJWH0ke3N0YXJ0RGF0ZX1fJHtlbmREYXRlfWA7XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIGV2ZW50c1xuICAgIGF3YWl0IHJlZGlzQ2xpZW50LnNldChyYW5nZUtleSwgSlNPTi5zdHJpbmdpZnkoZXZlbnRzKSwgJ0VYJywgZXhwaXJ5KTtcbiAgICBcbiAgICAvLyBBZGQgdGhpcyByYW5nZSB0byBhIHNldCBvZiBhbGwgcmFuZ2VzIGZvciB0aGlzIHVzZXJcbiAgICBhd2FpdCByZWRpc0NsaWVudC5zYWRkKGAke1VTRVJfUFJFRklYfSR7dXNlcklkfToke0RBVEVfUkFOR0VfUFJFRklYfWFsbF9yYW5nZXNgLCByYW5nZUtleSk7XG4gICAgXG4gICAgLy8gU3RvcmUgaW4gbG9jYWwgY2FjaGUgdG9vXG4gICAgbG9jYWxDYWNoZS5zZXQocmFuZ2VLZXksIGV2ZW50cywgMTApOyAvLyAxMCBzZWNvbmRzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FjaGluZyBldmVudHMgZm9yIGRhdGUgcmFuZ2U6JywgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNhY2hlZCBldmVudHMgZm9yIGEgc3BlY2lmaWMgZGF0ZSByYW5nZVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyIElEXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnREYXRlIC0gU3RhcnQgZGF0ZSBpbiBJU08gZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kRGF0ZSAtIEVuZCBkYXRlIGluIElTTyBmb3JtYXRcbiAqIEByZXR1cm5zIHtBcnJheXxudWxsfSAtIENhY2hlZCBldmVudHMgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWQsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHJhbmdlS2V5ID0gYCR7VVNFUl9QUkVGSVh9JHt1c2VySWR9OiR7REFURV9SQU5HRV9QUkVGSVh9JHtzdGFydERhdGV9XyR7ZW5kRGF0ZX1gO1xuICAgIFxuICAgIC8vIFRyeSBsb2NhbCBjYWNoZSBmaXJzdFxuICAgIGNvbnN0IGxvY2FsRGF0YSA9IGxvY2FsQ2FjaGUuZ2V0KHJhbmdlS2V5KTtcbiAgICBpZiAobG9jYWxEYXRhKSB7XG4gICAgICByZXR1cm4gbG9jYWxEYXRhO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgUmVkaXNcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVkaXNDbGllbnQuZ2V0KHJhbmdlS2V5KTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAvLyBTdG9yZSBpbiBsb2NhbCBjYWNoZVxuICAgICAgbG9jYWxDYWNoZS5zZXQocmFuZ2VLZXksIHBhcnNlZERhdGEsIDEwKTsgLy8gMTAgc2Vjb25kc1xuICAgICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY2FjaGVkIGV2ZW50cyBmb3IgZGF0ZSByYW5nZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZhbGlkYXRlIGNhY2hlZCBldmVudHMgZm9yIGEgc3BlY2lmaWMgZGF0ZSByYW5nZVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyIElEXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnREYXRlIC0gU3RhcnQgZGF0ZSBpbiBJU08gZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kRGF0ZSAtIEVuZCBkYXRlIGluIElTTyBmb3JtYXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGludmFsaWRhdGVEYXRlUmFuZ2VDYWNoZSh1c2VySWQsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICB0cnkge1xuICAgIC8vIEdldCBhbGwgY2FjaGVkIHJhbmdlcyBmb3IgdGhpcyB1c2VyXG4gICAgY29uc3QgYWxsUmFuZ2VzID0gYXdhaXQgcmVkaXNDbGllbnQuc21lbWJlcnMoYCR7VVNFUl9QUkVGSVh9JHt1c2VySWR9OiR7REFURV9SQU5HRV9QUkVGSVh9YWxsX3Jhbmdlc2ApO1xuICAgIFxuICAgIC8vIEZpbmQgcmFuZ2VzIHRoYXQgb3ZlcmxhcCB3aXRoIHRoZSBzcGVjaWZpZWQgcmFuZ2VcbiAgICBjb25zdCByYW5nZXNUb0ludmFsaWRhdGUgPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHJhbmdlS2V5IG9mIGFsbFJhbmdlcykge1xuICAgICAgLy8gRXh0cmFjdCBkYXRlcyBmcm9tIHRoZSBrZXlcbiAgICAgIGNvbnN0IG1hdGNoID0gcmFuZ2VLZXkubWF0Y2gobmV3IFJlZ0V4cChgJHtVU0VSX1BSRUZJWH0ke3VzZXJJZH06JHtEQVRFX1JBTkdFX1BSRUZJWH0oLispXyguKykkYCkpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IFssIGNhY2hlZFN0YXJ0LCBjYWNoZWRFbmRdID0gbWF0Y2g7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiByYW5nZXMgb3ZlcmxhcFxuICAgICAgICBpZiAoKHN0YXJ0RGF0ZSA8PSBjYWNoZWRFbmQpICYmIChlbmREYXRlID49IGNhY2hlZFN0YXJ0KSkge1xuICAgICAgICAgIHJhbmdlc1RvSW52YWxpZGF0ZS5wdXNoKHJhbmdlS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIG92ZXJsYXBwaW5nIHJhbmdlc1xuICAgIGlmIChyYW5nZXNUb0ludmFsaWRhdGUubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgcmVkaXNDbGllbnQuZGVsKC4uLnJhbmdlc1RvSW52YWxpZGF0ZSk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBzZXQgb2YgYWxsIHJhbmdlc1xuICAgICAgYXdhaXQgcmVkaXNDbGllbnQuc3JlbShgJHtVU0VSX1BSRUZJWH0ke3VzZXJJZH06JHtEQVRFX1JBTkdFX1BSRUZJWH1hbGxfcmFuZ2VzYCwgLi4ucmFuZ2VzVG9JbnZhbGlkYXRlKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgZnJvbSBsb2NhbCBjYWNoZSB0b29cbiAgICAgIHJhbmdlc1RvSW52YWxpZGF0ZS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGxvY2FsQ2FjaGUuZGVsKGtleSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYEludmFsaWRhdGVkICR7cmFuZ2VzVG9JbnZhbGlkYXRlLmxlbmd0aH0gb3ZlcmxhcHBpbmcgZGF0ZSByYW5nZXMgZm9yIHVzZXIgJHt1c2VySWR9YCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGludmFsaWRhdGluZyBkYXRlIHJhbmdlIGNhY2hlOicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGFsbCBjYWNoZSBlbnRyaWVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmbHVzaENhY2hlKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBgJHtDQUNIRV9QUkVGSVh9KmA7XG4gICAgY29uc3Qga2V5cyA9IGF3YWl0IHJlZGlzQ2xpZW50LmtleXMocGF0dGVybik7XG4gICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgcmVkaXNDbGllbnQuZGVsKC4uLmtleXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHNvIGNsZWFyIGRhdGUgcmFuZ2UgY2FjaGVzXG4gICAgY29uc3QgZGF0ZVJhbmdlUGF0dGVybiA9IGAqOiR7REFURV9SQU5HRV9QUkVGSVh9KmA7XG4gICAgY29uc3QgZGF0ZVJhbmdlS2V5cyA9IGF3YWl0IHJlZGlzQ2xpZW50LmtleXMoZGF0ZVJhbmdlUGF0dGVybik7XG4gICAgaWYgKGRhdGVSYW5nZUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgcmVkaXNDbGllbnQuZGVsKC4uLmRhdGVSYW5nZUtleXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciBsb2NhbCBjYWNoZVxuICAgIGxvY2FsQ2FjaGUuZmx1c2hBbGwoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQ2FjaGUgZmx1c2hlZCBzdWNjZXNzZnVsbHknKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmbHVzaGluZyBjYWNoZSBmcm9tIFJlZGlzOicsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCByZWRpc0NsaWVudDsiXSwibmFtZXMiOlsiUmVkaXMiLCJOb2RlQ2FjaGUiLCJyZWRpc0NsaWVudCIsImhvc3QiLCJwcm9jZXNzIiwiZW52IiwiUkVESVNfSE9TVCIsInBvcnQiLCJSRURJU19QT1JUIiwicGFzc3dvcmQiLCJSRURJU19QQVNTV09SRCIsImRiIiwiUkVESVNfREIiLCJyZXRyeVN0cmF0ZWd5IiwidGltZXMiLCJkZWxheSIsIk1hdGgiLCJtaW4iLCJsb2NhbENhY2hlIiwic3RkVFRMIiwib24iLCJjb25zb2xlIiwibG9nIiwiZXJyIiwiZXJyb3IiLCJDT05WRVJTQVRJT05fUFJFRklYIiwiQ0FDSEVfUFJFRklYIiwiREFURV9SQU5HRV9QUkVGSVgiLCJVU0VSX1BSRUZJWCIsIkRFRkFVTFRfRVhQSVJZIiwic2F2ZUNvbnZlcnNhdGlvbiIsInVzZXJJZCIsIm1lc3NhZ2VzIiwiZXhwaXJ5Iiwia2V5Iiwic2V0IiwiSlNPTiIsInN0cmluZ2lmeSIsImdldENvbnZlcnNhdGlvbiIsImxvY2FsRGF0YSIsImdldCIsImRhdGEiLCJwYXJzZWREYXRhIiwicGFyc2UiLCJkZWxldGVDb252ZXJzYXRpb24iLCJkZWwiLCJzZXRDYWNoZSIsInZhbHVlIiwiY2FjaGVLZXkiLCJnZXRDYWNoZSIsImRlbGV0ZUNhY2hlIiwiZGVsZXRlQ2FjaGVCeVByZWZpeCIsInByZWZpeCIsInBhdHRlcm4iLCJrZXlzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImNhY2hlRXZlbnRzRm9yRGF0ZVJhbmdlIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImV2ZW50cyIsInJhbmdlS2V5Iiwic2FkZCIsImdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSIsImludmFsaWRhdGVEYXRlUmFuZ2VDYWNoZSIsImFsbFJhbmdlcyIsInNtZW1iZXJzIiwicmFuZ2VzVG9JbnZhbGlkYXRlIiwibWF0Y2giLCJSZWdFeHAiLCJjYWNoZWRTdGFydCIsImNhY2hlZEVuZCIsInB1c2giLCJzcmVtIiwiZmx1c2hDYWNoZSIsImRhdGVSYW5nZVBhdHRlcm4iLCJkYXRlUmFuZ2VLZXlzIiwiZmx1c2hBbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/redisClient.js\n");

/***/ }),

/***/ "(api)/./lib/services/cacheService.js":
/*!**************************************!*\
  !*** ./lib/services/cacheService.js ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCachedEvents: () => (/* binding */ getCachedEvents),\n/* harmony export */   invalidateCache: () => (/* binding */ invalidateCache)\n/* harmony export */ });\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-cache */ \"node-cache\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var _tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/timeUtils.js */ \"(api)/./lib/tools/timeUtils.js\");\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../googleCalendar.js */ \"(api)/./googleCalendar.js\");\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_googleCalendar_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _redisClient_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../redisClient.js */ \"(api)/./lib/redisClient.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_1__, _tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__]);\n([luxon__WEBPACK_IMPORTED_MODULE_1__, _tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// ES Module imports\n\n\n\n// Import the calendar function with correct name\n\n// Import Redis functions\n\n// Consider calling initializeDatabase() at application startup\n// --- Cache ---\nconst memoryCache = new (node_cache__WEBPACK_IMPORTED_MODULE_0___default())({\n    stdTTL: 300\n}); // 5 minutes TTL\n// --- Caching Logic ---\n// (Keep getCachedEvents and invalidateCache as previously defined and refined)\nasync function getCachedEvents(tokens, start_date, end_date) {\n    if (!tokens?.access_token) {\n        console.warn(\"Attempting to get events without access token. Required for calendar operations.\");\n        throw new Error(\"User authentication required to fetch calendar events.\");\n    }\n    // Ensure start_date and end_date have proper timezone information\n    const userTimezone = (0,_tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.getUserTimezone)();\n    const startWithTz = typeof start_date === \"string\" ? (0,_tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertToUTCISOString)(start_date, userTimezone) || start_date : start_date;\n    const endWithTz = typeof end_date === \"string\" ? (0,_tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertToUTCISOString)(end_date, userTimezone) || end_date : end_date;\n    // Derive a user-specific cache key prefix (more stable than token hash if possible)\n    // For now, using token hash as fallback\n    const tokenHash = tokens.access_token.substring(tokens.access_token.length - 10);\n    const userIdCachePrefix = `user_${tokenHash}`; // Replace with stable user ID if available\n    // Parse dates and preserve timezone information\n    const startDt = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(startWithTz);\n    const endDt = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(endWithTz);\n    // Log the original and parsed dates for debugging\n    console.log(`getCachedEvents original range: ${start_date} to ${end_date} (converted to: ${startWithTz} to ${endWithTz})`);\n    console.log(`getCachedEvents parsed range: ${startDt.toISO()} to ${endDt.toISO()}`);\n    // Use full ISO strings for cache keys to preserve timezone information\n    // This is especially important for events after 7 PM Zulu time\n    const cacheKeyStart = startDt.toISO();\n    const cacheKeyEnd = endDt.toISO();\n    if (!cacheKeyStart || !cacheKeyEnd) {\n        throw new Error(`Invalid date format for caching: ${start_date}, ${end_date}`);\n    }\n    try {\n        const cachedEvents = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_4__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n        if (cachedEvents) {\n            console.log(`Cache HIT for events from ${cacheKeyStart} to ${cacheKeyEnd}`);\n            // Ensure it returns an array even if cache stores null/undefined mistakenly\n            return Array.isArray(cachedEvents) ? cachedEvents : [];\n        }\n        console.log(`Cache MISS for events from ${cacheKeyStart} to ${cacheKeyEnd}`);\n        // Fetch from API using the actual Calendar function\n        // Pass the exact ISO strings to preserve timezone information\n        const events = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_3__.getCalendarEvents)(tokens, new Date(startWithTz), new Date(endWithTz));\n        if (events && Array.isArray(events)) {\n            await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_4__.cacheEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd, events, 300); // 5 min TTL\n            console.log(`Stored ${events.length} events in Redis cache for range ${cacheKeyStart} to ${cacheKeyEnd}`);\n            return events;\n        } else {\n            console.warn(`No events returned or non-array from fetchGCalendarEvents for ${cacheKeyStart}-${cacheKeyEnd}`);\n            return []; // Return empty array on failure or non-array result\n        }\n    } catch (error) {\n        console.error(`Error in getCachedEvents (${cacheKeyStart} to ${cacheKeyEnd}):`, error);\n        throw new Error(`Failed to fetch or cache calendar events: ${error.message}`);\n    }\n}\nasync function invalidateCache(tokens = null, startDate = null, endDate = null) {\n    memoryCache.flushAll(); // Always flush memory cache\n    console.log(\"Memory cache invalidated\");\n    // If we have a specific date range to invalidate\n    if (tokens?.access_token && startDate && endDate) {\n        try {\n            // Ensure startDate and endDate have proper timezone information\n            const userTimezone = (0,_tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.getUserTimezone)();\n            const startWithTz = typeof startDate === \"string\" ? (0,_tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertToUTCISOString)(startDate, userTimezone) || startDate : startDate;\n            const endWithTz = typeof endDate === \"string\" ? (0,_tools_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertToUTCISOString)(endDate, userTimezone) || endDate : endDate;\n            const tokenHash = tokens.access_token.substring(tokens.access_token.length - 10);\n            const userIdCachePrefix = `user_${tokenHash}`; // Use consistent prefix\n            // Parse dates and preserve timezone information\n            const startDt = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(startWithTz);\n            const endDt = luxon__WEBPACK_IMPORTED_MODULE_1__.DateTime.fromISO(endWithTz);\n            // Log the original and parsed dates for debugging\n            console.log(`invalidateCache original range: ${startDate} to ${endDate} (converted to: ${startWithTz} to ${endWithTz})`);\n            console.log(`invalidateCache parsed range: ${startDt.toISO()} to ${endDt.toISO()}`);\n            // Use full ISO strings for cache keys to preserve timezone information\n            const startKey = startDt.toISO();\n            const endKey = endDt.toISO();\n            if (!startKey || !endKey) {\n                console.warn(`Cannot invalidate Redis: Invalid date format ${startDate}, ${endDate}`);\n                return;\n            }\n            await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_4__.invalidateDateRangeCache)(userIdCachePrefix, startKey, endKey);\n            console.log(`Invalidated Redis cache for user ${userIdCachePrefix}, exact range ${startKey} to ${endKey}`);\n        } catch (error) {\n            console.error(\"Error invalidating Redis date range cache:\", error);\n        }\n    } else {\n        console.log(\"Skipping granular Redis cache invalidation (missing token or date range)\");\n    }\n}\n// Export the functions\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q047WUFFL0Isa0RBQWtEO1lBQ2xETCxRQUFRYSxHQUFHLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRVksVUFBVSxJQUFJLEVBQUVDLFFBQVEsZ0JBQWdCLEVBQUV0QixZQUFZLElBQUksRUFBRUMsVUFBVSxDQUFDLENBQUM7WUFDdkhMLFFBQVFhLEdBQUcsQ0FBQyxDQUFDLDhCQUE4QixFQUFFSCxRQUFRSSxLQUFLLEdBQUcsSUFBSSxFQUFFRixNQUFNRSxLQUFLLEdBQUcsQ0FBQztZQUVsRix1RUFBdUU7WUFDdkUsTUFBTWMsV0FBV2xCLFFBQVFJLEtBQUs7WUFDOUIsTUFBTWUsU0FBU2pCLE1BQU1FLEtBQUs7WUFFMUIsSUFBSSxDQUFDYyxZQUFZLENBQUNDLFFBQVE7Z0JBQ3JCN0IsUUFBUUMsSUFBSSxDQUFDLENBQUMsNkNBQTZDLEVBQUV3QixVQUFVLEVBQUUsRUFBRUMsUUFBUSxDQUFDO2dCQUNwRjtZQUNKO1lBQ0QsTUFBTWxDLHlFQUF3QkEsQ0FBQ2lCLG1CQUFtQm1CLFVBQVVDO1lBQzVEN0IsUUFBUWEsR0FBRyxDQUFDLENBQUMsaUNBQWlDLEVBQUVKLGtCQUFrQixjQUFjLEVBQUVtQixTQUFTLElBQUksRUFBRUMsT0FBTyxDQUFDO1FBQzdHLEVBQUUsT0FBT1AsT0FBTztZQUNadEIsUUFBUXNCLEtBQUssQ0FBQyw4Q0FBOENBO1FBQ2hFO0lBQ0osT0FBTztRQUNIdEIsUUFBUWEsR0FBRyxDQUFDO0lBQ2hCO0FBQ0o7QUFFQSx1QkFBdUI7QUFDcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nY2FsZW5kYXJhcHAvLi9saWIvc2VydmljZXMvY2FjaGVTZXJ2aWNlLmpzPzgxNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRVMgTW9kdWxlIGltcG9ydHNcbmltcG9ydCBOb2RlQ2FjaGUgZnJvbSAnbm9kZS1jYWNoZSc7XG5pbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2x1eG9uJztcbmltcG9ydCB7IGdldFVzZXJUaW1lem9uZSwgY29udmVydFRvVVRDSVNPU3RyaW5nIH0gZnJvbSAnLi4vdG9vbHMvdGltZVV0aWxzLmpzJztcbi8vIEltcG9ydCB0aGUgY2FsZW5kYXIgZnVuY3Rpb24gd2l0aCBjb3JyZWN0IG5hbWVcbmltcG9ydCB7IGdldENhbGVuZGFyRXZlbnRzIH0gZnJvbSAnLi4vLi4vZ29vZ2xlQ2FsZW5kYXIuanMnO1xuLy8gSW1wb3J0IFJlZGlzIGZ1bmN0aW9uc1xuaW1wb3J0IHsgZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlLCBjYWNoZUV2ZW50c0ZvckRhdGVSYW5nZSwgaW52YWxpZGF0ZURhdGVSYW5nZUNhY2hlIH0gZnJvbSAnLi4vcmVkaXNDbGllbnQuanMnO1xuXG4vLyBDb25zaWRlciBjYWxsaW5nIGluaXRpYWxpemVEYXRhYmFzZSgpIGF0IGFwcGxpY2F0aW9uIHN0YXJ0dXBcblxuLy8gLS0tIENhY2hlIC0tLVxuY29uc3QgbWVtb3J5Q2FjaGUgPSBuZXcgTm9kZUNhY2hlKHsgc3RkVFRMOiAzMDAgfSk7IC8vIDUgbWludXRlcyBUVExcblxuLy8gLS0tIENhY2hpbmcgTG9naWMgLS0tXG4vLyAoS2VlcCBnZXRDYWNoZWRFdmVudHMgYW5kIGludmFsaWRhdGVDYWNoZSBhcyBwcmV2aW91c2x5IGRlZmluZWQgYW5kIHJlZmluZWQpXG5hc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRFdmVudHModG9rZW5zLCBzdGFydF9kYXRlLCBlbmRfZGF0ZSkge1xuICBpZiAoIXRva2Vucz8uYWNjZXNzX3Rva2VuKSB7XG4gICAgIGNvbnNvbGUud2FybihcIkF0dGVtcHRpbmcgdG8gZ2V0IGV2ZW50cyB3aXRob3V0IGFjY2VzcyB0b2tlbi4gUmVxdWlyZWQgZm9yIGNhbGVuZGFyIG9wZXJhdGlvbnMuXCIpO1xuICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkIHRvIGZldGNoIGNhbGVuZGFyIGV2ZW50cy5cIik7XG4gIH1cbiAgXG4gIC8vIEVuc3VyZSBzdGFydF9kYXRlIGFuZCBlbmRfZGF0ZSBoYXZlIHByb3BlciB0aW1lem9uZSBpbmZvcm1hdGlvblxuICBjb25zdCB1c2VyVGltZXpvbmUgPSBnZXRVc2VyVGltZXpvbmUoKTtcbiAgY29uc3Qgc3RhcnRXaXRoVHogPSB0eXBlb2Ygc3RhcnRfZGF0ZSA9PT0gJ3N0cmluZycgPyBjb252ZXJ0VG9VVENJU09TdHJpbmcoc3RhcnRfZGF0ZSwgdXNlclRpbWV6b25lKSB8fCBzdGFydF9kYXRlIDogc3RhcnRfZGF0ZTtcbiAgY29uc3QgZW5kV2l0aFR6ID0gdHlwZW9mIGVuZF9kYXRlID09PSAnc3RyaW5nJyA/IGNvbnZlcnRUb1VUQ0lTT1N0cmluZyhlbmRfZGF0ZSwgdXNlclRpbWV6b25lKSB8fCBlbmRfZGF0ZSA6IGVuZF9kYXRlO1xuICBcbiAgLy8gRGVyaXZlIGEgdXNlci1zcGVjaWZpYyBjYWNoZSBrZXkgcHJlZml4IChtb3JlIHN0YWJsZSB0aGFuIHRva2VuIGhhc2ggaWYgcG9zc2libGUpXG4gIC8vIEZvciBub3csIHVzaW5nIHRva2VuIGhhc2ggYXMgZmFsbGJhY2tcbiAgY29uc3QgdG9rZW5IYXNoID0gdG9rZW5zLmFjY2Vzc190b2tlbi5zdWJzdHJpbmcodG9rZW5zLmFjY2Vzc190b2tlbi5sZW5ndGggLSAxMCk7XG4gIGNvbnN0IHVzZXJJZENhY2hlUHJlZml4ID0gYHVzZXJfJHt0b2tlbkhhc2h9YDsgLy8gUmVwbGFjZSB3aXRoIHN0YWJsZSB1c2VyIElEIGlmIGF2YWlsYWJsZVxuXG4gIC8vIFBhcnNlIGRhdGVzIGFuZCBwcmVzZXJ2ZSB0aW1lem9uZSBpbmZvcm1hdGlvblxuICBjb25zdCBzdGFydER0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzdGFydFdpdGhUeik7XG4gIGNvbnN0IGVuZER0ID0gRGF0ZVRpbWUuZnJvbUlTTyhlbmRXaXRoVHopO1xuICBcbiAgLy8gTG9nIHRoZSBvcmlnaW5hbCBhbmQgcGFyc2VkIGRhdGVzIGZvciBkZWJ1Z2dpbmdcbiAgY29uc29sZS5sb2coYGdldENhY2hlZEV2ZW50cyBvcmlnaW5hbCByYW5nZTogJHtzdGFydF9kYXRlfSB0byAke2VuZF9kYXRlfSAoY29udmVydGVkIHRvOiAke3N0YXJ0V2l0aFR6fSB0byAke2VuZFdpdGhUen0pYCk7XG4gIGNvbnNvbGUubG9nKGBnZXRDYWNoZWRFdmVudHMgcGFyc2VkIHJhbmdlOiAke3N0YXJ0RHQudG9JU08oKX0gdG8gJHtlbmREdC50b0lTTygpfWApO1xuICBcbiAgLy8gVXNlIGZ1bGwgSVNPIHN0cmluZ3MgZm9yIGNhY2hlIGtleXMgdG8gcHJlc2VydmUgdGltZXpvbmUgaW5mb3JtYXRpb25cbiAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCBmb3IgZXZlbnRzIGFmdGVyIDcgUE0gWnVsdSB0aW1lXG4gIGNvbnN0IGNhY2hlS2V5U3RhcnQgPSBzdGFydER0LnRvSVNPKCk7XG4gIGNvbnN0IGNhY2hlS2V5RW5kID0gZW5kRHQudG9JU08oKTtcbiAgXG4gICBpZiAoIWNhY2hlS2V5U3RhcnQgfHwgIWNhY2hlS2V5RW5kKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGUgZm9ybWF0IGZvciBjYWNoaW5nOiAke3N0YXJ0X2RhdGV9LCAke2VuZF9kYXRlfWApO1xuICAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgY2FjaGVkRXZlbnRzID0gYXdhaXQgZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlKHVzZXJJZENhY2hlUHJlZml4LCBjYWNoZUtleVN0YXJ0LCBjYWNoZUtleUVuZCk7XG4gICAgaWYgKGNhY2hlZEV2ZW50cykge1xuICAgICAgY29uc29sZS5sb2coYENhY2hlIEhJVCBmb3IgZXZlbnRzIGZyb20gJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgLy8gRW5zdXJlIGl0IHJldHVybnMgYW4gYXJyYXkgZXZlbiBpZiBjYWNoZSBzdG9yZXMgbnVsbC91bmRlZmluZWQgbWlzdGFrZW5seVxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2FjaGVkRXZlbnRzKSA/IGNhY2hlZEV2ZW50cyA6IFtdO1xuICAgIH1cbiAgICAgY29uc29sZS5sb2coYENhY2hlIE1JU1MgZm9yIGV2ZW50cyBmcm9tICR7Y2FjaGVLZXlTdGFydH0gdG8gJHtjYWNoZUtleUVuZH1gKTtcblxuICAgIC8vIEZldGNoIGZyb20gQVBJIHVzaW5nIHRoZSBhY3R1YWwgQ2FsZW5kYXIgZnVuY3Rpb25cbiAgICAvLyBQYXNzIHRoZSBleGFjdCBJU08gc3RyaW5ncyB0byBwcmVzZXJ2ZSB0aW1lem9uZSBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IGdldENhbGVuZGFyRXZlbnRzKHRva2VucywgbmV3IERhdGUoc3RhcnRXaXRoVHopLCBuZXcgRGF0ZShlbmRXaXRoVHopKTtcbiAgICBpZiAoZXZlbnRzICYmIEFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgYXdhaXQgY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UodXNlcklkQ2FjaGVQcmVmaXgsIGNhY2hlS2V5U3RhcnQsIGNhY2hlS2V5RW5kLCBldmVudHMsIDMwMCk7IC8vIDUgbWluIFRUTFxuICAgICAgY29uc29sZS5sb2coYFN0b3JlZCAke2V2ZW50cy5sZW5ndGh9IGV2ZW50cyBpbiBSZWRpcyBjYWNoZSBmb3IgcmFuZ2UgJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIGV2ZW50cyByZXR1cm5lZCBvciBub24tYXJyYXkgZnJvbSBmZXRjaEdDYWxlbmRhckV2ZW50cyBmb3IgJHtjYWNoZUtleVN0YXJ0fS0ke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBmYWlsdXJlIG9yIG5vbi1hcnJheSByZXN1bHRcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gZ2V0Q2FjaGVkRXZlbnRzICgke2NhY2hlS2V5U3RhcnR9IHRvICR7Y2FjaGVLZXlFbmR9KTpgLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggb3IgY2FjaGUgY2FsZW5kYXIgZXZlbnRzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlKHRva2VucyA9IG51bGwsIHN0YXJ0RGF0ZSA9IG51bGwsIGVuZERhdGUgPSBudWxsKSB7XG4gICAgbWVtb3J5Q2FjaGUuZmx1c2hBbGwoKTsgLy8gQWx3YXlzIGZsdXNoIG1lbW9yeSBjYWNoZVxuICAgIGNvbnNvbGUubG9nKFwiTWVtb3J5IGNhY2hlIGludmFsaWRhdGVkXCIpO1xuICAgIFxuICAgIC8vIElmIHdlIGhhdmUgYSBzcGVjaWZpYyBkYXRlIHJhbmdlIHRvIGludmFsaWRhdGVcbiAgICBpZiAodG9rZW5zPy5hY2Nlc3NfdG9rZW4gJiYgc3RhcnREYXRlICYmIGVuZERhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBzdGFydERhdGUgYW5kIGVuZERhdGUgaGF2ZSBwcm9wZXIgdGltZXpvbmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHVzZXJUaW1lem9uZSA9IGdldFVzZXJUaW1lem9uZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRXaXRoVHogPSB0eXBlb2Ygc3RhcnREYXRlID09PSAnc3RyaW5nJyA/IGNvbnZlcnRUb1VUQ0lTT1N0cmluZyhzdGFydERhdGUsIHVzZXJUaW1lem9uZSkgfHwgc3RhcnREYXRlIDogc3RhcnREYXRlO1xuICAgICAgICAgICAgY29uc3QgZW5kV2l0aFR6ID0gdHlwZW9mIGVuZERhdGUgPT09ICdzdHJpbmcnID8gY29udmVydFRvVVRDSVNPU3RyaW5nKGVuZERhdGUsIHVzZXJUaW1lem9uZSkgfHwgZW5kRGF0ZSA6IGVuZERhdGU7XG5cbiAgICAgICAgICAgIGNvbnN0IHRva2VuSGFzaCA9IHRva2Vucy5hY2Nlc3NfdG9rZW4uc3Vic3RyaW5nKHRva2Vucy5hY2Nlc3NfdG9rZW4ubGVuZ3RoIC0gMTApO1xuICAgICAgICAgICAgY29uc3QgdXNlcklkQ2FjaGVQcmVmaXggPSBgdXNlcl8ke3Rva2VuSGFzaH1gOyAvLyBVc2UgY29uc2lzdGVudCBwcmVmaXhcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUGFyc2UgZGF0ZXMgYW5kIHByZXNlcnZlIHRpbWV6b25lIGluZm9ybWF0aW9uXG4gICAgICAgICAgICBjb25zdCBzdGFydER0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzdGFydFdpdGhUeik7XG4gICAgICAgICAgICBjb25zdCBlbmREdCA9IERhdGVUaW1lLmZyb21JU08oZW5kV2l0aFR6KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9nIHRoZSBvcmlnaW5hbCBhbmQgcGFyc2VkIGRhdGVzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBpbnZhbGlkYXRlQ2FjaGUgb3JpZ2luYWwgcmFuZ2U6ICR7c3RhcnREYXRlfSB0byAke2VuZERhdGV9IChjb252ZXJ0ZWQgdG86ICR7c3RhcnRXaXRoVHp9IHRvICR7ZW5kV2l0aFR6fSlgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBpbnZhbGlkYXRlQ2FjaGUgcGFyc2VkIHJhbmdlOiAke3N0YXJ0RHQudG9JU08oKX0gdG8gJHtlbmREdC50b0lTTygpfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVc2UgZnVsbCBJU08gc3RyaW5ncyBmb3IgY2FjaGUga2V5cyB0byBwcmVzZXJ2ZSB0aW1lem9uZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBzdGFydER0LnRvSVNPKCk7XG4gICAgICAgICAgICBjb25zdCBlbmRLZXkgPSBlbmREdC50b0lTTygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXN0YXJ0S2V5IHx8ICFlbmRLZXkpIHtcbiAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgaW52YWxpZGF0ZSBSZWRpczogSW52YWxpZCBkYXRlIGZvcm1hdCAke3N0YXJ0RGF0ZX0sICR7ZW5kRGF0ZX1gKTtcbiAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGludmFsaWRhdGVEYXRlUmFuZ2VDYWNoZSh1c2VySWRDYWNoZVByZWZpeCwgc3RhcnRLZXksIGVuZEtleSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZGF0ZWQgUmVkaXMgY2FjaGUgZm9yIHVzZXIgJHt1c2VySWRDYWNoZVByZWZpeH0sIGV4YWN0IHJhbmdlICR7c3RhcnRLZXl9IHRvICR7ZW5kS2V5fWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGludmFsaWRhdGluZyBSZWRpcyBkYXRlIHJhbmdlIGNhY2hlOlwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNraXBwaW5nIGdyYW51bGFyIFJlZGlzIGNhY2hlIGludmFsaWRhdGlvbiAobWlzc2luZyB0b2tlbiBvciBkYXRlIHJhbmdlKVwiKTtcbiAgICB9XG59XG5cbi8vIEV4cG9ydCB0aGUgZnVuY3Rpb25zXG5leHBvcnQgeyBnZXRDYWNoZWRFdmVudHMsIGludmFsaWRhdGVDYWNoZSB9O1xuIl0sIm5hbWVzIjpbIk5vZGVDYWNoZSIsIkRhdGVUaW1lIiwiZ2V0VXNlclRpbWV6b25lIiwiY29udmVydFRvVVRDSVNPU3RyaW5nIiwiZ2V0Q2FsZW5kYXJFdmVudHMiLCJnZXRDYWNoZWRFdmVudHNGb3JEYXRlUmFuZ2UiLCJjYWNoZUV2ZW50c0ZvckRhdGVSYW5nZSIsImludmFsaWRhdGVEYXRlUmFuZ2VDYWNoZSIsIm1lbW9yeUNhY2hlIiwic3RkVFRMIiwiZ2V0Q2FjaGVkRXZlbnRzIiwidG9rZW5zIiwic3RhcnRfZGF0ZSIsImVuZF9kYXRlIiwiYWNjZXNzX3Rva2VuIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsInVzZXJUaW1lem9uZSIsInN0YXJ0V2l0aFR6IiwiZW5kV2l0aFR6IiwidG9rZW5IYXNoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwidXNlcklkQ2FjaGVQcmVmaXgiLCJzdGFydER0IiwiZnJvbUlTTyIsImVuZER0IiwibG9nIiwidG9JU08iLCJjYWNoZUtleVN0YXJ0IiwiY2FjaGVLZXlFbmQiLCJjYWNoZWRFdmVudHMiLCJBcnJheSIsImlzQXJyYXkiLCJldmVudHMiLCJEYXRlIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW52YWxpZGF0ZUNhY2hlIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImZsdXNoQWxsIiwic3RhcnRLZXkiLCJlbmRLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/services/cacheService.js\n");

/***/ }),

/***/ "(api)/./lib/tools/checkForConflicts.js":
/*!****************************************!*\
  !*** ./lib/tools/checkForConflicts.js ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkForConflicts: () => (/* binding */ checkForConflicts)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/cacheService.js */ \"(api)/./lib/services/cacheService.js\");\n/* harmony import */ var _timeUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./timeUtils.js */ \"(api)/./lib/tools/timeUtils.js\");\n/* harmony import */ var _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _timeUtils_js__WEBPACK_IMPORTED_MODULE_2__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__]);\n([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _timeUtils_js__WEBPACK_IMPORTED_MODULE_2__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// lib/tools/checkForConflicts.js\n\n\n\n\n// --- Conflict Checking ---\nasync function checkForConflicts(tokens, start, end, overrideConflict = false) {\n    try {\n        // Ensure start and end times have proper timezone information\n        const userTimezone = (0,_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.getUserTimezone)();\n        const startWithTz = typeof start === \"string\" ? (0,_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertToUTCISOString)(start, userTimezone) : start;\n        const endWithTz = typeof end === \"string\" ? (0,_timeUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertToUTCISOString)(end, userTimezone) : end;\n        const checkStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(startWithTz);\n        const checkEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(endWithTz);\n        console.log(`Checking conflicts for: ${startWithTz} to ${endWithTz}`);\n        console.log(`Parsed DateTime objects: ${checkStart.toISO()} to ${checkEnd.toISO()}`);\n        console.log(`Override conflict flag: ${overrideConflict}`);\n        if (!checkStart.isValid || !checkEnd.isValid) {\n            throw new Error(`Invalid start/end time for conflict check: start=${startWithTz}, end=${endWithTz}`);\n        }\n        // Use the exact time range instead of the whole day to avoid unnecessary conflicts\n        // This is especially important for events after 7 PM Zulu time\n        const fetchStart = checkStart.minus({\n            hours: 1\n        }).toISO(); // Buffer of 1 hour before\n        const fetchEnd = checkEnd.plus({\n            hours: 1\n        }).toISO(); // Buffer of 1 hour after\n        console.log(`Fetching events from: ${fetchStart} to ${fetchEnd}`);\n        const events = await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__.getCachedEvents)(tokens, fetchStart, fetchEnd);\n        console.log(`Found ${events.length} events in the fetch window`);\n        const conflicts = events.filter((event)=>{\n            try {\n                const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                // Debug log for events near the conflict time\n                console.log(`Comparing with event: \"${event.summary}\" - ${eventStart.toISO()} to ${eventEnd.toISO()}`);\n                if (!eventStart.isValid || !eventEnd.isValid) return false; // Skip invalid event data\n                // Check if this is an all-day event (has date but no dateTime)\n                const isAllDayEvent = event.start?.date && !event.start?.dateTime;\n                // Strict overlap condition - events must actually overlap in time\n                let overlaps = eventStart < checkEnd && checkStart < eventEnd;\n                // For all-day events, don't consider them as conflicts unless explicitly configured\n                // This allows regular timed events to be scheduled during all-day events\n                if (isAllDayEvent) {\n                    // Check if the event summary contains keywords that indicate it should block time\n                    const blockingKeywords = [\n                        \"meeting\",\n                        \"appointment\",\n                        \"interview\",\n                        \"call\",\n                        \"conference\"\n                    ];\n                    const shouldBlock = blockingKeywords.some((keyword)=>event.summary?.toLowerCase().includes(keyword));\n                    if (!shouldBlock) {\n                        console.log(`All-day event \"${event.summary}\" is not blocking time slots.`);\n                        overlaps = false; // Don't consider this a conflict\n                    } else {\n                        console.log(`All-day event \"${event.summary}\" is blocking time slots due to keywords.`);\n                    }\n                }\n                if (overlaps) {\n                    console.log(`CONFLICT detected with: \"${event.summary}\" - ${eventStart.toISO()} to ${eventEnd.toISO()}`);\n                }\n                return overlaps;\n            } catch  {\n                return false;\n            } // Ignore parsing errors for individual events\n        });\n        if (conflicts.length > 0 && !overrideConflict) {\n            console.log(`Conflict detected for ${startWithTz} - ${endWithTz}. Override flag: ${overrideConflict}`);\n            const duration = checkEnd.diff(checkStart, \"minutes\").minutes;\n            // Ensure findAvailableSlotsUtil handles potential errors gracefully\n            let suggestions = [];\n            try {\n                // Use a wider range for suggestions but centered around the requested time\n                const suggestStart = checkStart.minus({\n                    hours: 12\n                }).toISO();\n                const suggestEnd = checkEnd.plus({\n                    hours: 12\n                }).toISO();\n                suggestions = await (0,_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__.findAvailableSlots)(events, duration, suggestStart, suggestEnd, \"Event\", \"any\");\n            } catch (suggestionError) {\n                console.error(\"Error finding suggestions during conflict check:\", suggestionError);\n            }\n            return {\n                conflicts: true,\n                suggestions: suggestions || []\n            };\n        } else if (conflicts.length > 0 && overrideConflict) {\n            console.log(`Conflict detected but override flag is set to true. Proceeding with event creation.`);\n            return {\n                conflicts: false,\n                overridden: true,\n                conflictCount: conflicts.length\n            };\n        }\n        return {\n            conflicts: false,\n            suggestions: []\n        };\n    } catch (error) {\n        console.error(\"Error checking for conflicts:\", error);\n        // Return conflict=true to be safe on error, prevents accidental scheduling\n        return {\n            conflicts: true,\n            suggestions: [],\n            error: `Conflict check failed: ${error.message}`\n        };\n    }\n}\n// Export the function\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUs7Z0JBQ3RENkIsY0FBYyxNQUFNM0MsdUVBQWtCQSxDQUFDc0IsUUFBUWtCLFVBQVVJLGNBQWNDLFlBQVksU0FBUztZQUNqRyxFQUFFLE9BQU9DLGlCQUFpQjtnQkFDckJsQyxRQUFRbUMsS0FBSyxDQUFDLG9EQUFvREQ7WUFDdkU7WUFDQSxPQUFPO2dCQUFFdEIsV0FBVztnQkFBTW1CLGFBQWFBLGVBQWUsRUFBRTtZQUFDO1FBQzNELE9BQU8sSUFBSW5CLFVBQVVELE1BQU0sR0FBRyxLQUFLbEIsa0JBQWtCO1lBQ25ETyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxtRkFBbUYsQ0FBQztZQUNqRyxPQUFPO2dCQUFFVyxXQUFXO2dCQUFPd0IsWUFBWTtnQkFBTUMsZUFBZXpCLFVBQVVELE1BQU07WUFBQztRQUMvRTtRQUNBLE9BQU87WUFBRUMsV0FBVztZQUFPbUIsYUFBYSxFQUFFO1FBQUM7SUFDN0MsRUFBRSxPQUFPSSxPQUFPO1FBQ1puQyxRQUFRbUMsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsMkVBQTJFO1FBQzNFLE9BQU87WUFBRXZCLFdBQVc7WUFBTW1CLGFBQWEsRUFBRTtZQUFFSSxPQUFPLENBQUMsdUJBQXVCLEVBQUVBLE1BQU1HLE9BQU8sQ0FBQyxDQUFDO1FBQUM7SUFDaEc7QUFDRjtBQUVBLHNCQUFzQjtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2NhbGVuZGFyYXBwLy4vbGliL3Rvb2xzL2NoZWNrRm9yQ29uZmxpY3RzLmpzPzU1NTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL3Rvb2xzL2NoZWNrRm9yQ29uZmxpY3RzLmpzXG5pbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2x1eG9uJztcbmltcG9ydCB7IGdldENhY2hlZEV2ZW50cyB9IGZyb20gJy4uL3NlcnZpY2VzL2NhY2hlU2VydmljZS5qcyc7XG5pbXBvcnQgeyBnZXRVc2VyVGltZXpvbmUsIGNvbnZlcnRUb1VUQ0lTT1N0cmluZyB9IGZyb20gJy4vdGltZVV0aWxzLmpzJztcbmltcG9ydCB7IGZpbmRBdmFpbGFibGVTbG90cyB9IGZyb20gJy4vc2NoZWR1bGluZ1V0aWxzLmpzJztcblxuLy8gLS0tIENvbmZsaWN0IENoZWNraW5nIC0tLVxuYXN5bmMgZnVuY3Rpb24gY2hlY2tGb3JDb25mbGljdHModG9rZW5zLCBzdGFydCwgZW5kLCBvdmVycmlkZUNvbmZsaWN0ID0gZmFsc2UpIHtcbiAgdHJ5IHtcbiAgICAvLyBFbnN1cmUgc3RhcnQgYW5kIGVuZCB0aW1lcyBoYXZlIHByb3BlciB0aW1lem9uZSBpbmZvcm1hdGlvblxuICAgIGNvbnN0IHVzZXJUaW1lem9uZSA9IGdldFVzZXJUaW1lem9uZSgpO1xuICAgIGNvbnN0IHN0YXJ0V2l0aFR6ID0gdHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJyA/IGNvbnZlcnRUb1VUQ0lTT1N0cmluZyhzdGFydCwgdXNlclRpbWV6b25lKSA6IHN0YXJ0O1xuICAgIGNvbnN0IGVuZFdpdGhUeiA9IHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnID8gY29udmVydFRvVVRDSVNPU3RyaW5nKGVuZCwgdXNlclRpbWV6b25lKSA6IGVuZDtcbiAgICBcbiAgICBjb25zdCBjaGVja1N0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzdGFydFdpdGhUeik7XG4gICAgY29uc3QgY2hlY2tFbmQgPSBEYXRlVGltZS5mcm9tSVNPKGVuZFdpdGhUeik7XG4gICAgXG4gICAgY29uc29sZS5sb2coYENoZWNraW5nIGNvbmZsaWN0cyBmb3I6ICR7c3RhcnRXaXRoVHp9IHRvICR7ZW5kV2l0aFR6fWApO1xuICAgIGNvbnNvbGUubG9nKGBQYXJzZWQgRGF0ZVRpbWUgb2JqZWN0czogJHtjaGVja1N0YXJ0LnRvSVNPKCl9IHRvICR7Y2hlY2tFbmQudG9JU08oKX1gKTtcbiAgICBjb25zb2xlLmxvZyhgT3ZlcnJpZGUgY29uZmxpY3QgZmxhZzogJHtvdmVycmlkZUNvbmZsaWN0fWApO1xuXG4gICAgaWYgKCFjaGVja1N0YXJ0LmlzVmFsaWQgfHwgIWNoZWNrRW5kLmlzVmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXJ0L2VuZCB0aW1lIGZvciBjb25mbGljdCBjaGVjazogc3RhcnQ9JHtzdGFydFdpdGhUen0sIGVuZD0ke2VuZFdpdGhUen1gKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIGV4YWN0IHRpbWUgcmFuZ2UgaW5zdGVhZCBvZiB0aGUgd2hvbGUgZGF5IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbmZsaWN0c1xuICAgIC8vIFRoaXMgaXMgZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIGV2ZW50cyBhZnRlciA3IFBNIFp1bHUgdGltZVxuICAgIGNvbnN0IGZldGNoU3RhcnQgPSBjaGVja1N0YXJ0Lm1pbnVzKHsgaG91cnM6IDEgfSkudG9JU08oKTsgLy8gQnVmZmVyIG9mIDEgaG91ciBiZWZvcmVcbiAgICBjb25zdCBmZXRjaEVuZCA9IGNoZWNrRW5kLnBsdXMoeyBob3VyczogMSB9KS50b0lTTygpOyAgIC8vIEJ1ZmZlciBvZiAxIGhvdXIgYWZ0ZXJcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZXZlbnRzIGZyb206ICR7ZmV0Y2hTdGFydH0gdG8gJHtmZXRjaEVuZH1gKTtcblxuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50cyh0b2tlbnMsIGZldGNoU3RhcnQsIGZldGNoRW5kKTtcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtldmVudHMubGVuZ3RofSBldmVudHMgaW4gdGhlIGZldGNoIHdpbmRvd2ApO1xuXG4gICAgY29uc3QgY29uZmxpY3RzID0gZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICAgdHJ5IHtcbiAgICAgICAgICAgY29uc3QgZXZlbnRTdGFydCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlKTtcbiAgICAgICAgICAgY29uc3QgZXZlbnRFbmQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50LmVuZD8uZGF0ZVRpbWUgfHwgZXZlbnQuZW5kPy5kYXRlKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgIC8vIERlYnVnIGxvZyBmb3IgZXZlbnRzIG5lYXIgdGhlIGNvbmZsaWN0IHRpbWVcbiAgICAgICAgICAgY29uc29sZS5sb2coYENvbXBhcmluZyB3aXRoIGV2ZW50OiBcIiR7ZXZlbnQuc3VtbWFyeX1cIiAtICR7ZXZlbnRTdGFydC50b0lTTygpfSB0byAke2V2ZW50RW5kLnRvSVNPKCl9YCk7XG4gICAgICAgICAgIFxuICAgICAgICAgICBpZiAoIWV2ZW50U3RhcnQuaXNWYWxpZCB8fCAhZXZlbnRFbmQuaXNWYWxpZCkgcmV0dXJuIGZhbHNlOyAvLyBTa2lwIGludmFsaWQgZXZlbnQgZGF0YVxuICAgICAgICAgICBcbiAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBhbGwtZGF5IGV2ZW50IChoYXMgZGF0ZSBidXQgbm8gZGF0ZVRpbWUpXG4gICAgICAgICAgIGNvbnN0IGlzQWxsRGF5RXZlbnQgPSBldmVudC5zdGFydD8uZGF0ZSAmJiAhZXZlbnQuc3RhcnQ/LmRhdGVUaW1lO1xuICAgICAgICAgICBcbiAgICAgICAgICAgLy8gU3RyaWN0IG92ZXJsYXAgY29uZGl0aW9uIC0gZXZlbnRzIG11c3QgYWN0dWFsbHkgb3ZlcmxhcCBpbiB0aW1lXG4gICAgICAgICAgIGxldCBvdmVybGFwcyA9IGV2ZW50U3RhcnQgPCBjaGVja0VuZCAmJiBjaGVja1N0YXJ0IDwgZXZlbnRFbmQ7XG4gICAgICAgICAgIFxuICAgICAgICAgICAvLyBGb3IgYWxsLWRheSBldmVudHMsIGRvbid0IGNvbnNpZGVyIHRoZW0gYXMgY29uZmxpY3RzIHVubGVzcyBleHBsaWNpdGx5IGNvbmZpZ3VyZWRcbiAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgcmVndWxhciB0aW1lZCBldmVudHMgdG8gYmUgc2NoZWR1bGVkIGR1cmluZyBhbGwtZGF5IGV2ZW50c1xuICAgICAgICAgICBpZiAoaXNBbGxEYXlFdmVudCkge1xuICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IHN1bW1hcnkgY29udGFpbnMga2V5d29yZHMgdGhhdCBpbmRpY2F0ZSBpdCBzaG91bGQgYmxvY2sgdGltZVxuICAgICAgICAgICAgICAgY29uc3QgYmxvY2tpbmdLZXl3b3JkcyA9IFsnbWVldGluZycsICdhcHBvaW50bWVudCcsICdpbnRlcnZpZXcnLCAnY2FsbCcsICdjb25mZXJlbmNlJ107XG4gICAgICAgICAgICAgICBjb25zdCBzaG91bGRCbG9jayA9IGJsb2NraW5nS2V5d29yZHMuc29tZShrZXl3b3JkID0+IFxuICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1bW1hcnk/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZClcbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIGlmICghc2hvdWxkQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQWxsLWRheSBldmVudCBcIiR7ZXZlbnQuc3VtbWFyeX1cIiBpcyBub3QgYmxvY2tpbmcgdGltZSBzbG90cy5gKTtcbiAgICAgICAgICAgICAgICAgICBvdmVybGFwcyA9IGZhbHNlOyAvLyBEb24ndCBjb25zaWRlciB0aGlzIGEgY29uZmxpY3RcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEFsbC1kYXkgZXZlbnQgXCIke2V2ZW50LnN1bW1hcnl9XCIgaXMgYmxvY2tpbmcgdGltZSBzbG90cyBkdWUgdG8ga2V5d29yZHMuYCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENPTkZMSUNUIGRldGVjdGVkIHdpdGg6IFwiJHtldmVudC5zdW1tYXJ5fVwiIC0gJHtldmVudFN0YXJ0LnRvSVNPKCl9IHRvICR7ZXZlbnRFbmQudG9JU08oKX1gKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBzO1xuICAgICAgIH0gY2F0Y2ggeyByZXR1cm4gZmFsc2U7IH0gLy8gSWdub3JlIHBhcnNpbmcgZXJyb3JzIGZvciBpbmRpdmlkdWFsIGV2ZW50c1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPiAwICYmICFvdmVycmlkZUNvbmZsaWN0KSB7XG4gICAgICBjb25zb2xlLmxvZyhgQ29uZmxpY3QgZGV0ZWN0ZWQgZm9yICR7c3RhcnRXaXRoVHp9IC0gJHtlbmRXaXRoVHp9LiBPdmVycmlkZSBmbGFnOiAke292ZXJyaWRlQ29uZmxpY3R9YCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGNoZWNrRW5kLmRpZmYoY2hlY2tTdGFydCwgJ21pbnV0ZXMnKS5taW51dGVzO1xuICAgICAgLy8gRW5zdXJlIGZpbmRBdmFpbGFibGVTbG90c1V0aWwgaGFuZGxlcyBwb3RlbnRpYWwgZXJyb3JzIGdyYWNlZnVsbHlcbiAgICAgIGxldCBzdWdnZXN0aW9ucyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFVzZSBhIHdpZGVyIHJhbmdlIGZvciBzdWdnZXN0aW9ucyBidXQgY2VudGVyZWQgYXJvdW5kIHRoZSByZXF1ZXN0ZWQgdGltZVxuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdFN0YXJ0ID0gY2hlY2tTdGFydC5taW51cyh7IGhvdXJzOiAxMiB9KS50b0lTTygpO1xuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdEVuZCA9IGNoZWNrRW5kLnBsdXMoeyBob3VyczogMTIgfSkudG9JU08oKTtcbiAgICAgICAgICAgc3VnZ2VzdGlvbnMgPSBhd2FpdCBmaW5kQXZhaWxhYmxlU2xvdHMoZXZlbnRzLCBkdXJhdGlvbiwgc3VnZ2VzdFN0YXJ0LCBzdWdnZXN0RW5kLCBcIkV2ZW50XCIsIFwiYW55XCIpO1xuICAgICAgfSBjYXRjaCAoc3VnZ2VzdGlvbkVycm9yKSB7XG4gICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmaW5kaW5nIHN1Z2dlc3Rpb25zIGR1cmluZyBjb25mbGljdCBjaGVjazpcIiwgc3VnZ2VzdGlvbkVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGNvbmZsaWN0czogdHJ1ZSwgc3VnZ2VzdGlvbnM6IHN1Z2dlc3Rpb25zIHx8IFtdIH07XG4gICAgfSBlbHNlIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCAmJiBvdmVycmlkZUNvbmZsaWN0KSB7XG4gICAgICBjb25zb2xlLmxvZyhgQ29uZmxpY3QgZGV0ZWN0ZWQgYnV0IG92ZXJyaWRlIGZsYWcgaXMgc2V0IHRvIHRydWUuIFByb2NlZWRpbmcgd2l0aCBldmVudCBjcmVhdGlvbi5gKTtcbiAgICAgIHJldHVybiB7IGNvbmZsaWN0czogZmFsc2UsIG92ZXJyaWRkZW46IHRydWUsIGNvbmZsaWN0Q291bnQ6IGNvbmZsaWN0cy5sZW5ndGggfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uZmxpY3RzOiBmYWxzZSwgc3VnZ2VzdGlvbnM6IFtdIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2hlY2tpbmcgZm9yIGNvbmZsaWN0czpcIiwgZXJyb3IpO1xuICAgICAgLy8gUmV0dXJuIGNvbmZsaWN0PXRydWUgdG8gYmUgc2FmZSBvbiBlcnJvciwgcHJldmVudHMgYWNjaWRlbnRhbCBzY2hlZHVsaW5nXG4gICAgICByZXR1cm4geyBjb25mbGljdHM6IHRydWUsIHN1Z2dlc3Rpb25zOiBbXSwgZXJyb3I6IGBDb25mbGljdCBjaGVjayBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gIH07XG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBmdW5jdGlvblxuZXhwb3J0IHsgY2hlY2tGb3JDb25mbGljdHMgfTtcbiJdLCJuYW1lcyI6WyJEYXRlVGltZSIsImdldENhY2hlZEV2ZW50cyIsImdldFVzZXJUaW1lem9uZSIsImNvbnZlcnRUb1VUQ0lTT1N0cmluZyIsImZpbmRBdmFpbGFibGVTbG90cyIsImNoZWNrRm9yQ29uZmxpY3RzIiwidG9rZW5zIiwic3RhcnQiLCJlbmQiLCJvdmVycmlkZUNvbmZsaWN0IiwidXNlclRpbWV6b25lIiwic3RhcnRXaXRoVHoiLCJlbmRXaXRoVHoiLCJjaGVja1N0YXJ0IiwiZnJvbUlTTyIsImNoZWNrRW5kIiwiY29uc29sZSIsImxvZyIsInRvSVNPIiwiaXNWYWxpZCIsIkVycm9yIiwiZmV0Y2hTdGFydCIsIm1pbnVzIiwiaG91cnMiLCJmZXRjaEVuZCIsInBsdXMiLCJldmVudHMiLCJsZW5ndGgiLCJjb25mbGljdHMiLCJmaWx0ZXIiLCJldmVudCIsImV2ZW50U3RhcnQiLCJkYXRlVGltZSIsImRhdGUiLCJldmVudEVuZCIsInN1bW1hcnkiLCJpc0FsbERheUV2ZW50Iiwib3ZlcmxhcHMiLCJibG9ja2luZ0tleXdvcmRzIiwic2hvdWxkQmxvY2siLCJzb21lIiwia2V5d29yZCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJkdXJhdGlvbiIsImRpZmYiLCJtaW51dGVzIiwic3VnZ2VzdGlvbnMiLCJzdWdnZXN0U3RhcnQiLCJzdWdnZXN0RW5kIiwic3VnZ2VzdGlvbkVycm9yIiwiZXJyb3IiLCJvdmVycmlkZGVuIiwiY29uZmxpY3RDb3VudCIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/tools/checkForConflicts.js\n");

/***/ }),

/***/ "(api)/./lib/tools/eventHelpers.js":
/*!***********************************!*\
  !*** ./lib/tools/eventHelpers.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   listTodaysEvents: () => (/* binding */ listTodaysEvents),\n/* harmony export */   suggestEventTime: () => (/* binding */ suggestEventTime)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/cacheService.js */ \"(api)/./lib/services/cacheService.js\");\n/* harmony import */ var _formatters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatters.js */ \"(api)/./lib/tools/formatters.js\");\n/* harmony import */ var _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _formatters_js__WEBPACK_IMPORTED_MODULE_2__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__]);\n([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__, _formatters_js__WEBPACK_IMPORTED_MODULE_2__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n// --- Additional Utility Functions ---\nasync function listTodaysEvents(accessToken = null) {\n    if (!accessToken) return \"Authentication required.\";\n    try {\n        const tokens = {\n            access_token: accessToken\n        };\n        const today = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        const startOfDay = today.startOf(\"day\").toISO();\n        const endOfDay = today.endOf(\"day\").toISO();\n        const events = await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_1__.getCachedEvents)(tokens, startOfDay, endOfDay);\n        return (0,_formatters_js__WEBPACK_IMPORTED_MODULE_2__.formatCalendarEvents)(events);\n    } catch (error) {\n        console.error(\"Failed to fetch today's events:\", error);\n        return `Failed to fetch events: ${error.message}`;\n    }\n}\nasync function suggestEventTime(duration, preferredTime = \"any\", accessToken = null, activity = \"event\") {\n    if (!accessToken) return \"Authentication required.\";\n    if (!duration || typeof duration !== \"number\" || duration <= 0) return \"Invalid duration.\";\n    try {\n        const tokens = {\n            access_token: accessToken\n        };\n        const now = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        const startDate = now.toISO();\n        const endDate = now.plus({\n            days: 7\n        }).endOf(\"day\").toISO(); // Search next 7 days\n        const suggestions = await (0,_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_3__.findAvailableSlots)([], duration, startDate, endDate, activity, preferredTime);\n        return (0,_formatters_js__WEBPACK_IMPORTED_MODULE_2__.formatToolResponse)(\"findAvailableSlots\", suggestions);\n    } catch (error) {\n        console.error(\"Failed to suggest event time:\", error);\n        return `Failed to suggest time: ${error.message}`;\n    }\n}\n// Export the functions\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvdG9vbHMvZXZlbnRIZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNpQztBQUM2QjtBQUNhO0FBQ2pCO0FBRTFELHVDQUF1QztBQUN2QyxlQUFlSyxpQkFBaUJDLGNBQWMsSUFBSTtJQUNoRCxJQUFJLENBQUNBLGFBQWEsT0FBTztJQUN6QixJQUFJO1FBQ0YsTUFBTUMsU0FBUztZQUFFQyxjQUFjRjtRQUFZO1FBQzNDLE1BQU1HLFFBQVFULDJDQUFRQSxDQUFDVSxHQUFHO1FBQzFCLE1BQU1DLGFBQWFGLE1BQU1HLE9BQU8sQ0FBQyxPQUFPQyxLQUFLO1FBQzdDLE1BQU1DLFdBQVdMLE1BQU1NLEtBQUssQ0FBQyxPQUFPRixLQUFLO1FBQ3pDLE1BQU1HLFNBQVMsTUFBTWYsMEVBQWVBLENBQUNNLFFBQVFJLFlBQVlHO1FBQ3pELE9BQU9aLG9FQUFvQkEsQ0FBQ2M7SUFDOUIsRUFBRSxPQUFPQyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBbUNBO1FBQ2pELE9BQU8sQ0FBQyx3QkFBd0IsRUFBRUEsTUFBTUUsT0FBTyxDQUFDLENBQUM7SUFDbkQ7QUFDRjtBQUVBLGVBQWVDLGlCQUFpQkMsUUFBUSxFQUFFQyxnQkFBZ0IsS0FBSyxFQUFFaEIsY0FBYyxJQUFJLEVBQUVpQixXQUFXLE9BQU87SUFDcEcsSUFBSSxDQUFDakIsYUFBYSxPQUFPO0lBQ3pCLElBQUksQ0FBQ2UsWUFBWSxPQUFPQSxhQUFhLFlBQVlBLFlBQVksR0FBRyxPQUFPO0lBQ3hFLElBQUk7UUFDRixNQUFNZCxTQUFTO1lBQUVDLGNBQWNGO1FBQVk7UUFDM0MsTUFBTUksTUFBTVYsMkNBQVFBLENBQUNVLEdBQUc7UUFDeEIsTUFBTWMsWUFBWWQsSUFBSUcsS0FBSztRQUMzQixNQUFNWSxVQUFVZixJQUFJZ0IsSUFBSSxDQUFDO1lBQUVDLE1BQU07UUFBRSxHQUFHWixLQUFLLENBQUMsT0FBT0YsS0FBSyxJQUFJLHFCQUFxQjtRQUNqRixNQUFNZSxjQUFjLE1BQU14Qix1RUFBa0JBLENBQzFDLEVBQUUsRUFDRmlCLFVBQ0FHLFdBQ0FDLFNBQ0FGLFVBQ0FEO1FBRUYsT0FBT25CLGtFQUFrQkEsQ0FBQyxzQkFBc0J5QjtJQUNsRCxFQUFFLE9BQU9YLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsT0FBTyxDQUFDLHdCQUF3QixFQUFFQSxNQUFNRSxPQUFPLENBQUMsQ0FBQztJQUNuRDtBQUNGO0FBRUEsdUJBQXVCO0FBQ3VCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2NhbGVuZGFyYXBwLy4vbGliL3Rvb2xzL2V2ZW50SGVscGVycy5qcz9jNDk1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgeyBnZXRDYWNoZWRFdmVudHMgfSBmcm9tICcuLi9zZXJ2aWNlcy9jYWNoZVNlcnZpY2UuanMnO1xuaW1wb3J0IHsgZm9ybWF0Q2FsZW5kYXJFdmVudHMsIGZvcm1hdFRvb2xSZXNwb25zZSB9IGZyb20gJy4vZm9ybWF0dGVycy5qcyc7XG5pbXBvcnQgeyBmaW5kQXZhaWxhYmxlU2xvdHMgfSBmcm9tICcuL3NjaGVkdWxpbmdVdGlscy5qcyc7XG5cbi8vIC0tLSBBZGRpdGlvbmFsIFV0aWxpdHkgRnVuY3Rpb25zIC0tLVxuYXN5bmMgZnVuY3Rpb24gbGlzdFRvZGF5c0V2ZW50cyhhY2Nlc3NUb2tlbiA9IG51bGwpIHtcbiAgaWYgKCFhY2Nlc3NUb2tlbikgcmV0dXJuIFwiQXV0aGVudGljYXRpb24gcmVxdWlyZWQuXCI7XG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgY29uc3QgdG9kYXkgPSBEYXRlVGltZS5ub3coKTtcbiAgICBjb25zdCBzdGFydE9mRGF5ID0gdG9kYXkuc3RhcnRPZignZGF5JykudG9JU08oKTtcbiAgICBjb25zdCBlbmRPZkRheSA9IHRvZGF5LmVuZE9mKCdkYXknKS50b0lTTygpO1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50cyh0b2tlbnMsIHN0YXJ0T2ZEYXksIGVuZE9mRGF5KTtcbiAgICByZXR1cm4gZm9ybWF0Q2FsZW5kYXJFdmVudHMoZXZlbnRzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHRvZGF5J3MgZXZlbnRzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGBGYWlsZWQgdG8gZmV0Y2ggZXZlbnRzOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzdWdnZXN0RXZlbnRUaW1lKGR1cmF0aW9uLCBwcmVmZXJyZWRUaW1lID0gJ2FueScsIGFjY2Vzc1Rva2VuID0gbnVsbCwgYWN0aXZpdHkgPSBcImV2ZW50XCIpIHtcbiAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiBcIkF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkLlwiO1xuICAgaWYgKCFkdXJhdGlvbiB8fCB0eXBlb2YgZHVyYXRpb24gIT09ICdudW1iZXInIHx8IGR1cmF0aW9uIDw9IDApIHJldHVybiBcIkludmFsaWQgZHVyYXRpb24uXCI7XG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgY29uc3Qgbm93ID0gRGF0ZVRpbWUubm93KCk7XG4gICAgY29uc3Qgc3RhcnREYXRlID0gbm93LnRvSVNPKCk7XG4gICAgY29uc3QgZW5kRGF0ZSA9IG5vdy5wbHVzKHsgZGF5czogNyB9KS5lbmRPZignZGF5JykudG9JU08oKTsgLy8gU2VhcmNoIG5leHQgNyBkYXlzXG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBhd2FpdCBmaW5kQXZhaWxhYmxlU2xvdHMoXG4gICAgICBbXSwgLy8gV2lsbCBiZSBmZXRjaGVkIGluc2lkZSBmaW5kQXZhaWxhYmxlU2xvdHNcbiAgICAgIGR1cmF0aW9uLCBcbiAgICAgIHN0YXJ0RGF0ZSwgXG4gICAgICBlbmREYXRlLCBcbiAgICAgIGFjdGl2aXR5LFxuICAgICAgcHJlZmVycmVkVGltZVxuICAgICk7XG4gICAgcmV0dXJuIGZvcm1hdFRvb2xSZXNwb25zZSgnZmluZEF2YWlsYWJsZVNsb3RzJywgc3VnZ2VzdGlvbnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc3VnZ2VzdCBldmVudCB0aW1lOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGBGYWlsZWQgdG8gc3VnZ2VzdCB0aW1lOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIGZ1bmN0aW9uc1xuZXhwb3J0IHsgbGlzdFRvZGF5c0V2ZW50cywgc3VnZ2VzdEV2ZW50VGltZSB9O1xuIl0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiZ2V0Q2FjaGVkRXZlbnRzIiwiZm9ybWF0Q2FsZW5kYXJFdmVudHMiLCJmb3JtYXRUb29sUmVzcG9uc2UiLCJmaW5kQXZhaWxhYmxlU2xvdHMiLCJsaXN0VG9kYXlzRXZlbnRzIiwiYWNjZXNzVG9rZW4iLCJ0b2tlbnMiLCJhY2Nlc3NfdG9rZW4iLCJ0b2RheSIsIm5vdyIsInN0YXJ0T2ZEYXkiLCJzdGFydE9mIiwidG9JU08iLCJlbmRPZkRheSIsImVuZE9mIiwiZXZlbnRzIiwiZXJyb3IiLCJjb25zb2xlIiwibWVzc2FnZSIsInN1Z2dlc3RFdmVudFRpbWUiLCJkdXJhdGlvbiIsInByZWZlcnJlZFRpbWUiLCJhY3Rpdml0eSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJwbHVzIiwiZGF5cyIsInN1Z2dlc3Rpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/tools/eventHelpers.js\n");

/***/ }),

/***/ "(api)/./lib/tools/formatters.js":
/*!*********************************!*\
  !*** ./lib/tools/formatters.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatCalendarEvents: () => (/* binding */ formatCalendarEvents),\n/* harmony export */   formatEventTime: () => (/* binding */ formatEventTime),\n/* harmony export */   formatToolResponse: () => (/* binding */ formatToolResponse)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__]);\nluxon__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nfunction formatEventTime(eventTime) {\n    // ... (Keep implementation from chatbot.js) ...\n    try {\n        const dt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(eventTime);\n        if (dt.isValid) {\n            return dt.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATETIME_FULL);\n        }\n        const dateOnly = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(eventTime, {\n            zone: \"utc\"\n        });\n        if (dateOnly.isValid) {\n            return dateOnly.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATE_FULL) + \" (All day)\";\n        }\n        return eventTime;\n    } catch (e) {\n        console.warn(\"Error formatting event time:\", eventTime, e);\n        return String(eventTime); // Ensure returns string\n    }\n}\nfunction formatCalendarEvents(events) {\n    if (!events) return \"No events found or an error occurred.\";\n    if (!Array.isArray(events)) return \"An error occurred processing events.\";\n    if (events.length === 0) return \"No events found for the specified time period.\";\n    return events.map((event)=>{\n        try {\n            const start = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n            const end = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || devent.end?.date);\n            if (!start.isValid || !end.isValid) return `â“ Invalid date found for event: ${event.summary || event.id}`;\n            const isAllDay = !event.start?.dateTime;\n            // Include the event ID in the formatted output (hidden with a zero-width space for reference)\n            let formattedEvent = `ðŸ“… ${event.summary || \"(No Title)\"} [ID:â€‹${event.id}]\\n`;\n            formattedEvent += `   ðŸ“† ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATE_FULL)}\\n`;\n            if (!isAllDay) {\n                formattedEvent += `   ðŸ•’ ${start.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.TIME_SIMPLE)} - ${end.toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.TIME_SIMPLE)}\\n`;\n            } else {\n                formattedEvent += `   ðŸ•’ All Day\\n`;\n            }\n            if (event.description) formattedEvent += `   ðŸ“ ${event.description}\\n`;\n            if (event.location) formattedEvent += `   ðŸ“ ${event.location}\\n`;\n            if (event.reminders?.useDefault === false && Array.isArray(event.reminders.overrides)) {\n                formattedEvent += `   ðŸ”” Reminders: ${event.reminders.overrides.map((r)=>`${r.minutes} min`).join(\", \")}\\n`;\n            }\n            // Check if the event has a priority property and display it\n            if (event.priority) {\n                formattedEvent += `   ðŸš© Priority: ${event.priority}\\n`;\n            }\n            // Check if the event has tags and display them\n            if (event.tags && Array.isArray(event.tags) && event.tags.length > 0) {\n                formattedEvent += `   ðŸ·ï¸ Tags: ${event.tags.join(\", \")}\\n`;\n            }\n            return formattedEvent.trim(); // Trim each event string\n        } catch (mapError) {\n            console.error(\"Error mapping event:\", event, mapError);\n            return `â“ Error processing event: ${event.summary || event.id}`;\n        }\n    }).join(\"\\n\\n\"); // Add space between events\n}\n// --- Formatting Tool Responses for the LLM ---\nfunction formatToolResponse(functionName, result) {\n    try {\n        // Explicitly handle null/undefined results first\n        if (result == null) {\n            console.warn(`Tool ${functionName} returned null or undefined.`);\n            return `Tool ${functionName} did not return a result. (Status: FAILED)`;\n        }\n        // Handle known error shapes returned by tool functions\n        if (typeof result === \"string\" && result.toLowerCase().startsWith(\"error:\")) return `${result} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.error) return `Error executing ${functionName}: ${result.error} (Status: FAILED)`;\n        if (typeof result === \"object\" && result.success === false) return `Tool ${functionName} failed: ${result.message || \"No details.\"} (Status: FAILED)`;\n        // --- Format successful results ---\n        switch(functionName){\n            case \"saveUserPreference\":\n                return result.success ? `âœ… Pref saved: ${result.message} (Status: SUCCESS)` : `âŒ Pref fail: ${result.message} (Status: FAILED)`;\n            case \"addCalendarEvents\":\n                if (!Array.isArray(result)) return \"Error: Invalid response format from addCalendarEvents. (Status: FAILED)\";\n                if (result.length === 0) return \"No events were processed. (Status: NEUTRAL)\";\n                return result.map((item)=>{\n                    if (!item) return \"â“ Invalid item in result array. (Status: FAILED)\";\n                    if (item.error) {\n                        const summary = item.summary || \"?\";\n                        if (item.conflict) {\n                            // Include suggestions if available\n                            const suggestionText = item.suggestions && item.suggestions.length > 0 ? ` Suggested slots: ${item.suggestions.map((s)=>`${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(s.start).toFormat(\"h:mma\")} - ${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(s.end).toFormat(\"h:mma\")}`).join(\", \")}` : \"\";\n                            return `âš ï¸ Conflict detected for event \"${summary}\".${suggestionText} (Status: CONFLICT)`;\n                        } else {\n                            return `âŒ Failed to add event \"${summary}\": ${item.error} (Status: FAILED)`;\n                        }\n                    } else if (item.id && item.summary && (item.start?.dateTime || item.start?.date)) {\n                        try {\n                            const startStr = formatEventTime(item.start.dateTime || item.start.date); // Use existing helper\n                            let successMsg = `âœ… Event added: \"${item.summary}\" starting ${startStr}. (ID: ${item.id})`;\n                            // Add priority information if available\n                            if (item.priority) {\n                                successMsg += ` [Priority: ${item.priority}]`;\n                            }\n                            successMsg += \" (Status: SUCCESS)\";\n                            return successMsg;\n                        } catch (e) {\n                            console.error(\"Error formatting success message for added event:\", item, e);\n                            return `âœ… Event added: \"${item.summary}\" (details unavailable). (ID: ${item.id}) (Status: SUCCESS)`;\n                        }\n                    } else {\n                        console.warn(\"Unexpected item shape in addCalendarEvents result:\", item);\n                        return `â“ Unknown outcome for an event attempt. (Status: UNKNOWN)`;\n                    }\n                }).join(\"\\n\");\n            case \"getCalendarEvents\":\n                if (typeof result === \"string\") return `ðŸ—“ï¸ Events: ${result} (Status: ${result.toLowerCase().startsWith(\"error\") ? \"FAILED\" : \"SUCCESS\"})`;\n                // More robust handling of different response structures\n                let events = [];\n                if (Array.isArray(result)) {\n                    // Direct array of events\n                    events = result;\n                } else if (result && typeof result === \"object\") {\n                    if (Array.isArray(result.events)) {\n                        // Object with events array property\n                        events = result.events;\n                    } else if (result.success === false) {\n                        // Error object with success: false\n                        return `Error: ${result.error || \"Unknown error retrieving calendar events\"} (Status: FAILED)`;\n                    }\n                } else {\n                    return \"Error: Invalid getCalendarEvents response format. (Status: FAILED)\";\n                }\n                // Process the events array\n                if (events.length === 0) {\n                    return \"\\uD83D\\uDDD3ï¸ No events found. (Status: SUCCESS)\";\n                } else {\n                    const priorityInfo = events.some((e)=>e.priority) ? \" (includes priority information)\" : \"\";\n                    const textDescription = `ðŸ—“ï¸ Found ${events.length} event(s)${priorityInfo}:\\n\\n${formatCalendarEvents(events)} (Status: SUCCESS)`;\n                    // Log the events for debugging\n                    console.log(\"DEBUG EVENT CARDS: Events to format:\", JSON.stringify(events));\n                    // Send the events directly to the frontend via the chatbot.js responseCallback\n                    // This will be handled in the chatbot.js file\n                    setTimeout(()=>{\n                        if (global.currentResponseCallback) {\n                            global.currentResponseCallback({\n                                type: \"events\",\n                                content: \"Here are your calendar events:\",\n                                events: events\n                            });\n                        }\n                    }, 500);\n                    // Return the text description for the message content\n                    return textDescription;\n                }\n            case \"deleteCalendarEvent\":\n                return result.success ? `ðŸ—‘ï¸ Event \"${result.summary || result.eventId}\" deleted. (Status: SUCCESS)` // Use eventId if summary wasn't fetched/returned\n                 : `âŒ Failed to delete event ${result.eventId || \"?\"}: ${result.error || result.message || \"?\"} (Status: FAILED)`;\n            case \"updateCalendarEvent\":\n                // Check if result has an ID, indicating success from googleCalendar update function\n                if (result && result.id) {\n                    let successMsg = `âœï¸ Event \"${result.summary || result.id}\" updated. (ID: ${result.id})`;\n                    // Add priority information if available\n                    if (result.priority) {\n                        successMsg += ` [Priority: ${result.priority}]`;\n                    }\n                    successMsg += \" (Status: SUCCESS)\";\n                    return successMsg;\n                } else {\n                    // Handle potential error objects passed back\n                    const errorMsg = result?.error || result?.message || JSON.stringify(result);\n                    return `âŒ Failed to update event: ${errorMsg} (Status: FAILED)`;\n                }\n            case \"findAvailableSlots\":\n                if (!Array.isArray(result)) return \"Error: Invalid findAvailableSlots response. (Status: FAILED)\";\n                if (result.length === 0) return `ðŸ•’ No available slots found matching criteria. (Status: SUCCESS)`;\n                // Format slots with success status\n                const formattedSlots = result.map((slot)=>`${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.start).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.DATETIME_SHORT)} - ${luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.end).toLocaleString(luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.TIME_SIMPLE)}`).join(\"\\n\");\n                return `ðŸ•’ Found ${result.length} available slot(s):\\n\\n${formattedSlots}\\n\\n(Status: SUCCESS)`;\n            case \"getWeatherForecast\":\n                return `ðŸŒ¤ï¸ Weather for ${result.location} on ${result.date}: ${result.forecast || \"N/A\"} (Status: ${result.forecast && !result.forecast.includes(\"unavailable\") ? \"SUCCESS\" : \"PARTIAL\"})`;\n            case \"deleteCalendarEventsByQuery\":\n                return result.success ? `ðŸ—‘ï¸ ${result.message} (Deleted Count: ${result.deletedCount}) (Status: SUCCESS)` : `âŒ Failed bulk delete: ${result.message || result.error || \"?\"} (Status: FAILED)`;\n            default:\n                // Safely stringify other results with status indicators\n                if (typeof result === \"object\" && result !== null) {\n                    const status = result.success === true ? \"SUCCESS\" : result.success === false ? \"FAILED\" : \"UNKNOWN\";\n                    return `${JSON.stringify(result)} (Status: ${status})`;\n                } else {\n                    return `${String(result)} (Status: UNKNOWN)`;\n                }\n        }\n    } catch (formatError) {\n        console.error(`CRITICAL: Error *within* formatToolResponse for ${functionName}:`, formatError, \"Raw result:\", result);\n        // Return a guaranteed string error message\n        return `Internal Error: Failed to format the result for ${functionName}. (Status: ERROR)`;\n    }\n}\n// Export the functions\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFVBQVUsRUFBRWdDLE9BQU8sQ0FBQyxDQUFDO2dCQUMxRCxPQUFPO29CQUNILE9BQU8sQ0FBQyxFQUFFakUsT0FBT2lDLFFBQVEsa0JBQWtCLENBQUM7Z0JBQ2hEO1FBQ1I7SUFDSixFQUFFLE9BQU9pQyxhQUFhO1FBQ2xCcEUsUUFBUWdDLEtBQUssQ0FBQyxDQUFDLGdEQUFnRCxFQUFFRSxhQUFhLENBQUMsQ0FBQyxFQUFFa0MsYUFBYSxlQUFlakM7UUFDOUcsMkNBQTJDO1FBQzNDLE9BQU8sQ0FBQyxnREFBZ0QsRUFBRUQsYUFBYSxpQkFBaUIsQ0FBQztJQUM3RjtBQUNKO0FBRUEsdUJBQXVCO0FBQzhDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2NhbGVuZGFyYXBwLy4vbGliL3Rvb2xzL2Zvcm1hdHRlcnMuanM/NTk3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSAnbHV4b24nO1xuXG5mdW5jdGlvbiBmb3JtYXRFdmVudFRpbWUoZXZlbnRUaW1lKSB7XG4gICAgLy8gLi4uIChLZWVwIGltcGxlbWVudGF0aW9uIGZyb20gY2hhdGJvdC5qcykgLi4uXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZHQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50VGltZSk7XG4gICAgICAgIGlmIChkdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZHQudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfRlVMTCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZU9ubHkgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50VGltZSwgeyB6b25lOiAndXRjJyB9KTtcbiAgICAgICAgaWYgKGRhdGVPbmx5LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlT25seS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpICsgXCIgKEFsbCBkYXkpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50VGltZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZvcm1hdHRpbmcgZXZlbnQgdGltZTpcIiwgZXZlbnRUaW1lLCBlKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhldmVudFRpbWUpOyAvLyBFbnN1cmUgcmV0dXJucyBzdHJpbmdcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENhbGVuZGFyRXZlbnRzKGV2ZW50cykge1xuICAgIGlmICghZXZlbnRzKSByZXR1cm4gXCJObyBldmVudHMgZm91bmQgb3IgYW4gZXJyb3Igb2NjdXJyZWQuXCI7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHJldHVybiBcIkFuIGVycm9yIG9jY3VycmVkIHByb2Nlc3NpbmcgZXZlbnRzLlwiO1xuICAgIGlmIChldmVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJObyBldmVudHMgZm91bmQgZm9yIHRoZSBzcGVjaWZpZWQgdGltZSBwZXJpb2QuXCI7XG5cbiAgICByZXR1cm4gZXZlbnRzLm1hcChldmVudCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kPy5kYXRlVGltZSB8fCBkZXZlbnQuZW5kPy5kYXRlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnQuaXNWYWxpZCB8fCAhZW5kLmlzVmFsaWQpIHJldHVybiBg4p2TIEludmFsaWQgZGF0ZSBmb3VuZCBmb3IgZXZlbnQ6ICR7ZXZlbnQuc3VtbWFyeSB8fCBldmVudC5pZH1gO1xuXG4gICAgICAgICAgICBjb25zdCBpc0FsbERheSA9ICFldmVudC5zdGFydD8uZGF0ZVRpbWU7XG4gICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBldmVudCBJRCBpbiB0aGUgZm9ybWF0dGVkIG91dHB1dCAoaGlkZGVuIHdpdGggYSB6ZXJvLXdpZHRoIHNwYWNlIGZvciByZWZlcmVuY2UpXG4gICAgICAgICAgICBsZXQgZm9ybWF0dGVkRXZlbnQgPSBg8J+ThSAke2V2ZW50LnN1bW1hcnkgfHwgJyhObyBUaXRsZSknfSBbSUQ64oCLJHtldmVudC5pZH1dXFxuYDtcbiAgICAgICAgICAgIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5OGICR7c3RhcnQudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKX1cXG5gO1xuICAgICAgICAgICAgaWYgKCFpc0FsbERheSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5WSICR7c3RhcnQudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpfSAtICR7ZW5kLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKX1cXG5gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+VkiBBbGwgRGF5XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudC5kZXNjcmlwdGlvbikgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCfk50gJHtldmVudC5kZXNjcmlwdGlvbn1cXG5gO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmxvY2F0aW9uKSBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+TjSAke2V2ZW50LmxvY2F0aW9ufVxcbmA7XG4gICAgICAgICAgICBpZiAoZXZlbnQucmVtaW5kZXJzPy51c2VEZWZhdWx0ID09PSBmYWxzZSAmJiBBcnJheS5pc0FycmF5KGV2ZW50LnJlbWluZGVycy5vdmVycmlkZXMpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkRXZlbnQgKz0gYCAgIPCflJQgUmVtaW5kZXJzOiAke2V2ZW50LnJlbWluZGVycy5vdmVycmlkZXMubWFwKHIgPT4gYCR7ci5taW51dGVzfSBtaW5gKS5qb2luKCcsICcpfVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgaGFzIGEgcHJpb3JpdHkgcHJvcGVydHkgYW5kIGRpc3BsYXkgaXRcbiAgICAgICAgICAgIGlmIChldmVudC5wcmlvcml0eSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZEV2ZW50ICs9IGAgICDwn5qpIFByaW9yaXR5OiAke2V2ZW50LnByaW9yaXR5fVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgaGFzIHRhZ3MgYW5kIGRpc3BsYXkgdGhlbVxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZ3MgJiYgQXJyYXkuaXNBcnJheShldmVudC50YWdzKSAmJiBldmVudC50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRFdmVudCArPSBgICAg8J+Pt++4jyBUYWdzOiAke2V2ZW50LnRhZ3Muam9pbignLCAnKX1cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZEV2ZW50LnRyaW0oKTsgLy8gVHJpbSBlYWNoIGV2ZW50IHN0cmluZ1xuICAgICAgICB9IGNhdGNoIChtYXBFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1hcHBpbmcgZXZlbnQ6XCIsIGV2ZW50LCBtYXBFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gYOKdkyBFcnJvciBwcm9jZXNzaW5nIGV2ZW50OiAke2V2ZW50LnN1bW1hcnkgfHwgZXZlbnQuaWR9YDtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oJ1xcblxcbicpOyAvLyBBZGQgc3BhY2UgYmV0d2VlbiBldmVudHNcbn1cblxuXG4vLyAtLS0gRm9ybWF0dGluZyBUb29sIFJlc3BvbnNlcyBmb3IgdGhlIExMTSAtLS1cbmZ1bmN0aW9uIGZvcm1hdFRvb2xSZXNwb25zZShmdW5jdGlvbk5hbWUsIHJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgaGFuZGxlIG51bGwvdW5kZWZpbmVkIHJlc3VsdHMgZmlyc3RcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRvb2wgJHtmdW5jdGlvbk5hbWV9IHJldHVybmVkIG51bGwgb3IgdW5kZWZpbmVkLmApO1xuICAgICAgICAgICAgcmV0dXJuIGBUb29sICR7ZnVuY3Rpb25OYW1lfSBkaWQgbm90IHJldHVybiBhIHJlc3VsdC4gKFN0YXR1czogRkFJTEVEKWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUga25vd24gZXJyb3Igc2hhcGVzIHJldHVybmVkIGJ5IHRvb2wgZnVuY3Rpb25zXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJyAmJiByZXN1bHQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdlcnJvcjonKSlcbiAgICAgICAgICAgIHJldHVybiBgJHtyZXN1bHR9IChTdGF0dXM6IEZBSUxFRClgO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0LmVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBleGVjdXRpbmcgJHtmdW5jdGlvbk5hbWV9OiAke3Jlc3VsdC5lcnJvcn0gKFN0YXR1czogRkFJTEVEKWA7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gYFRvb2wgJHtmdW5jdGlvbk5hbWV9IGZhaWxlZDogJHtyZXN1bHQubWVzc2FnZSB8fCAnTm8gZGV0YWlscy4nfSAoU3RhdHVzOiBGQUlMRUQpYDtcblxuICAgICAgICAvLyAtLS0gRm9ybWF0IHN1Y2Nlc3NmdWwgcmVzdWx0cyAtLS1cbiAgICAgICAgc3dpdGNoIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NhdmVVc2VyUHJlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8gYOKchSBQcmVmIHNhdmVkOiAke3Jlc3VsdC5tZXNzYWdlfSAoU3RhdHVzOiBTVUNDRVNTKWAgOiBg4p2MIFByZWYgZmFpbDogJHtyZXN1bHQubWVzc2FnZX0gKFN0YXR1czogRkFJTEVEKWA7XG5cbiAgICAgICAgICAgIGNhc2UgJ2FkZENhbGVuZGFyRXZlbnRzJzpcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSkgcmV0dXJuIFwiRXJyb3I6IEludmFsaWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gYWRkQ2FsZW5kYXJFdmVudHMuIChTdGF0dXM6IEZBSUxFRClcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiTm8gZXZlbnRzIHdlcmUgcHJvY2Vzc2VkLiAoU3RhdHVzOiBORVVUUkFMKVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiAn4p2TIEludmFsaWQgaXRlbSBpbiByZXN1bHQgYXJyYXkuIChTdGF0dXM6IEZBSUxFRCknO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5lcnJvcikgeyAvLyBIYW5kbGUgZXhwbGljaXQgZXJyb3JzIGZpcnN0IChjb25mbGljdCwgdmFsaWRhdGlvbiwgQVBJKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IGl0ZW0uc3VtbWFyeSB8fCAnPyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb25mbGljdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgc3VnZ2VzdGlvbnMgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGlvblRleHQgPSBpdGVtLnN1Z2dlc3Rpb25zICYmIGl0ZW0uc3VnZ2VzdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAgU3VnZ2VzdGVkIHNsb3RzOiAke2l0ZW0uc3VnZ2VzdGlvbnMubWFwKHMgPT4gYCR7RGF0ZVRpbWUuZnJvbUlTTyhzLnN0YXJ0KS50b0Zvcm1hdCgnaDptbWEnKX0gLSAke0RhdGVUaW1lLmZyb21JU08ocy5lbmQpLnRvRm9ybWF0KCdoOm1tYScpfWApLmpvaW4oJywgJyl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBg4pqg77iPIENvbmZsaWN0IGRldGVjdGVkIGZvciBldmVudCBcIiR7c3VtbWFyeX1cIi4ke3N1Z2dlc3Rpb25UZXh0fSAoU3RhdHVzOiBDT05GTElDVClgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKdjCBGYWlsZWQgdG8gYWRkIGV2ZW50IFwiJHtzdW1tYXJ5fVwiOiAke2l0ZW0uZXJyb3J9IChTdGF0dXM6IEZBSUxFRClgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaWQgJiYgaXRlbS5zdW1tYXJ5ICYmIChpdGVtLnN0YXJ0Py5kYXRlVGltZSB8fCBpdGVtLnN0YXJ0Py5kYXRlKSkgeyAvLyBBc3N1bWUgc3VjY2VzcyBpZiBrZXkgZmllbGRzIGV4aXN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3RyID0gZm9ybWF0RXZlbnRUaW1lKGl0ZW0uc3RhcnQuZGF0ZVRpbWUgfHwgaXRlbS5zdGFydC5kYXRlKTsgLy8gVXNlIGV4aXN0aW5nIGhlbHBlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWNjZXNzTXNnID0gYOKchSBFdmVudCBhZGRlZDogXCIke2l0ZW0uc3VtbWFyeX1cIiBzdGFydGluZyAke3N0YXJ0U3RyfS4gKElEOiAke2l0ZW0uaWR9KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHByaW9yaXR5IGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NNc2cgKz0gYCBbUHJpb3JpdHk6ICR7aXRlbS5wcmlvcml0eX1dYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc01zZyArPSBcIiAoU3RhdHVzOiBTVUNDRVNTKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzTXNnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmb3JtYXR0aW5nIHN1Y2Nlc3MgbWVzc2FnZSBmb3IgYWRkZWQgZXZlbnQ6XCIsIGl0ZW0sIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBg4pyFIEV2ZW50IGFkZGVkOiBcIiR7aXRlbS5zdW1tYXJ5fVwiIChkZXRhaWxzIHVuYXZhaWxhYmxlKS4gKElEOiAke2l0ZW0uaWR9KSAoU3RhdHVzOiBTVUNDRVNTKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIEZhbGxiYWNrIGZvciB1bmV4cGVjdGVkIHNoYXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBpdGVtIHNoYXBlIGluIGFkZENhbGVuZGFyRXZlbnRzIHJlc3VsdDpcIiwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYOKdkyBVbmtub3duIG91dGNvbWUgZm9yIGFuIGV2ZW50IGF0dGVtcHQuIChTdGF0dXM6IFVOS05PV04pYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgICBjYXNlICdnZXRDYWxlbmRhckV2ZW50cyc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYPCfl5PvuI8gRXZlbnRzOiAke3Jlc3VsdH0gKFN0YXR1czogJHtyZXN1bHQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdlcnJvcicpID8gJ0ZBSUxFRCcgOiAnU1VDQ0VTUyd9KWA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTW9yZSByb2J1c3QgaGFuZGxpbmcgb2YgZGlmZmVyZW50IHJlc3BvbnNlIHN0cnVjdHVyZXNcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEaXJlY3QgYXJyYXkgb2YgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQuZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IHdpdGggZXZlbnRzIGFycmF5IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgPSByZXN1bHQuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3Igb2JqZWN0IHdpdGggc3VjY2VzczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgRXJyb3I6ICR7cmVzdWx0LmVycm9yIHx8ICdVbmtub3duIGVycm9yIHJldHJpZXZpbmcgY2FsZW5kYXIgZXZlbnRzJ30gKFN0YXR1czogRkFJTEVEKWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogSW52YWxpZCBnZXRDYWxlbmRhckV2ZW50cyByZXNwb25zZSBmb3JtYXQuIChTdGF0dXM6IEZBSUxFRClcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgZXZlbnRzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwi8J+Xk++4jyBObyBldmVudHMgZm91bmQuIChTdGF0dXM6IFNVQ0NFU1MpXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlJbmZvID0gZXZlbnRzLnNvbWUoZSA9PiBlLnByaW9yaXR5KSA/ICcgKGluY2x1ZGVzIHByaW9yaXR5IGluZm9ybWF0aW9uKScgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dERlc2NyaXB0aW9uID0gYPCfl5PvuI8gRm91bmQgJHtldmVudHMubGVuZ3RofSBldmVudChzKSR7cHJpb3JpdHlJbmZvfTpcXG5cXG4ke2Zvcm1hdENhbGVuZGFyRXZlbnRzKGV2ZW50cyl9IChTdGF0dXM6IFNVQ0NFU1MpYDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyB0aGUgZXZlbnRzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJERUJVRyBFVkVOVCBDQVJEUzogRXZlbnRzIHRvIGZvcm1hdDpcIiwgSlNPTi5zdHJpbmdpZnkoZXZlbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBldmVudHMgZGlyZWN0bHkgdG8gdGhlIGZyb250ZW5kIHZpYSB0aGUgY2hhdGJvdC5qcyByZXNwb25zZUNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSBjaGF0Ym90LmpzIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsLmN1cnJlbnRSZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLmN1cnJlbnRSZXNwb25zZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdIZXJlIGFyZSB5b3VyIGNhbGVuZGFyIGV2ZW50czonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgbWVzc2FnZSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0RGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdkZWxldGVDYWxlbmRhckV2ZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgPyBg8J+Xke+4jyBFdmVudCBcIiR7cmVzdWx0LnN1bW1hcnkgfHwgcmVzdWx0LmV2ZW50SWR9XCIgZGVsZXRlZC4gKFN0YXR1czogU1VDQ0VTUylgIC8vIFVzZSBldmVudElkIGlmIHN1bW1hcnkgd2Fzbid0IGZldGNoZWQvcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgOiBg4p2MIEZhaWxlZCB0byBkZWxldGUgZXZlbnQgJHtyZXN1bHQuZXZlbnRJZCB8fCAnPyd9OiAke3Jlc3VsdC5lcnJvciB8fCByZXN1bHQubWVzc2FnZSB8fCAnPyd9IChTdGF0dXM6IEZBSUxFRClgO1xuXG4gICAgICAgICAgICBjYXNlICd1cGRhdGVDYWxlbmRhckV2ZW50JzpcbiAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcmVzdWx0IGhhcyBhbiBJRCwgaW5kaWNhdGluZyBzdWNjZXNzIGZyb20gZ29vZ2xlQ2FsZW5kYXIgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1Y2Nlc3NNc2cgPSBg4pyP77iPIEV2ZW50IFwiJHtyZXN1bHQuc3VtbWFyeSB8fCByZXN1bHQuaWR9XCIgdXBkYXRlZC4gKElEOiAke3Jlc3VsdC5pZH0pYDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHByaW9yaXR5IGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzTXNnICs9IGAgW1ByaW9yaXR5OiAke3Jlc3VsdC5wcmlvcml0eX1dYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzTXNnICs9IFwiIChTdGF0dXM6IFNVQ0NFU1MpXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzTXNnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBwb3RlbnRpYWwgZXJyb3Igb2JqZWN0cyBwYXNzZWQgYmFja1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9IHJlc3VsdD8uZXJyb3IgfHwgcmVzdWx0Py5tZXNzYWdlIHx8IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBg4p2MIEZhaWxlZCB0byB1cGRhdGUgZXZlbnQ6ICR7ZXJyb3JNc2d9IChTdGF0dXM6IEZBSUxFRClgO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZmluZEF2YWlsYWJsZVNsb3RzJzpcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IEludmFsaWQgZmluZEF2YWlsYWJsZVNsb3RzIHJlc3BvbnNlLiAoU3RhdHVzOiBGQUlMRUQpXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBg8J+VkiBObyBhdmFpbGFibGUgc2xvdHMgZm91bmQgbWF0Y2hpbmcgY3JpdGVyaWEuIChTdGF0dXM6IFNVQ0NFU1MpYDtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgc2xvdHMgd2l0aCBzdWNjZXNzIHN0YXR1c1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFNsb3RzID0gcmVzdWx0Lm1hcChzbG90ID0+XG4gICAgICAgICAgICAgICAgICAgIGAke0RhdGVUaW1lLmZyb21JU08oc2xvdC5zdGFydCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfU0hPUlQpfSAtICR7RGF0ZVRpbWUuZnJvbUlTTyhzbG90LmVuZCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpfWBcbiAgICAgICAgICAgICAgICApLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBg8J+VkiBGb3VuZCAke3Jlc3VsdC5sZW5ndGh9IGF2YWlsYWJsZSBzbG90KHMpOlxcblxcbiR7Zm9ybWF0dGVkU2xvdHN9XFxuXFxuKFN0YXR1czogU1VDQ0VTUylgO1xuXG4gICAgICAgICAgICBjYXNlICdnZXRXZWF0aGVyRm9yZWNhc3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBg8J+MpO+4jyBXZWF0aGVyIGZvciAke3Jlc3VsdC5sb2NhdGlvbn0gb24gJHtyZXN1bHQuZGF0ZX06ICR7cmVzdWx0LmZvcmVjYXN0IHx8ICdOL0EnfSAoU3RhdHVzOiAke3Jlc3VsdC5mb3JlY2FzdCAmJiAhcmVzdWx0LmZvcmVjYXN0LmluY2x1ZGVzKCd1bmF2YWlsYWJsZScpID8gJ1NVQ0NFU1MnIDogJ1BBUlRJQUwnfSlgO1xuXG4gICAgICAgICAgICBjYXNlICdkZWxldGVDYWxlbmRhckV2ZW50c0J5UXVlcnknOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICA/IGDwn5eR77iPICR7cmVzdWx0Lm1lc3NhZ2V9IChEZWxldGVkIENvdW50OiAke3Jlc3VsdC5kZWxldGVkQ291bnR9KSAoU3RhdHVzOiBTVUNDRVNTKWBcbiAgICAgICAgICAgICAgICAgICAgOiBg4p2MIEZhaWxlZCBidWxrIGRlbGV0ZTogJHtyZXN1bHQubWVzc2FnZSB8fCByZXN1bHQuZXJyb3IgfHwgJz8nfSAoU3RhdHVzOiBGQUlMRUQpYDtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBTYWZlbHkgc3RyaW5naWZ5IG90aGVyIHJlc3VsdHMgd2l0aCBzdGF0dXMgaW5kaWNhdG9yc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzdWx0LnN1Y2Nlc3MgPT09IHRydWUgPyAnU1VDQ0VTUycgOiAocmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlID8gJ0ZBSUxFRCcgOiAnVU5LTk9XTicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX0gKFN0YXR1czogJHtzdGF0dXN9KWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke1N0cmluZyhyZXN1bHQpfSAoU3RhdHVzOiBVTktOT1dOKWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZm9ybWF0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQ1JJVElDQUw6IEVycm9yICp3aXRoaW4qIGZvcm1hdFRvb2xSZXNwb25zZSBmb3IgJHtmdW5jdGlvbk5hbWV9OmAsIGZvcm1hdEVycm9yLCBcIlJhdyByZXN1bHQ6XCIsIHJlc3VsdCk7XG4gICAgICAgIC8vIFJldHVybiBhIGd1YXJhbnRlZWQgc3RyaW5nIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgcmV0dXJuIGBJbnRlcm5hbCBFcnJvcjogRmFpbGVkIHRvIGZvcm1hdCB0aGUgcmVzdWx0IGZvciAke2Z1bmN0aW9uTmFtZX0uIChTdGF0dXM6IEVSUk9SKWA7XG4gICAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIGZ1bmN0aW9uc1xuZXhwb3J0IHsgZm9ybWF0RXZlbnRUaW1lLCBmb3JtYXRDYWxlbmRhckV2ZW50cywgZm9ybWF0VG9vbFJlc3BvbnNlIH07XG4iXSwibmFtZXMiOlsiRGF0ZVRpbWUiLCJmb3JtYXRFdmVudFRpbWUiLCJldmVudFRpbWUiLCJkdCIsImZyb21JU08iLCJpc1ZhbGlkIiwidG9Mb2NhbGVTdHJpbmciLCJEQVRFVElNRV9GVUxMIiwiZGF0ZU9ubHkiLCJ6b25lIiwiREFURV9GVUxMIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwiU3RyaW5nIiwiZm9ybWF0Q2FsZW5kYXJFdmVudHMiLCJldmVudHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJtYXAiLCJldmVudCIsInN0YXJ0IiwiZGF0ZVRpbWUiLCJkYXRlIiwiZW5kIiwiZGV2ZW50Iiwic3VtbWFyeSIsImlkIiwiaXNBbGxEYXkiLCJmb3JtYXR0ZWRFdmVudCIsIlRJTUVfU0lNUExFIiwiZGVzY3JpcHRpb24iLCJsb2NhdGlvbiIsInJlbWluZGVycyIsInVzZURlZmF1bHQiLCJvdmVycmlkZXMiLCJyIiwibWludXRlcyIsImpvaW4iLCJwcmlvcml0eSIsInRhZ3MiLCJ0cmltIiwibWFwRXJyb3IiLCJlcnJvciIsImZvcm1hdFRvb2xSZXNwb25zZSIsImZ1bmN0aW9uTmFtZSIsInJlc3VsdCIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwiaXRlbSIsImNvbmZsaWN0Iiwic3VnZ2VzdGlvblRleHQiLCJzdWdnZXN0aW9ucyIsInMiLCJ0b0Zvcm1hdCIsInN0YXJ0U3RyIiwic3VjY2Vzc01zZyIsInByaW9yaXR5SW5mbyIsInNvbWUiLCJ0ZXh0RGVzY3JpcHRpb24iLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0VGltZW91dCIsImdsb2JhbCIsImN1cnJlbnRSZXNwb25zZUNhbGxiYWNrIiwidHlwZSIsImNvbnRlbnQiLCJldmVudElkIiwiZXJyb3JNc2ciLCJmb3JtYXR0ZWRTbG90cyIsInNsb3QiLCJEQVRFVElNRV9TSE9SVCIsImZvcmVjYXN0IiwiaW5jbHVkZXMiLCJkZWxldGVkQ291bnQiLCJzdGF0dXMiLCJmb3JtYXRFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/tools/formatters.js\n");

/***/ }),

/***/ "(api)/./lib/tools/schedulingUtils.js":
/*!**************************************!*\
  !*** ./lib/tools/schedulingUtils.js ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAvailableSlots: () => (/* binding */ findAvailableSlots),\n/* harmony export */   formatAvailableSlots: () => (/* binding */ formatAvailableSlots)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__]);\nluxon__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * Default working hours configuration\n * Can be extended to fetch from user preferences in the future\n */ const DEFAULT_WORKING_HOURS = {\n    start: 9,\n    end: 17,\n    workDays: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ]\n};\n/**\n * Find available time slots for a new event\n * @param {Array} events - List of calendar events\n * @param {number} duration - Duration of the event in minutes\n * @param {string} startDate - Start date to search from in ISO format\n * @param {string} endDate - End date to search until in ISO format\n * @param {string} activity - Type of activity being scheduled\n * @param {string} timePreference - Preferred time of day (morning, afternoon, evening, any)\n * @param {Object} workingHours - Optional working hours configuration\n * @returns {Array} - List of available time slots with pros and cons\n */ function findAvailableSlots(events, duration, startDate, endDate, activity, timePreference = \"any\", workingHours = DEFAULT_WORKING_HOURS) {\n    // Convert inputs to Luxon objects\n    const start = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(startDate);\n    const end = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(endDate);\n    const durationMinutes = duration;\n    // Create a list of busy intervals from events\n    const busyIntervals = events.map((event)=>{\n        const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start.dateTime || event.start.date);\n        const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end.dateTime || event.end.date);\n        return {\n            interval: luxon__WEBPACK_IMPORTED_MODULE_0__.Interval.fromDateTimes(eventStart, eventEnd),\n            summary: event.summary\n        };\n    });\n    // Generate potential slots\n    const slots = generatePotentialSlots(start, end, durationMinutes, busyIntervals, timePreference, workingHours);\n    // Evaluate and rank slots\n    const evaluatedSlots = evaluateSlots(slots, busyIntervals, durationMinutes, activity, timePreference);\n    // Return top slots (limited to 3)\n    return evaluatedSlots.slice(0, 3);\n}\n/**\n * Generate potential time slots based on constraints\n * @param {DateTime} start - Start date/time to search from\n * @param {DateTime} end - End date/time to search until\n * @param {number} durationMinutes - Duration in minutes\n * @param {Array} busyIntervals - List of busy time intervals\n * @param {string} timePreference - Preferred time of day\n * @param {Object} workingHours - Working hours configuration\n * @returns {Array} - List of potential time slots\n */ function generatePotentialSlots(start, end, durationMinutes, busyIntervals, timePreference, workingHours) {\n    const slots = [];\n    const slotDuration = luxon__WEBPACK_IMPORTED_MODULE_0__.Duration.fromObject({\n        minutes: durationMinutes\n    });\n    // Start from the beginning of the search period\n    let currentTime = start;\n    // Iterate through each day in the search period\n    while(currentTime < end){\n        // Check if this is a working day\n        const isWorkingDay = workingHours.workDays.includes(currentTime.weekday);\n        if (isWorkingDay) {\n            // Set start time to either current time or beginning of working hours\n            let dayStart = currentTime.set({\n                hour: workingHours.start,\n                minute: 0,\n                second: 0,\n                millisecond: 0\n            });\n            // If we're already past the working hours start for today, use current time\n            if (currentTime > dayStart) {\n                dayStart = currentTime;\n            }\n            // End of working hours for today\n            const dayEnd = currentTime.set({\n                hour: workingHours.end,\n                minute: 0,\n                second: 0,\n                millisecond: 0\n            });\n            // Generate slots for this day\n            let slotStart = dayStart;\n            // Use 30-minute increments for slot generation\n            while(slotStart.plus(slotDuration) <= dayEnd){\n                const slotEnd = slotStart.plus(slotDuration);\n                const currentSlot = luxon__WEBPACK_IMPORTED_MODULE_0__.Interval.fromDateTimes(slotStart, slotEnd);\n                // Check if this slot overlaps with any busy intervals\n                const isAvailable = !busyIntervals.some((busy)=>busy.interval.overlaps(currentSlot));\n                if (isAvailable) {\n                    // Check if this slot matches the time preference\n                    const hour = slotStart.hour;\n                    let matchesPreference = true;\n                    if (timePreference === \"morning\" && (hour < 8 || hour >= 12)) {\n                        matchesPreference = false;\n                    } else if (timePreference === \"afternoon\" && (hour < 12 || hour >= 17)) {\n                        matchesPreference = false;\n                    } else if (timePreference === \"evening\" && (hour < 17 || hour >= 21)) {\n                        matchesPreference = false;\n                    }\n                    if (matchesPreference) {\n                        slots.push({\n                            start: slotStart.toISO(),\n                            end: slotEnd.toISO(),\n                            startDateTime: slotStart,\n                            endDateTime: slotEnd\n                        });\n                    }\n                }\n                // Move to next slot (30-minute increments)\n                slotStart = slotStart.plus({\n                    minutes: 30\n                });\n            }\n        }\n        // Move to next day\n        currentTime = currentTime.plus({\n            days: 1\n        }).startOf(\"day\");\n    }\n    return slots;\n}\n/**\n * Evaluate and rank available time slots\n * @param {Array} slots - List of potential time slots\n * @param {Array} busyIntervals - List of busy time intervals\n * @param {number} durationMinutes - Duration in minutes\n * @param {string} activity - Type of activity\n * @param {string} timePreference - Preferred time of day\n * @returns {Array} - Evaluated and ranked slots with pros and cons\n */ function evaluateSlots(slots, busyIntervals, durationMinutes, activity, timePreference) {\n    return slots.map((slot)=>{\n        const slotStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.start);\n        const slotEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.end);\n        const slotInterval = luxon__WEBPACK_IMPORTED_MODULE_0__.Interval.fromDateTimes(slotStart, slotEnd);\n        // Generate pros and cons\n        const { pros, cons } = generateProsAndCons(slotStart, slotEnd, busyIntervals, activity, timePreference);\n        // Calculate a score based on pros and cons\n        const score = calculateScore(slotStart, pros, cons, timePreference);\n        return {\n            start: slot.start,\n            end: slot.end,\n            pros,\n            cons,\n            score\n        };\n    })// Sort by score (highest first)\n    .sort((a, b)=>b.score - a.score);\n}\n/**\n * Generate pros and cons for a time slot\n * @param {DateTime} slotStart - Start time of the slot\n * @param {DateTime} slotEnd - End time of the slot\n * @param {Array} busyIntervals - List of busy time intervals\n * @param {string} activity - Type of activity\n * @param {string} timePreference - Preferred time of day\n * @returns {Object} - Object containing pros and cons arrays\n */ function generateProsAndCons(slotStart, slotEnd, busyIntervals, activity, timePreference) {\n    const pros = [];\n    const cons = [];\n    // Time of day factors\n    const hour = slotStart.hour;\n    // Check if slot is during preferred time\n    if (timePreference === \"morning\" && hour >= 8 && hour < 12) {\n        pros.push(\"Matches your morning time preference\");\n    } else if (timePreference === \"afternoon\" && hour >= 12 && hour < 17) {\n        pros.push(\"Matches your afternoon time preference\");\n    } else if (timePreference === \"evening\" && hour >= 17 && hour < 21) {\n        pros.push(\"Matches your evening time preference\");\n    } else if (timePreference !== \"any\") {\n        cons.push(`Outside your preferred ${timePreference} time`);\n    }\n    // Early morning/late evening factors\n    if (hour < 8) {\n        cons.push(\"Early morning slot may be difficult to attend\");\n    } else if (hour >= 20) {\n        cons.push(\"Late evening slot may interfere with personal time\");\n    }\n    // Ideal working hours\n    if (hour >= 9 && hour < 17) {\n        pros.push(\"During standard working hours\");\n    }\n    // Lunch time\n    if (hour >= 12 && hour < 14) {\n        if (activity.toLowerCase().includes(\"lunch\") || activity.toLowerCase().includes(\"meal\") || activity.toLowerCase().includes(\"eat\")) {\n            pros.push(\"Ideal time for a meal\");\n        } else {\n            cons.push(\"May conflict with lunch time\");\n        }\n    }\n    // Proximity to other events\n    const bufferTime = luxon__WEBPACK_IMPORTED_MODULE_0__.Duration.fromObject({\n        minutes: 30\n    });\n    let hasEventBefore = false;\n    let hasEventAfter = false;\n    for (const busy of busyIntervals){\n        const busyEnd = busy.interval.end;\n        const busyStart = busy.interval.start;\n        // Check if there's an event ending right before this slot\n        if (busyEnd <= slotStart && busyEnd.plus(bufferTime) >= slotStart) {\n            hasEventBefore = true;\n            pros.push(`Convenient timing after \"${busy.summary}\"`);\n        }\n        // Check if there's an event starting right after this slot\n        if (busyStart >= slotEnd && busyStart.minus(bufferTime) <= slotEnd) {\n            hasEventAfter = true;\n            pros.push(`Convenient timing before \"${busy.summary}\"`);\n        }\n    }\n    // If the slot is sandwiched between events\n    if (hasEventBefore && hasEventAfter) {\n        pros.push(\"Efficiently uses gap between events\");\n    }\n    // Day of week factors\n    const dayOfWeek = slotStart.weekday;\n    if (dayOfWeek === 1) {\n        if (hour < 11) {\n            cons.push(\"Early Monday morning may be busy with weekly planning\");\n        } else {\n            pros.push(\"Good for setting the tone for the week\");\n        }\n    } else if (dayOfWeek === 5) {\n        if (hour >= 15) {\n            cons.push(\"Late Friday may conflict with weekend plans\");\n        } else {\n            pros.push(\"Good for wrapping up the week\");\n        }\n    } else if (dayOfWeek === 6 || dayOfWeek === 7) {\n        if (activity.toLowerCase().includes(\"work\") || activity.toLowerCase().includes(\"meeting\") || activity.toLowerCase().includes(\"call\")) {\n            cons.push(\"Weekend slot for work-related activity\");\n        } else {\n            pros.push(\"Weekend slot good for personal activities\");\n        }\n    }\n    // Activity-specific factors\n    if (activity.toLowerCase().includes(\"exercise\") || activity.toLowerCase().includes(\"workout\") || activity.toLowerCase().includes(\"gym\")) {\n        if (hour >= 6 && hour < 9) {\n            pros.push(\"Morning exercise can boost energy for the day\");\n        } else if (hour >= 17 && hour < 20) {\n            pros.push(\"Evening exercise can help unwind after work\");\n        }\n    }\n    // Ensure we have at least one pro and con\n    if (pros.length === 0) {\n        pros.push(\"Available time slot that fits your schedule\");\n    }\n    if (cons.length === 0) {\n        // Look for any minor drawback\n        if (slotStart.minute !== 0 && slotStart.minute !== 30) {\n            cons.push(\"Starts at an unusual time\");\n        } else if (dayOfWeek >= 1 && dayOfWeek <= 5 && (hour < 9 || hour >= 17)) {\n            cons.push(\"Outside standard working hours\");\n        } else {\n            cons.push(\"No significant drawbacks identified\");\n        }\n    }\n    return {\n        pros,\n        cons\n    };\n}\n/**\n * Calculate a score for ranking time slots\n * @param {DateTime} slotStart - Start time of the slot\n * @param {Array} pros - List of pros\n * @param {Array} cons - List of cons\n * @param {string} timePreference - Preferred time of day\n * @returns {number} - Score for ranking\n */ function calculateScore(slotStart, pros, cons, timePreference) {\n    let score = 0;\n    // Base score from pros and cons count\n    score += pros.length * 10;\n    score -= cons.length * 8;\n    // Preferred time bonus\n    const hour = slotStart.hour;\n    if (timePreference === \"morning\" && hour >= 8 && hour < 12) {\n        score += 15;\n    } else if (timePreference === \"afternoon\" && hour >= 12 && hour < 17) {\n        score += 15;\n    } else if (timePreference === \"evening\" && hour >= 17 && hour < 21) {\n        score += 15;\n    }\n    // Ideal working hours bonus\n    if (hour >= 9 && hour < 17) {\n        score += 5;\n    }\n    // Prefer earlier slots when all else is equal (for consistent sorting)\n    score -= slotStart.hour * 0.1;\n    return score;\n}\n/**\n * Format available slots for display\n * @param {Array} slots - List of available slots with pros and cons\n * @returns {string} - Formatted string for display\n */ function formatAvailableSlots(slots) {\n    if (!slots || slots.length === 0) {\n        return \"No available slots found.\";\n    }\n    let result = \"Available time slots:\\n\\n\";\n    slots.forEach((slot, index)=>{\n        const start = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.start);\n        const end = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(slot.end);\n        result += `Option ${index + 1}: ${start.toFormat(\"ccc, LLL d\")} from ${start.toFormat(\"h:mm a\")} to ${end.toFormat(\"h:mm a\")}\\n`;\n        result += \"Pros:\\n\";\n        slot.pros.forEach((pro)=>{\n            result += `- ${pro}\\n`;\n        });\n        result += \"Cons:\\n\";\n        slot.cons.forEach((con)=>{\n            result += `- ${con}\\n`;\n        });\n        if (index < slots.length - 1) {\n            result += \"\\n\";\n        }\n    });\n    return result;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBSztJQUN4QyxJQUFJLENBQUNBLFNBQVNBLE1BQU1vRCxNQUFNLEtBQUssR0FBRztRQUNoQyxPQUFPO0lBQ1Q7SUFFQSxJQUFJRSxTQUFTO0lBRWJ0RCxNQUFNdUQsT0FBTyxDQUFDLENBQUNyQixNQUFNc0I7UUFDbkIsTUFBTS9FLFFBQVFKLDJDQUFRQSxDQUFDZSxPQUFPLENBQUM4QyxLQUFLekQsS0FBSztRQUN6QyxNQUFNQyxNQUFNTCwyQ0FBUUEsQ0FBQ2UsT0FBTyxDQUFDOEMsS0FBS3hELEdBQUc7UUFFckM0RSxVQUFVLENBQUMsT0FBTyxFQUFFRSxRQUFRLEVBQUUsRUFBRSxFQUFFL0UsTUFBTWdGLFFBQVEsQ0FBQyxjQUFjLE1BQU0sRUFBRWhGLE1BQU1nRixRQUFRLENBQUMsVUFBVSxJQUFJLEVBQUUvRSxJQUFJK0UsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRWhJSCxVQUFVO1FBQ1ZwQixLQUFLRSxJQUFJLENBQUNtQixPQUFPLENBQUNHLENBQUFBO1lBQ2hCSixVQUFVLENBQUMsRUFBRSxFQUFFSSxJQUFJLEVBQUUsQ0FBQztRQUN4QjtRQUVBSixVQUFVO1FBQ1ZwQixLQUFLRyxJQUFJLENBQUNrQixPQUFPLENBQUNJLENBQUFBO1lBQ2hCTCxVQUFVLENBQUMsRUFBRSxFQUFFSyxJQUFJLEVBQUUsQ0FBQztRQUN4QjtRQUVBLElBQUlILFFBQVF4RCxNQUFNb0QsTUFBTSxHQUFHLEdBQUc7WUFDNUJFLFVBQVU7UUFDWjtJQUNGO0lBRUEsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi90b29scy9zY2hlZHVsaW5nVXRpbHMuanM/ZDBmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRlVGltZSwgSW50ZXJ2YWwsIER1cmF0aW9uIH0gZnJvbSAnbHV4b24nO1xuXG4vKipcbiAqIERlZmF1bHQgd29ya2luZyBob3VycyBjb25maWd1cmF0aW9uXG4gKiBDYW4gYmUgZXh0ZW5kZWQgdG8gZmV0Y2ggZnJvbSB1c2VyIHByZWZlcmVuY2VzIGluIHRoZSBmdXR1cmVcbiAqL1xuY29uc3QgREVGQVVMVF9XT1JLSU5HX0hPVVJTID0ge1xuICBzdGFydDogOSwgLy8gOSBBTVxuICBlbmQ6IDE3LCAgLy8gNSBQTVxuICB3b3JrRGF5czogWzEsIDIsIDMsIDQsIDVdLCAvLyBNb25kYXkgdG8gRnJpZGF5ICgxLTUpXG59O1xuXG4vKipcbiAqIEZpbmQgYXZhaWxhYmxlIHRpbWUgc2xvdHMgZm9yIGEgbmV3IGV2ZW50XG4gKiBAcGFyYW0ge0FycmF5fSBldmVudHMgLSBMaXN0IG9mIGNhbGVuZGFyIGV2ZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gRHVyYXRpb24gb2YgdGhlIGV2ZW50IGluIG1pbnV0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydERhdGUgLSBTdGFydCBkYXRlIHRvIHNlYXJjaCBmcm9tIGluIElTTyBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmREYXRlIC0gRW5kIGRhdGUgdG8gc2VhcmNoIHVudGlsIGluIElTTyBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpdml0eSAtIFR5cGUgb2YgYWN0aXZpdHkgYmVpbmcgc2NoZWR1bGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZVByZWZlcmVuY2UgLSBQcmVmZXJyZWQgdGltZSBvZiBkYXkgKG1vcm5pbmcsIGFmdGVybm9vbiwgZXZlbmluZywgYW55KVxuICogQHBhcmFtIHtPYmplY3R9IHdvcmtpbmdIb3VycyAtIE9wdGlvbmFsIHdvcmtpbmcgaG91cnMgY29uZmlndXJhdGlvblxuICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgYXZhaWxhYmxlIHRpbWUgc2xvdHMgd2l0aCBwcm9zIGFuZCBjb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQXZhaWxhYmxlU2xvdHMoXG4gIGV2ZW50cywgXG4gIGR1cmF0aW9uLCBcbiAgc3RhcnREYXRlLCBcbiAgZW5kRGF0ZSwgXG4gIGFjdGl2aXR5LCBcbiAgdGltZVByZWZlcmVuY2UgPSAnYW55JyxcbiAgd29ya2luZ0hvdXJzID0gREVGQVVMVF9XT1JLSU5HX0hPVVJTXG4pIHtcbiAgLy8gQ29udmVydCBpbnB1dHMgdG8gTHV4b24gb2JqZWN0c1xuICBjb25zdCBzdGFydCA9IERhdGVUaW1lLmZyb21JU08oc3RhcnREYXRlKTtcbiAgY29uc3QgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlbmREYXRlKTtcbiAgY29uc3QgZHVyYXRpb25NaW51dGVzID0gZHVyYXRpb247XG4gIFxuICAvLyBDcmVhdGUgYSBsaXN0IG9mIGJ1c3kgaW50ZXJ2YWxzIGZyb20gZXZlbnRzXG4gIGNvbnN0IGJ1c3lJbnRlcnZhbHMgPSBldmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICBjb25zdCBldmVudFN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5zdGFydC5kYXRlVGltZSB8fCBldmVudC5zdGFydC5kYXRlKTtcbiAgICBjb25zdCBldmVudEVuZCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuZW5kLmRhdGVUaW1lIHx8IGV2ZW50LmVuZC5kYXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJ2YWw6IEludGVydmFsLmZyb21EYXRlVGltZXMoZXZlbnRTdGFydCwgZXZlbnRFbmQpLFxuICAgICAgc3VtbWFyeTogZXZlbnQuc3VtbWFyeVxuICAgIH07XG4gIH0pO1xuICBcbiAgLy8gR2VuZXJhdGUgcG90ZW50aWFsIHNsb3RzXG4gIGNvbnN0IHNsb3RzID0gZ2VuZXJhdGVQb3RlbnRpYWxTbG90cyhcbiAgICBzdGFydCwgXG4gICAgZW5kLCBcbiAgICBkdXJhdGlvbk1pbnV0ZXMsIFxuICAgIGJ1c3lJbnRlcnZhbHMsIFxuICAgIHRpbWVQcmVmZXJlbmNlLFxuICAgIHdvcmtpbmdIb3Vyc1xuICApO1xuICBcbiAgLy8gRXZhbHVhdGUgYW5kIHJhbmsgc2xvdHNcbiAgY29uc3QgZXZhbHVhdGVkU2xvdHMgPSBldmFsdWF0ZVNsb3RzKFxuICAgIHNsb3RzLCBcbiAgICBidXN5SW50ZXJ2YWxzLCBcbiAgICBkdXJhdGlvbk1pbnV0ZXMsIFxuICAgIGFjdGl2aXR5LCBcbiAgICB0aW1lUHJlZmVyZW5jZVxuICApO1xuICBcbiAgLy8gUmV0dXJuIHRvcCBzbG90cyAobGltaXRlZCB0byAzKVxuICByZXR1cm4gZXZhbHVhdGVkU2xvdHMuc2xpY2UoMCwgMyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgcG90ZW50aWFsIHRpbWUgc2xvdHMgYmFzZWQgb24gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IHN0YXJ0IC0gU3RhcnQgZGF0ZS90aW1lIHRvIHNlYXJjaCBmcm9tXG4gKiBAcGFyYW0ge0RhdGVUaW1lfSBlbmQgLSBFbmQgZGF0ZS90aW1lIHRvIHNlYXJjaCB1bnRpbFxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uTWludXRlcyAtIER1cmF0aW9uIGluIG1pbnV0ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1c3lJbnRlcnZhbHMgLSBMaXN0IG9mIGJ1c3kgdGltZSBpbnRlcnZhbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lUHJlZmVyZW5jZSAtIFByZWZlcnJlZCB0aW1lIG9mIGRheVxuICogQHBhcmFtIHtPYmplY3R9IHdvcmtpbmdIb3VycyAtIFdvcmtpbmcgaG91cnMgY29uZmlndXJhdGlvblxuICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgcG90ZW50aWFsIHRpbWUgc2xvdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQb3RlbnRpYWxTbG90cyhcbiAgc3RhcnQsIFxuICBlbmQsIFxuICBkdXJhdGlvbk1pbnV0ZXMsIFxuICBidXN5SW50ZXJ2YWxzLCBcbiAgdGltZVByZWZlcmVuY2UsXG4gIHdvcmtpbmdIb3Vyc1xuKSB7XG4gIGNvbnN0IHNsb3RzID0gW107XG4gIGNvbnN0IHNsb3REdXJhdGlvbiA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiBkdXJhdGlvbk1pbnV0ZXMgfSk7XG4gIFxuICAvLyBTdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlYXJjaCBwZXJpb2RcbiAgbGV0IGN1cnJlbnRUaW1lID0gc3RhcnQ7XG4gIFxuICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBkYXkgaW4gdGhlIHNlYXJjaCBwZXJpb2RcbiAgd2hpbGUgKGN1cnJlbnRUaW1lIDwgZW5kKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHdvcmtpbmcgZGF5XG4gICAgY29uc3QgaXNXb3JraW5nRGF5ID0gd29ya2luZ0hvdXJzLndvcmtEYXlzLmluY2x1ZGVzKGN1cnJlbnRUaW1lLndlZWtkYXkpO1xuICAgIFxuICAgIGlmIChpc1dvcmtpbmdEYXkpIHtcbiAgICAgIC8vIFNldCBzdGFydCB0aW1lIHRvIGVpdGhlciBjdXJyZW50IHRpbWUgb3IgYmVnaW5uaW5nIG9mIHdvcmtpbmcgaG91cnNcbiAgICAgIGxldCBkYXlTdGFydCA9IGN1cnJlbnRUaW1lLnNldCh7IFxuICAgICAgICBob3VyOiB3b3JraW5nSG91cnMuc3RhcnQsIFxuICAgICAgICBtaW51dGU6IDAsIFxuICAgICAgICBzZWNvbmQ6IDAsIFxuICAgICAgICBtaWxsaXNlY29uZDogMCBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHBhc3QgdGhlIHdvcmtpbmcgaG91cnMgc3RhcnQgZm9yIHRvZGF5LCB1c2UgY3VycmVudCB0aW1lXG4gICAgICBpZiAoY3VycmVudFRpbWUgPiBkYXlTdGFydCkge1xuICAgICAgICBkYXlTdGFydCA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbmQgb2Ygd29ya2luZyBob3VycyBmb3IgdG9kYXlcbiAgICAgIGNvbnN0IGRheUVuZCA9IGN1cnJlbnRUaW1lLnNldCh7IFxuICAgICAgICBob3VyOiB3b3JraW5nSG91cnMuZW5kLCBcbiAgICAgICAgbWludXRlOiAwLCBcbiAgICAgICAgc2Vjb25kOiAwLCBcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDAgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgc2xvdHMgZm9yIHRoaXMgZGF5XG4gICAgICBsZXQgc2xvdFN0YXJ0ID0gZGF5U3RhcnQ7XG4gICAgICBcbiAgICAgIC8vIFVzZSAzMC1taW51dGUgaW5jcmVtZW50cyBmb3Igc2xvdCBnZW5lcmF0aW9uXG4gICAgICB3aGlsZSAoc2xvdFN0YXJ0LnBsdXMoc2xvdER1cmF0aW9uKSA8PSBkYXlFbmQpIHtcbiAgICAgICAgY29uc3Qgc2xvdEVuZCA9IHNsb3RTdGFydC5wbHVzKHNsb3REdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbG90ID0gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzbG90U3RhcnQsIHNsb3RFbmQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzbG90IG92ZXJsYXBzIHdpdGggYW55IGJ1c3kgaW50ZXJ2YWxzXG4gICAgICAgIGNvbnN0IGlzQXZhaWxhYmxlID0gIWJ1c3lJbnRlcnZhbHMuc29tZShidXN5ID0+IFxuICAgICAgICAgIGJ1c3kuaW50ZXJ2YWwub3ZlcmxhcHMoY3VycmVudFNsb3QpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHNsb3QgbWF0Y2hlcyB0aGUgdGltZSBwcmVmZXJlbmNlXG4gICAgICAgICAgY29uc3QgaG91ciA9IHNsb3RTdGFydC5ob3VyO1xuICAgICAgICAgIGxldCBtYXRjaGVzUHJlZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRpbWVQcmVmZXJlbmNlID09PSAnbW9ybmluZycgJiYgKGhvdXIgPCA4IHx8IGhvdXIgPj0gMTIpKSB7XG4gICAgICAgICAgICBtYXRjaGVzUHJlZmVyZW5jZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGltZVByZWZlcmVuY2UgPT09ICdhZnRlcm5vb24nICYmIChob3VyIDwgMTIgfHwgaG91ciA+PSAxNykpIHtcbiAgICAgICAgICAgIG1hdGNoZXNQcmVmZXJlbmNlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ2V2ZW5pbmcnICYmIChob3VyIDwgMTcgfHwgaG91ciA+PSAyMSkpIHtcbiAgICAgICAgICAgIG1hdGNoZXNQcmVmZXJlbmNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChtYXRjaGVzUHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgc2xvdHMucHVzaCh7XG4gICAgICAgICAgICAgIHN0YXJ0OiBzbG90U3RhcnQudG9JU08oKSxcbiAgICAgICAgICAgICAgZW5kOiBzbG90RW5kLnRvSVNPKCksXG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZVRpbWU6IHNsb3RTdGFydCxcbiAgICAgICAgICAgICAgZW5kRGF0ZVRpbWU6IHNsb3RFbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IHNsb3QgKDMwLW1pbnV0ZSBpbmNyZW1lbnRzKVxuICAgICAgICBzbG90U3RhcnQgPSBzbG90U3RhcnQucGx1cyh7IG1pbnV0ZXM6IDMwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBNb3ZlIHRvIG5leHQgZGF5XG4gICAgY3VycmVudFRpbWUgPSBjdXJyZW50VGltZS5wbHVzKHsgZGF5czogMSB9KS5zdGFydE9mKCdkYXknKTtcbiAgfVxuICBcbiAgcmV0dXJuIHNsb3RzO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIGFuZCByYW5rIGF2YWlsYWJsZSB0aW1lIHNsb3RzXG4gKiBAcGFyYW0ge0FycmF5fSBzbG90cyAtIExpc3Qgb2YgcG90ZW50aWFsIHRpbWUgc2xvdHNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1c3lJbnRlcnZhbHMgLSBMaXN0IG9mIGJ1c3kgdGltZSBpbnRlcnZhbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbk1pbnV0ZXMgLSBEdXJhdGlvbiBpbiBtaW51dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aXZpdHkgLSBUeXBlIG9mIGFjdGl2aXR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZVByZWZlcmVuY2UgLSBQcmVmZXJyZWQgdGltZSBvZiBkYXlcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBFdmFsdWF0ZWQgYW5kIHJhbmtlZCBzbG90cyB3aXRoIHByb3MgYW5kIGNvbnNcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVTbG90cyhzbG90cywgYnVzeUludGVydmFscywgZHVyYXRpb25NaW51dGVzLCBhY3Rpdml0eSwgdGltZVByZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHNsb3RzLm1hcChzbG90ID0+IHtcbiAgICBjb25zdCBzbG90U3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHNsb3Quc3RhcnQpO1xuICAgIGNvbnN0IHNsb3RFbmQgPSBEYXRlVGltZS5mcm9tSVNPKHNsb3QuZW5kKTtcbiAgICBjb25zdCBzbG90SW50ZXJ2YWwgPSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHNsb3RTdGFydCwgc2xvdEVuZCk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgcHJvcyBhbmQgY29uc1xuICAgIGNvbnN0IHsgcHJvcywgY29ucyB9ID0gZ2VuZXJhdGVQcm9zQW5kQ29ucyhcbiAgICAgIHNsb3RTdGFydCwgXG4gICAgICBzbG90RW5kLCBcbiAgICAgIGJ1c3lJbnRlcnZhbHMsIFxuICAgICAgYWN0aXZpdHksIFxuICAgICAgdGltZVByZWZlcmVuY2VcbiAgICApO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBhIHNjb3JlIGJhc2VkIG9uIHByb3MgYW5kIGNvbnNcbiAgICBjb25zdCBzY29yZSA9IGNhbGN1bGF0ZVNjb3JlKHNsb3RTdGFydCwgcHJvcywgY29ucywgdGltZVByZWZlcmVuY2UpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogc2xvdC5zdGFydCxcbiAgICAgIGVuZDogc2xvdC5lbmQsXG4gICAgICBwcm9zLFxuICAgICAgY29ucyxcbiAgICAgIHNjb3JlXG4gICAgfTtcbiAgfSlcbiAgLy8gU29ydCBieSBzY29yZSAoaGlnaGVzdCBmaXJzdClcbiAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBwcm9zIGFuZCBjb25zIGZvciBhIHRpbWUgc2xvdFxuICogQHBhcmFtIHtEYXRlVGltZX0gc2xvdFN0YXJ0IC0gU3RhcnQgdGltZSBvZiB0aGUgc2xvdFxuICogQHBhcmFtIHtEYXRlVGltZX0gc2xvdEVuZCAtIEVuZCB0aW1lIG9mIHRoZSBzbG90XG4gKiBAcGFyYW0ge0FycmF5fSBidXN5SW50ZXJ2YWxzIC0gTGlzdCBvZiBidXN5IHRpbWUgaW50ZXJ2YWxzXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aXZpdHkgLSBUeXBlIG9mIGFjdGl2aXR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZVByZWZlcmVuY2UgLSBQcmVmZXJyZWQgdGltZSBvZiBkYXlcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gT2JqZWN0IGNvbnRhaW5pbmcgcHJvcyBhbmQgY29ucyBhcnJheXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9zQW5kQ29ucyhzbG90U3RhcnQsIHNsb3RFbmQsIGJ1c3lJbnRlcnZhbHMsIGFjdGl2aXR5LCB0aW1lUHJlZmVyZW5jZSkge1xuICBjb25zdCBwcm9zID0gW107XG4gIGNvbnN0IGNvbnMgPSBbXTtcbiAgXG4gIC8vIFRpbWUgb2YgZGF5IGZhY3RvcnNcbiAgY29uc3QgaG91ciA9IHNsb3RTdGFydC5ob3VyO1xuICBcbiAgLy8gQ2hlY2sgaWYgc2xvdCBpcyBkdXJpbmcgcHJlZmVycmVkIHRpbWVcbiAgaWYgKHRpbWVQcmVmZXJlbmNlID09PSAnbW9ybmluZycgJiYgaG91ciA+PSA4ICYmIGhvdXIgPCAxMikge1xuICAgIHByb3MucHVzaCgnTWF0Y2hlcyB5b3VyIG1vcm5pbmcgdGltZSBwcmVmZXJlbmNlJyk7XG4gIH0gZWxzZSBpZiAodGltZVByZWZlcmVuY2UgPT09ICdhZnRlcm5vb24nICYmIGhvdXIgPj0gMTIgJiYgaG91ciA8IDE3KSB7XG4gICAgcHJvcy5wdXNoKCdNYXRjaGVzIHlvdXIgYWZ0ZXJub29uIHRpbWUgcHJlZmVyZW5jZScpO1xuICB9IGVsc2UgaWYgKHRpbWVQcmVmZXJlbmNlID09PSAnZXZlbmluZycgJiYgaG91ciA+PSAxNyAmJiBob3VyIDwgMjEpIHtcbiAgICBwcm9zLnB1c2goJ01hdGNoZXMgeW91ciBldmVuaW5nIHRpbWUgcHJlZmVyZW5jZScpO1xuICB9IGVsc2UgaWYgKHRpbWVQcmVmZXJlbmNlICE9PSAnYW55Jykge1xuICAgIGNvbnMucHVzaChgT3V0c2lkZSB5b3VyIHByZWZlcnJlZCAke3RpbWVQcmVmZXJlbmNlfSB0aW1lYCk7XG4gIH1cbiAgXG4gIC8vIEVhcmx5IG1vcm5pbmcvbGF0ZSBldmVuaW5nIGZhY3RvcnNcbiAgaWYgKGhvdXIgPCA4KSB7XG4gICAgY29ucy5wdXNoKCdFYXJseSBtb3JuaW5nIHNsb3QgbWF5IGJlIGRpZmZpY3VsdCB0byBhdHRlbmQnKTtcbiAgfSBlbHNlIGlmIChob3VyID49IDIwKSB7XG4gICAgY29ucy5wdXNoKCdMYXRlIGV2ZW5pbmcgc2xvdCBtYXkgaW50ZXJmZXJlIHdpdGggcGVyc29uYWwgdGltZScpO1xuICB9XG4gIFxuICAvLyBJZGVhbCB3b3JraW5nIGhvdXJzXG4gIGlmIChob3VyID49IDkgJiYgaG91ciA8IDE3KSB7XG4gICAgcHJvcy5wdXNoKCdEdXJpbmcgc3RhbmRhcmQgd29ya2luZyBob3VycycpO1xuICB9XG4gIFxuICAvLyBMdW5jaCB0aW1lXG4gIGlmIChob3VyID49IDEyICYmIGhvdXIgPCAxNCkge1xuICAgIGlmIChhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdsdW5jaCcpIHx8IFxuICAgICAgICBhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdtZWFsJykgfHwgXG4gICAgICAgIGFjdGl2aXR5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2VhdCcpKSB7XG4gICAgICBwcm9zLnB1c2goJ0lkZWFsIHRpbWUgZm9yIGEgbWVhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zLnB1c2goJ01heSBjb25mbGljdCB3aXRoIGx1bmNoIHRpbWUnKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFByb3hpbWl0eSB0byBvdGhlciBldmVudHNcbiAgY29uc3QgYnVmZmVyVGltZSA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAzMCB9KTtcbiAgbGV0IGhhc0V2ZW50QmVmb3JlID0gZmFsc2U7XG4gIGxldCBoYXNFdmVudEFmdGVyID0gZmFsc2U7XG4gIFxuICBmb3IgKGNvbnN0IGJ1c3kgb2YgYnVzeUludGVydmFscykge1xuICAgIGNvbnN0IGJ1c3lFbmQgPSBidXN5LmludGVydmFsLmVuZDtcbiAgICBjb25zdCBidXN5U3RhcnQgPSBidXN5LmludGVydmFsLnN0YXJ0O1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXZlbnQgZW5kaW5nIHJpZ2h0IGJlZm9yZSB0aGlzIHNsb3RcbiAgICBpZiAoYnVzeUVuZCA8PSBzbG90U3RhcnQgJiYgYnVzeUVuZC5wbHVzKGJ1ZmZlclRpbWUpID49IHNsb3RTdGFydCkge1xuICAgICAgaGFzRXZlbnRCZWZvcmUgPSB0cnVlO1xuICAgICAgcHJvcy5wdXNoKGBDb252ZW5pZW50IHRpbWluZyBhZnRlciBcIiR7YnVzeS5zdW1tYXJ5fVwiYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXZlbnQgc3RhcnRpbmcgcmlnaHQgYWZ0ZXIgdGhpcyBzbG90XG4gICAgaWYgKGJ1c3lTdGFydCA+PSBzbG90RW5kICYmIGJ1c3lTdGFydC5taW51cyhidWZmZXJUaW1lKSA8PSBzbG90RW5kKSB7XG4gICAgICBoYXNFdmVudEFmdGVyID0gdHJ1ZTtcbiAgICAgIHByb3MucHVzaChgQ29udmVuaWVudCB0aW1pbmcgYmVmb3JlIFwiJHtidXN5LnN1bW1hcnl9XCJgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIHRoZSBzbG90IGlzIHNhbmR3aWNoZWQgYmV0d2VlbiBldmVudHNcbiAgaWYgKGhhc0V2ZW50QmVmb3JlICYmIGhhc0V2ZW50QWZ0ZXIpIHtcbiAgICBwcm9zLnB1c2goJ0VmZmljaWVudGx5IHVzZXMgZ2FwIGJldHdlZW4gZXZlbnRzJyk7XG4gIH1cbiAgXG4gIC8vIERheSBvZiB3ZWVrIGZhY3RvcnNcbiAgY29uc3QgZGF5T2ZXZWVrID0gc2xvdFN0YXJ0LndlZWtkYXk7XG4gIFxuICBpZiAoZGF5T2ZXZWVrID09PSAxKSB7IC8vIE1vbmRheVxuICAgIGlmIChob3VyIDwgMTEpIHtcbiAgICAgIGNvbnMucHVzaCgnRWFybHkgTW9uZGF5IG1vcm5pbmcgbWF5IGJlIGJ1c3kgd2l0aCB3ZWVrbHkgcGxhbm5pbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcy5wdXNoKCdHb29kIGZvciBzZXR0aW5nIHRoZSB0b25lIGZvciB0aGUgd2VlaycpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXlPZldlZWsgPT09IDUpIHsgLy8gRnJpZGF5XG4gICAgaWYgKGhvdXIgPj0gMTUpIHtcbiAgICAgIGNvbnMucHVzaCgnTGF0ZSBGcmlkYXkgbWF5IGNvbmZsaWN0IHdpdGggd2Vla2VuZCBwbGFucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9zLnB1c2goJ0dvb2QgZm9yIHdyYXBwaW5nIHVwIHRoZSB3ZWVrJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRheU9mV2VlayA9PT0gNiB8fCBkYXlPZldlZWsgPT09IDcpIHsgLy8gV2Vla2VuZFxuICAgIGlmIChhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd3b3JrJykgfHwgXG4gICAgICAgIGFjdGl2aXR5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ21lZXRpbmcnKSB8fCBcbiAgICAgICAgYWN0aXZpdHkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY2FsbCcpKSB7XG4gICAgICBjb25zLnB1c2goJ1dlZWtlbmQgc2xvdCBmb3Igd29yay1yZWxhdGVkIGFjdGl2aXR5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3MucHVzaCgnV2Vla2VuZCBzbG90IGdvb2QgZm9yIHBlcnNvbmFsIGFjdGl2aXRpZXMnKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFjdGl2aXR5LXNwZWNpZmljIGZhY3RvcnNcbiAgaWYgKGFjdGl2aXR5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2V4ZXJjaXNlJykgfHwgXG4gICAgICBhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd3b3Jrb3V0JykgfHwgXG4gICAgICBhY3Rpdml0eS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdneW0nKSkge1xuICAgIGlmIChob3VyID49IDYgJiYgaG91ciA8IDkpIHtcbiAgICAgIHByb3MucHVzaCgnTW9ybmluZyBleGVyY2lzZSBjYW4gYm9vc3QgZW5lcmd5IGZvciB0aGUgZGF5Jyk7XG4gICAgfSBlbHNlIGlmIChob3VyID49IDE3ICYmIGhvdXIgPCAyMCkge1xuICAgICAgcHJvcy5wdXNoKCdFdmVuaW5nIGV4ZXJjaXNlIGNhbiBoZWxwIHVud2luZCBhZnRlciB3b3JrJyk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBFbnN1cmUgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgcHJvIGFuZCBjb25cbiAgaWYgKHByb3MubGVuZ3RoID09PSAwKSB7XG4gICAgcHJvcy5wdXNoKCdBdmFpbGFibGUgdGltZSBzbG90IHRoYXQgZml0cyB5b3VyIHNjaGVkdWxlJyk7XG4gIH1cbiAgXG4gIGlmIChjb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIExvb2sgZm9yIGFueSBtaW5vciBkcmF3YmFja1xuICAgIGlmIChzbG90U3RhcnQubWludXRlICE9PSAwICYmIHNsb3RTdGFydC5taW51dGUgIT09IDMwKSB7XG4gICAgICBjb25zLnB1c2goJ1N0YXJ0cyBhdCBhbiB1bnVzdWFsIHRpbWUnKTtcbiAgICB9IGVsc2UgaWYgKGRheU9mV2VlayA+PSAxICYmIGRheU9mV2VlayA8PSA1ICYmIChob3VyIDwgOSB8fCBob3VyID49IDE3KSkge1xuICAgICAgY29ucy5wdXNoKCdPdXRzaWRlIHN0YW5kYXJkIHdvcmtpbmcgaG91cnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29ucy5wdXNoKCdObyBzaWduaWZpY2FudCBkcmF3YmFja3MgaWRlbnRpZmllZCcpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHsgcHJvcywgY29ucyB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBhIHNjb3JlIGZvciByYW5raW5nIHRpbWUgc2xvdHNcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IHNsb3RTdGFydCAtIFN0YXJ0IHRpbWUgb2YgdGhlIHNsb3RcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3MgLSBMaXN0IG9mIHByb3NcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnMgLSBMaXN0IG9mIGNvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lUHJlZmVyZW5jZSAtIFByZWZlcnJlZCB0aW1lIG9mIGRheVxuICogQHJldHVybnMge251bWJlcn0gLSBTY29yZSBmb3IgcmFua2luZ1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTY29yZShzbG90U3RhcnQsIHByb3MsIGNvbnMsIHRpbWVQcmVmZXJlbmNlKSB7XG4gIGxldCBzY29yZSA9IDA7XG4gIFxuICAvLyBCYXNlIHNjb3JlIGZyb20gcHJvcyBhbmQgY29ucyBjb3VudFxuICBzY29yZSArPSBwcm9zLmxlbmd0aCAqIDEwO1xuICBzY29yZSAtPSBjb25zLmxlbmd0aCAqIDg7XG4gIFxuICAvLyBQcmVmZXJyZWQgdGltZSBib251c1xuICBjb25zdCBob3VyID0gc2xvdFN0YXJ0LmhvdXI7XG4gIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ21vcm5pbmcnICYmIGhvdXIgPj0gOCAmJiBob3VyIDwgMTIpIHtcbiAgICBzY29yZSArPSAxNTtcbiAgfSBlbHNlIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ2FmdGVybm9vbicgJiYgaG91ciA+PSAxMiAmJiBob3VyIDwgMTcpIHtcbiAgICBzY29yZSArPSAxNTtcbiAgfSBlbHNlIGlmICh0aW1lUHJlZmVyZW5jZSA9PT0gJ2V2ZW5pbmcnICYmIGhvdXIgPj0gMTcgJiYgaG91ciA8IDIxKSB7XG4gICAgc2NvcmUgKz0gMTU7XG4gIH1cbiAgXG4gIC8vIElkZWFsIHdvcmtpbmcgaG91cnMgYm9udXNcbiAgaWYgKGhvdXIgPj0gOSAmJiBob3VyIDwgMTcpIHtcbiAgICBzY29yZSArPSA1O1xuICB9XG4gIFxuICAvLyBQcmVmZXIgZWFybGllciBzbG90cyB3aGVuIGFsbCBlbHNlIGlzIGVxdWFsIChmb3IgY29uc2lzdGVudCBzb3J0aW5nKVxuICBzY29yZSAtPSBzbG90U3RhcnQuaG91ciAqIDAuMTtcbiAgXG4gIHJldHVybiBzY29yZTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYXZhaWxhYmxlIHNsb3RzIGZvciBkaXNwbGF5XG4gKiBAcGFyYW0ge0FycmF5fSBzbG90cyAtIExpc3Qgb2YgYXZhaWxhYmxlIHNsb3RzIHdpdGggcHJvcyBhbmQgY29uc1xuICogQHJldHVybnMge3N0cmluZ30gLSBGb3JtYXR0ZWQgc3RyaW5nIGZvciBkaXNwbGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBdmFpbGFibGVTbG90cyhzbG90cykge1xuICBpZiAoIXNsb3RzIHx8IHNsb3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIk5vIGF2YWlsYWJsZSBzbG90cyBmb3VuZC5cIjtcbiAgfVxuICBcbiAgbGV0IHJlc3VsdCA9IFwiQXZhaWxhYmxlIHRpbWUgc2xvdHM6XFxuXFxuXCI7XG4gIFxuICBzbG90cy5mb3JFYWNoKChzbG90LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzbG90LnN0YXJ0KTtcbiAgICBjb25zdCBlbmQgPSBEYXRlVGltZS5mcm9tSVNPKHNsb3QuZW5kKTtcbiAgICBcbiAgICByZXN1bHQgKz0gYE9wdGlvbiAke2luZGV4ICsgMX06ICR7c3RhcnQudG9Gb3JtYXQoJ2NjYywgTExMIGQnKX0gZnJvbSAke3N0YXJ0LnRvRm9ybWF0KCdoOm1tIGEnKX0gdG8gJHtlbmQudG9Gb3JtYXQoJ2g6bW0gYScpfVxcbmA7XG4gICAgXG4gICAgcmVzdWx0ICs9IFwiUHJvczpcXG5cIjtcbiAgICBzbG90LnByb3MuZm9yRWFjaChwcm8gPT4ge1xuICAgICAgcmVzdWx0ICs9IGAtICR7cHJvfVxcbmA7XG4gICAgfSk7XG4gICAgXG4gICAgcmVzdWx0ICs9IFwiQ29uczpcXG5cIjtcbiAgICBzbG90LmNvbnMuZm9yRWFjaChjb24gPT4ge1xuICAgICAgcmVzdWx0ICs9IGAtICR7Y29ufVxcbmA7XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKGluZGV4IDwgc2xvdHMubGVuZ3RoIC0gMSkge1xuICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiByZXN1bHQ7XG59Il0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiSW50ZXJ2YWwiLCJEdXJhdGlvbiIsIkRFRkFVTFRfV09SS0lOR19IT1VSUyIsInN0YXJ0IiwiZW5kIiwid29ya0RheXMiLCJmaW5kQXZhaWxhYmxlU2xvdHMiLCJldmVudHMiLCJkdXJhdGlvbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJhY3Rpdml0eSIsInRpbWVQcmVmZXJlbmNlIiwid29ya2luZ0hvdXJzIiwiZnJvbUlTTyIsImR1cmF0aW9uTWludXRlcyIsImJ1c3lJbnRlcnZhbHMiLCJtYXAiLCJldmVudCIsImV2ZW50U3RhcnQiLCJkYXRlVGltZSIsImRhdGUiLCJldmVudEVuZCIsImludGVydmFsIiwiZnJvbURhdGVUaW1lcyIsInN1bW1hcnkiLCJzbG90cyIsImdlbmVyYXRlUG90ZW50aWFsU2xvdHMiLCJldmFsdWF0ZWRTbG90cyIsImV2YWx1YXRlU2xvdHMiLCJzbGljZSIsInNsb3REdXJhdGlvbiIsImZyb21PYmplY3QiLCJtaW51dGVzIiwiY3VycmVudFRpbWUiLCJpc1dvcmtpbmdEYXkiLCJpbmNsdWRlcyIsIndlZWtkYXkiLCJkYXlTdGFydCIsInNldCIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsImRheUVuZCIsInNsb3RTdGFydCIsInBsdXMiLCJzbG90RW5kIiwiY3VycmVudFNsb3QiLCJpc0F2YWlsYWJsZSIsInNvbWUiLCJidXN5Iiwib3ZlcmxhcHMiLCJtYXRjaGVzUHJlZmVyZW5jZSIsInB1c2giLCJ0b0lTTyIsInN0YXJ0RGF0ZVRpbWUiLCJlbmREYXRlVGltZSIsImRheXMiLCJzdGFydE9mIiwic2xvdCIsInNsb3RJbnRlcnZhbCIsInByb3MiLCJjb25zIiwiZ2VuZXJhdGVQcm9zQW5kQ29ucyIsInNjb3JlIiwiY2FsY3VsYXRlU2NvcmUiLCJzb3J0IiwiYSIsImIiLCJ0b0xvd2VyQ2FzZSIsImJ1ZmZlclRpbWUiLCJoYXNFdmVudEJlZm9yZSIsImhhc0V2ZW50QWZ0ZXIiLCJidXN5RW5kIiwiYnVzeVN0YXJ0IiwibWludXMiLCJkYXlPZldlZWsiLCJsZW5ndGgiLCJmb3JtYXRBdmFpbGFibGVTbG90cyIsInJlc3VsdCIsImZvckVhY2giLCJpbmRleCIsInRvRm9ybWF0IiwicHJvIiwiY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/tools/schedulingUtils.js\n");

/***/ }),

/***/ "(api)/./lib/tools/timeUtils.js":
/*!********************************!*\
  !*** ./lib/tools/timeUtils.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToUTCISOString: () => (/* binding */ convertToUTCISOString),\n/* harmony export */   getUserTimezone: () => (/* binding */ getUserTimezone)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var chrono_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chrono-node */ \"chrono-node\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__, chrono_node__WEBPACK_IMPORTED_MODULE_1__]);\n([luxon__WEBPACK_IMPORTED_MODULE_0__, chrono_node__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * Gets the user's configured timezone.\n * In a real application, this should ideally fetch from user database preferences\n * or potentially derive from the user's session/request context.\n *\n * @returns {string} - User's IANA timezone string (e.g., \"America/Winnipeg\"). Defaults to 'UTC'.\n */ function getUserTimezone() {\n    try {\n        // --- PLACEHOLDER: Replace with actual logic ---\n        // Option 1: Fetch from User Preferences (requires passing userId or context)\n        // const userPrefs = await fetchUserPreferences(userId);\n        // if (userPrefs?.timezone) return userPrefs.timezone;\n        // Option 2: Get from environment/config (less flexible)\n        // if (process.env.DEFAULT_USER_TIMEZONE) return process.env.DEFAULT_USER_TIMEZONE;\n        // Fallback for this example (as used previously)\n        const defaultTimezone = \"America/Winnipeg\"; // Or load from .env\n        console.log(`DEBUG: Using timezone: ${defaultTimezone}`); // Add log for visibility\n        return defaultTimezone;\n    // --- End Placeholder ---\n    } catch (error) {\n        console.error(\"Error getting user timezone:\", error);\n        return \"UTC\"; // Safe fallback\n    }\n}\n/**\n * Converts a potentially natural language date/time string into a standardized\n * ISO 8601 UTC string (YYYY-MM-DDTHH:mm:ssZ).\n * It uses chrono-node for parsing and Luxon for timezone handling and formatting.\n * Interprets ambiguous times relative to the user's local timezone.\n *\n * @param {string} timeString - The date/time string from user/LLM (e.g., \"Friday at 2 PM\", \"tomorrow morning\", \"2025-04-04T14:00:00\").\n * @param {string} [userTimezone] - Optional. The user's IANA timezone (e.g., \"America/Winnipeg\"). If not provided, getUserTimezone() is called.\n * @returns {string | null} - The date/time in ISO 8601 UTC format (ending in 'Z'), or null if parsing fails.\n */ function convertToUTCISOString(timeString, userTimezone) {\n    if (!timeString) {\n        console.error(\"convertToUTCISOString received empty timeString.\");\n        return null;\n    }\n    const tz = userTimezone || getUserTimezone();\n    try {\n        // --- Step 1: Handle if input is ALREADY a valid ISO string ---\n        // Basic check first to avoid unnecessary chrono parsing\n        if (typeof timeString === \"string\" && timeString.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/)) {\n            const dtFromISO = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(timeString, {\n                zone: \"keepLocalTime\"\n            }); // Try parsing first\n            if (dtFromISO.isValid) {\n                let finalDt;\n                // Check if the original string had timezone info (Z or offset)\n                if (timeString.includes(\"Z\") || timeString.includes(\"+\") || timeString.match(/-\\d{2}:\\d{2}$/)) {\n                    // It has timezone info, use it directly but ensure it's DateTime object\n                    finalDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(timeString, {\n                        setZone: true\n                    }); // Let Luxon handle the provided zone/offset\n                    console.log(`DEBUG: Parsed existing ISO with TZ: ${timeString} -> ${finalDt.toISO()}`);\n                } else {\n                    // No timezone info, assume it's in the user's local timezone\n                    finalDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(timeString, {\n                        zone: tz\n                    }); // Interpret in user's zone\n                    console.log(`DEBUG: Parsed existing ISO (assumed local ${tz}): ${timeString} -> ${finalDt.toISO()}`);\n                }\n                // Ensure the final result is valid and convert to UTC ISO\n                if (finalDt.isValid) {\n                    return finalDt.toUTC().set({\n                        millisecond: 0\n                    }).toISO(); // Convert to UTC\n                } else {\n                    console.warn(`convertToUTCISOString: Luxon deemed parsed ISO invalid: ${timeString}`);\n                    // Fall through to chrono parsing as a last resort maybe? Or return null? Let's return null for now.\n                    return null;\n                }\n            }\n            // If Luxon couldn't parse it as ISO, let chrono try below\n            console.log(`DEBUG: Input looked like ISO but failed Luxon parse, trying chrono: ${timeString}`);\n        }\n        // --- Step 2: Use chrono-node for natural language parsing ---\n        // Create a reference date (\"now\") in the user's timezone for chrono's context\n        const referenceDate = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now().setZone(tz).toJSDate();\n        // Use chrono.parseDate which returns a single Date object or null\n        // 'forwardDate: true' helps interpret ambiguous dates (like \"Friday\") as upcoming\n        const parsedDate = chrono_node__WEBPACK_IMPORTED_MODULE_1__.parseDate(timeString, referenceDate, {\n            forwardDate: true\n        });\n        if (!parsedDate) {\n            console.warn(`convertToUTCISOString: chrono-node could not parse: \"${timeString}\" with reference timezone ${tz}`);\n            return null; // Parsing failed\n        }\n        // --- Step 3: Convert the JS Date (interpreted relative to user TZ) to UTC ISO ---\n        // Wrap the JS Date in Luxon, explicitly state it represents time in the user's zone, then convert to UTC\n        const finalDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromJSDate(parsedDate, {\n            zone: tz\n        });\n        if (!finalDt.isValid) {\n            console.error(`convertToUTCISOString: Luxon failed to create valid DateTime from chrono result for \"${timeString}\"`);\n            return null;\n        }\n        console.log(`DEBUG: Parsed NL \"${timeString}\" (ref: ${tz}) -> ${finalDt.toISO()}`);\n        // Convert to UTC and format as ISO 8601 string, removing milliseconds\n        const utcIsoString = finalDt.toUTC().set({\n            millisecond: 0\n        }).toISO();\n        console.log(`DEBUG: Converted \"${timeString}\" to UTC ISO: ${utcIsoString}`);\n        return utcIsoString;\n    } catch (error) {\n        console.error(`Error converting time string \"${timeString}\" to UTC ISO with timezone ${tz}:`, error);\n        return null; // Return null on error\n    }\n} // Example Usage (for testing, not part of the export usually):\n /*\nconst userTZ = getUserTimezone(); // e.g., \"America/Winnipeg\"\nconsole.log(\"User Timezone:\", userTZ);\nconsole.log(\"--- Examples ---\");\nconsole.log(`\"Friday at 2 PM\" ->`, convertToUTCISOString(\"Friday at 2 PM\", userTZ));\nconsole.log(`\"tomorrow morning\" ->`, convertToUTCISOString(\"tomorrow morning\", userTZ)); // Chrono defaults morning to ~9 AM\nconsole.log(`\"next monday 10:30am\" ->`, convertToUTCISOString(\"next monday 10:30am\", userTZ));\nconsole.log(`\"2025-04-04T14:00:00\" ->`, convertToUTCISOString(\"2025-04-04T14:00:00\", userTZ)); // Assumes local time\nconsole.log(`\"2025-04-04T19:00:00-05:00\" ->`, convertToUTCISOString(\"2025-04-04T19:00:00-05:00\", userTZ)); // Has offset\nconsole.log(`\"2025-04-04T19:00:00Z\" ->`, convertToUTCISOString(\"2025-04-04T19:00:00Z\", userTZ)); // Already UTC\nconsole.log(`\"gibberish\" ->`, convertToUTCISOString(\"gibberish\", userTZ));\n*/ \n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxNQUFNLGlCQUFpQjtRQUNoQztRQUVBLG1GQUFtRjtRQUNuRix5R0FBeUc7UUFDekcsTUFBTU0sVUFBVWhCLDJDQUFRQSxDQUFDOEIsVUFBVSxDQUFDSCxZQUFZO1lBQUViLE1BQU1KO1FBQUc7UUFFM0QsSUFBSSxDQUFDTSxRQUFRRCxPQUFPLEVBQUU7WUFDbEJYLFFBQVFFLEtBQUssQ0FBQyxDQUFDLHFGQUFxRixFQUFFRSxXQUFXLENBQUMsQ0FBQztZQUNuSCxPQUFPO1FBQ1g7UUFFQUosUUFBUUMsR0FBRyxDQUFDLENBQUMsa0JBQWtCLEVBQUVHLFdBQVcsUUFBUSxFQUFFRSxHQUFHLEtBQUssRUFBRU0sUUFBUUcsS0FBSyxHQUFHLENBQUM7UUFFakYsc0VBQXNFO1FBQ3RFLE1BQU1ZLGVBQWVmLFFBQVFJLEtBQUssR0FBR0MsR0FBRyxDQUFDO1lBQUVDLGFBQWE7UUFBRSxHQUFHSCxLQUFLO1FBQ2xFZixRQUFRQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRUcsV0FBVyxjQUFjLEVBQUV1QixhQUFhLENBQUM7UUFFMUUsT0FBT0E7SUFFVCxFQUFFLE9BQU96QixPQUFPO1FBQ2RGLFFBQVFFLEtBQUssQ0FBQyxDQUFDLDhCQUE4QixFQUFFRSxXQUFXLDJCQUEyQixFQUFFRSxHQUFHLENBQUMsQ0FBQyxFQUFFSjtRQUM5RixPQUFPLE1BQU0sdUJBQXVCO0lBQ3RDO0FBQ0YsRUFFQSwrREFBK0Q7Q0FDL0Q7Ozs7Ozs7Ozs7O0FBV0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nY2FsZW5kYXJhcHAvLi9saWIvdG9vbHMvdGltZVV0aWxzLmpzPzRmMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgKiBhcyBjaHJvbm8gZnJvbSAnY2hyb25vLW5vZGUnO1xuXG4vKipcbiAqIEdldHMgdGhlIHVzZXIncyBjb25maWd1cmVkIHRpbWV6b25lLlxuICogSW4gYSByZWFsIGFwcGxpY2F0aW9uLCB0aGlzIHNob3VsZCBpZGVhbGx5IGZldGNoIGZyb20gdXNlciBkYXRhYmFzZSBwcmVmZXJlbmNlc1xuICogb3IgcG90ZW50aWFsbHkgZGVyaXZlIGZyb20gdGhlIHVzZXIncyBzZXNzaW9uL3JlcXVlc3QgY29udGV4dC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVzZXIncyBJQU5BIHRpbWV6b25lIHN0cmluZyAoZS5nLiwgXCJBbWVyaWNhL1dpbm5pcGVnXCIpLiBEZWZhdWx0cyB0byAnVVRDJy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJUaW1lem9uZSgpIHtcbiAgdHJ5IHtcbiAgICAvLyAtLS0gUExBQ0VIT0xERVI6IFJlcGxhY2Ugd2l0aCBhY3R1YWwgbG9naWMgLS0tXG4gICAgLy8gT3B0aW9uIDE6IEZldGNoIGZyb20gVXNlciBQcmVmZXJlbmNlcyAocmVxdWlyZXMgcGFzc2luZyB1c2VySWQgb3IgY29udGV4dClcbiAgICAvLyBjb25zdCB1c2VyUHJlZnMgPSBhd2FpdCBmZXRjaFVzZXJQcmVmZXJlbmNlcyh1c2VySWQpO1xuICAgIC8vIGlmICh1c2VyUHJlZnM/LnRpbWV6b25lKSByZXR1cm4gdXNlclByZWZzLnRpbWV6b25lO1xuXG4gICAgLy8gT3B0aW9uIDI6IEdldCBmcm9tIGVudmlyb25tZW50L2NvbmZpZyAobGVzcyBmbGV4aWJsZSlcbiAgICAvLyBpZiAocHJvY2Vzcy5lbnYuREVGQVVMVF9VU0VSX1RJTUVaT05FKSByZXR1cm4gcHJvY2Vzcy5lbnYuREVGQVVMVF9VU0VSX1RJTUVaT05FO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIHRoaXMgZXhhbXBsZSAoYXMgdXNlZCBwcmV2aW91c2x5KVxuICAgIGNvbnN0IGRlZmF1bHRUaW1lem9uZSA9ICdBbWVyaWNhL1dpbm5pcGVnJzsgLy8gT3IgbG9hZCBmcm9tIC5lbnZcbiAgICBjb25zb2xlLmxvZyhgREVCVUc6IFVzaW5nIHRpbWV6b25lOiAke2RlZmF1bHRUaW1lem9uZX1gKTsgLy8gQWRkIGxvZyBmb3IgdmlzaWJpbGl0eVxuICAgIHJldHVybiBkZWZhdWx0VGltZXpvbmU7XG4gICAgLy8gLS0tIEVuZCBQbGFjZWhvbGRlciAtLS1cblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciB0aW1lem9uZTonLCBlcnJvcik7XG4gICAgcmV0dXJuICdVVEMnOyAvLyBTYWZlIGZhbGxiYWNrXG4gIH1cbn1cblxuXG4vKipcbiAqIENvbnZlcnRzIGEgcG90ZW50aWFsbHkgbmF0dXJhbCBsYW5ndWFnZSBkYXRlL3RpbWUgc3RyaW5nIGludG8gYSBzdGFuZGFyZGl6ZWRcbiAqIElTTyA4NjAxIFVUQyBzdHJpbmcgKFlZWVktTU0tRERUSEg6bW06c3NaKS5cbiAqIEl0IHVzZXMgY2hyb25vLW5vZGUgZm9yIHBhcnNpbmcgYW5kIEx1eG9uIGZvciB0aW1lem9uZSBoYW5kbGluZyBhbmQgZm9ybWF0dGluZy5cbiAqIEludGVycHJldHMgYW1iaWd1b3VzIHRpbWVzIHJlbGF0aXZlIHRvIHRoZSB1c2VyJ3MgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbWVTdHJpbmcgLSBUaGUgZGF0ZS90aW1lIHN0cmluZyBmcm9tIHVzZXIvTExNIChlLmcuLCBcIkZyaWRheSBhdCAyIFBNXCIsIFwidG9tb3Jyb3cgbW9ybmluZ1wiLCBcIjIwMjUtMDQtMDRUMTQ6MDA6MDBcIikuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJUaW1lem9uZV0gLSBPcHRpb25hbC4gVGhlIHVzZXIncyBJQU5BIHRpbWV6b25lIChlLmcuLCBcIkFtZXJpY2EvV2lubmlwZWdcIikuIElmIG5vdCBwcm92aWRlZCwgZ2V0VXNlclRpbWV6b25lKCkgaXMgY2FsbGVkLlxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9IC0gVGhlIGRhdGUvdGltZSBpbiBJU08gODYwMSBVVEMgZm9ybWF0IChlbmRpbmcgaW4gJ1onKSwgb3IgbnVsbCBpZiBwYXJzaW5nIGZhaWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvVVRDSVNPU3RyaW5nKHRpbWVTdHJpbmcsIHVzZXJUaW1lem9uZSkge1xuICBpZiAoIXRpbWVTdHJpbmcpIHtcbiAgICBjb25zb2xlLmVycm9yKCdjb252ZXJ0VG9VVENJU09TdHJpbmcgcmVjZWl2ZWQgZW1wdHkgdGltZVN0cmluZy4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHR6ID0gdXNlclRpbWV6b25lIHx8IGdldFVzZXJUaW1lem9uZSgpO1xuXG4gIHRyeSB7XG4gICAgLy8gLS0tIFN0ZXAgMTogSGFuZGxlIGlmIGlucHV0IGlzIEFMUkVBRFkgYSB2YWxpZCBJU08gc3RyaW5nIC0tLVxuICAgIC8vIEJhc2ljIGNoZWNrIGZpcnN0IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNocm9ubyBwYXJzaW5nXG4gICAgaWYgKHR5cGVvZiB0aW1lU3RyaW5nID09PSAnc3RyaW5nJyAmJiB0aW1lU3RyaW5nLm1hdGNoKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0vKSkge1xuICAgICAgICBjb25zdCBkdEZyb21JU08gPSBEYXRlVGltZS5mcm9tSVNPKHRpbWVTdHJpbmcsIHsgem9uZTogJ2tlZXBMb2NhbFRpbWUnIH0pOyAvLyBUcnkgcGFyc2luZyBmaXJzdFxuXG4gICAgICAgIGlmIChkdEZyb21JU08uaXNWYWxpZCkge1xuICAgICAgICAgICAgbGV0IGZpbmFsRHQ7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3JpZ2luYWwgc3RyaW5nIGhhZCB0aW1lem9uZSBpbmZvIChaIG9yIG9mZnNldClcbiAgICAgICAgICAgIGlmICh0aW1lU3RyaW5nLmluY2x1ZGVzKCdaJykgfHwgdGltZVN0cmluZy5pbmNsdWRlcygnKycpIHx8IHRpbWVTdHJpbmcubWF0Y2goLy1cXGR7Mn06XFxkezJ9JC8pKSB7XG4gICAgICAgICAgICAgICAgIC8vIEl0IGhhcyB0aW1lem9uZSBpbmZvLCB1c2UgaXQgZGlyZWN0bHkgYnV0IGVuc3VyZSBpdCdzIERhdGVUaW1lIG9iamVjdFxuICAgICAgICAgICAgICAgICBmaW5hbER0ID0gRGF0ZVRpbWUuZnJvbUlTTyh0aW1lU3RyaW5nLCB7IHNldFpvbmU6IHRydWUgfSk7IC8vIExldCBMdXhvbiBoYW5kbGUgdGhlIHByb3ZpZGVkIHpvbmUvb2Zmc2V0XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBERUJVRzogUGFyc2VkIGV4aXN0aW5nIElTTyB3aXRoIFRaOiAke3RpbWVTdHJpbmd9IC0+ICR7ZmluYWxEdC50b0lTTygpfWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgLy8gTm8gdGltZXpvbmUgaW5mbywgYXNzdW1lIGl0J3MgaW4gdGhlIHVzZXIncyBsb2NhbCB0aW1lem9uZVxuICAgICAgICAgICAgICAgICBmaW5hbER0ID0gRGF0ZVRpbWUuZnJvbUlTTyh0aW1lU3RyaW5nLCB7IHpvbmU6IHR6IH0pOyAvLyBJbnRlcnByZXQgaW4gdXNlcidzIHpvbmVcbiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYERFQlVHOiBQYXJzZWQgZXhpc3RpbmcgSVNPIChhc3N1bWVkIGxvY2FsICR7dHp9KTogJHt0aW1lU3RyaW5nfSAtPiAke2ZpbmFsRHQudG9JU08oKX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBmaW5hbCByZXN1bHQgaXMgdmFsaWQgYW5kIGNvbnZlcnQgdG8gVVRDIElTT1xuICAgICAgICAgICAgaWYgKGZpbmFsRHQuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxEdC50b1VUQygpLnNldCh7IG1pbGxpc2Vjb25kOiAwIH0pLnRvSVNPKCk7IC8vIENvbnZlcnQgdG8gVVRDXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGNvbnZlcnRUb1VUQ0lTT1N0cmluZzogTHV4b24gZGVlbWVkIHBhcnNlZCBJU08gaW52YWxpZDogJHt0aW1lU3RyaW5nfWApO1xuICAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gY2hyb25vIHBhcnNpbmcgYXMgYSBsYXN0IHJlc29ydCBtYXliZT8gT3IgcmV0dXJuIG51bGw/IExldCdzIHJldHVybiBudWxsIGZvciBub3cuXG4gICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAvLyBJZiBMdXhvbiBjb3VsZG4ndCBwYXJzZSBpdCBhcyBJU08sIGxldCBjaHJvbm8gdHJ5IGJlbG93XG4gICAgICAgICBjb25zb2xlLmxvZyhgREVCVUc6IElucHV0IGxvb2tlZCBsaWtlIElTTyBidXQgZmFpbGVkIEx1eG9uIHBhcnNlLCB0cnlpbmcgY2hyb25vOiAke3RpbWVTdHJpbmd9YCk7XG4gICAgfVxuXG5cbiAgICAvLyAtLS0gU3RlcCAyOiBVc2UgY2hyb25vLW5vZGUgZm9yIG5hdHVyYWwgbGFuZ3VhZ2UgcGFyc2luZyAtLS1cbiAgICAvLyBDcmVhdGUgYSByZWZlcmVuY2UgZGF0ZSAoXCJub3dcIikgaW4gdGhlIHVzZXIncyB0aW1lem9uZSBmb3IgY2hyb25vJ3MgY29udGV4dFxuICAgIGNvbnN0IHJlZmVyZW5jZURhdGUgPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHR6KS50b0pTRGF0ZSgpO1xuXG4gICAgLy8gVXNlIGNocm9uby5wYXJzZURhdGUgd2hpY2ggcmV0dXJucyBhIHNpbmdsZSBEYXRlIG9iamVjdCBvciBudWxsXG4gICAgLy8gJ2ZvcndhcmREYXRlOiB0cnVlJyBoZWxwcyBpbnRlcnByZXQgYW1iaWd1b3VzIGRhdGVzIChsaWtlIFwiRnJpZGF5XCIpIGFzIHVwY29taW5nXG4gICAgY29uc3QgcGFyc2VkRGF0ZSA9IGNocm9uby5wYXJzZURhdGUodGltZVN0cmluZywgcmVmZXJlbmNlRGF0ZSwgeyBmb3J3YXJkRGF0ZTogdHJ1ZSB9KTtcblxuICAgIGlmICghcGFyc2VkRGF0ZSkge1xuICAgICAgY29uc29sZS53YXJuKGBjb252ZXJ0VG9VVENJU09TdHJpbmc6IGNocm9uby1ub2RlIGNvdWxkIG5vdCBwYXJzZTogXCIke3RpbWVTdHJpbmd9XCIgd2l0aCByZWZlcmVuY2UgdGltZXpvbmUgJHt0en1gKTtcbiAgICAgIHJldHVybiBudWxsOyAvLyBQYXJzaW5nIGZhaWxlZFxuICAgIH1cblxuICAgIC8vIC0tLSBTdGVwIDM6IENvbnZlcnQgdGhlIEpTIERhdGUgKGludGVycHJldGVkIHJlbGF0aXZlIHRvIHVzZXIgVFopIHRvIFVUQyBJU08gLS0tXG4gICAgLy8gV3JhcCB0aGUgSlMgRGF0ZSBpbiBMdXhvbiwgZXhwbGljaXRseSBzdGF0ZSBpdCByZXByZXNlbnRzIHRpbWUgaW4gdGhlIHVzZXIncyB6b25lLCB0aGVuIGNvbnZlcnQgdG8gVVRDXG4gICAgY29uc3QgZmluYWxEdCA9IERhdGVUaW1lLmZyb21KU0RhdGUocGFyc2VkRGF0ZSwgeyB6b25lOiB0eiB9KTtcblxuICAgIGlmICghZmluYWxEdC5pc1ZhbGlkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNvbnZlcnRUb1VUQ0lTT1N0cmluZzogTHV4b24gZmFpbGVkIHRvIGNyZWF0ZSB2YWxpZCBEYXRlVGltZSBmcm9tIGNocm9ubyByZXN1bHQgZm9yIFwiJHt0aW1lU3RyaW5nfVwiYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBERUJVRzogUGFyc2VkIE5MIFwiJHt0aW1lU3RyaW5nfVwiIChyZWY6ICR7dHp9KSAtPiAke2ZpbmFsRHQudG9JU08oKX1gKTtcblxuICAgIC8vIENvbnZlcnQgdG8gVVRDIGFuZCBmb3JtYXQgYXMgSVNPIDg2MDEgc3RyaW5nLCByZW1vdmluZyBtaWxsaXNlY29uZHNcbiAgICBjb25zdCB1dGNJc29TdHJpbmcgPSBmaW5hbER0LnRvVVRDKCkuc2V0KHsgbWlsbGlzZWNvbmQ6IDAgfSkudG9JU08oKTtcbiAgICBjb25zb2xlLmxvZyhgREVCVUc6IENvbnZlcnRlZCBcIiR7dGltZVN0cmluZ31cIiB0byBVVEMgSVNPOiAke3V0Y0lzb1N0cmluZ31gKTtcblxuICAgIHJldHVybiB1dGNJc29TdHJpbmc7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjb252ZXJ0aW5nIHRpbWUgc3RyaW5nIFwiJHt0aW1lU3RyaW5nfVwiIHRvIFVUQyBJU08gd2l0aCB0aW1lem9uZSAke3R6fTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7IC8vIFJldHVybiBudWxsIG9uIGVycm9yXG4gIH1cbn1cblxuLy8gRXhhbXBsZSBVc2FnZSAoZm9yIHRlc3RpbmcsIG5vdCBwYXJ0IG9mIHRoZSBleHBvcnQgdXN1YWxseSk6XG4vKlxuY29uc3QgdXNlclRaID0gZ2V0VXNlclRpbWV6b25lKCk7IC8vIGUuZy4sIFwiQW1lcmljYS9XaW5uaXBlZ1wiXG5jb25zb2xlLmxvZyhcIlVzZXIgVGltZXpvbmU6XCIsIHVzZXJUWik7XG5jb25zb2xlLmxvZyhcIi0tLSBFeGFtcGxlcyAtLS1cIik7XG5jb25zb2xlLmxvZyhgXCJGcmlkYXkgYXQgMiBQTVwiIC0+YCwgY29udmVydFRvVVRDSVNPU3RyaW5nKFwiRnJpZGF5IGF0IDIgUE1cIiwgdXNlclRaKSk7XG5jb25zb2xlLmxvZyhgXCJ0b21vcnJvdyBtb3JuaW5nXCIgLT5gLCBjb252ZXJ0VG9VVENJU09TdHJpbmcoXCJ0b21vcnJvdyBtb3JuaW5nXCIsIHVzZXJUWikpOyAvLyBDaHJvbm8gZGVmYXVsdHMgbW9ybmluZyB0byB+OSBBTVxuY29uc29sZS5sb2coYFwibmV4dCBtb25kYXkgMTA6MzBhbVwiIC0+YCwgY29udmVydFRvVVRDSVNPU3RyaW5nKFwibmV4dCBtb25kYXkgMTA6MzBhbVwiLCB1c2VyVFopKTtcbmNvbnNvbGUubG9nKGBcIjIwMjUtMDQtMDRUMTQ6MDA6MDBcIiAtPmAsIGNvbnZlcnRUb1VUQ0lTT1N0cmluZyhcIjIwMjUtMDQtMDRUMTQ6MDA6MDBcIiwgdXNlclRaKSk7IC8vIEFzc3VtZXMgbG9jYWwgdGltZVxuY29uc29sZS5sb2coYFwiMjAyNS0wNC0wNFQxOTowMDowMC0wNTowMFwiIC0+YCwgY29udmVydFRvVVRDSVNPU3RyaW5nKFwiMjAyNS0wNC0wNFQxOTowMDowMC0wNTowMFwiLCB1c2VyVFopKTsgLy8gSGFzIG9mZnNldFxuY29uc29sZS5sb2coYFwiMjAyNS0wNC0wNFQxOTowMDowMFpcIiAtPmAsIGNvbnZlcnRUb1VUQ0lTT1N0cmluZyhcIjIwMjUtMDQtMDRUMTk6MDA6MDBaXCIsIHVzZXJUWikpOyAvLyBBbHJlYWR5IFVUQ1xuY29uc29sZS5sb2coYFwiZ2liYmVyaXNoXCIgLT5gLCBjb252ZXJ0VG9VVENJU09TdHJpbmcoXCJnaWJiZXJpc2hcIiwgdXNlclRaKSk7XG4qLyJdLCJuYW1lcyI6WyJEYXRlVGltZSIsImNocm9ubyIsImdldFVzZXJUaW1lem9uZSIsImRlZmF1bHRUaW1lem9uZSIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImNvbnZlcnRUb1VUQ0lTT1N0cmluZyIsInRpbWVTdHJpbmciLCJ1c2VyVGltZXpvbmUiLCJ0eiIsIm1hdGNoIiwiZHRGcm9tSVNPIiwiZnJvbUlTTyIsInpvbmUiLCJpc1ZhbGlkIiwiZmluYWxEdCIsImluY2x1ZGVzIiwic2V0Wm9uZSIsInRvSVNPIiwidG9VVEMiLCJzZXQiLCJtaWxsaXNlY29uZCIsIndhcm4iLCJyZWZlcmVuY2VEYXRlIiwibm93IiwidG9KU0RhdGUiLCJwYXJzZWREYXRlIiwicGFyc2VEYXRlIiwiZm9yd2FyZERhdGUiLCJmcm9tSlNEYXRlIiwidXRjSXNvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/tools/timeUtils.js\n");

/***/ }),

/***/ "(api)/./lib/tools/toolIndex.js":
/*!********************************!*\
  !*** ./lib/tools/toolIndex.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toolFunctions: () => (/* binding */ toolFunctions),\n/* harmony export */   tools: () => (/* binding */ tools)\n/* harmony export */ });\n/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! luxon */ \"luxon\");\n/* harmony import */ var googleapis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! googleapis */ \"googleapis\");\n/* harmony import */ var googleapis__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(googleapis__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../googleCalendar.js */ \"(api)/./googleCalendar.js\");\n/* harmony import */ var _googleCalendar_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _redisClient_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../redisClient.js */ \"(api)/./lib/redisClient.js\");\n/* harmony import */ var _services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../services/cacheService.js */ \"(api)/./lib/services/cacheService.js\");\n/* harmony import */ var _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schedulingUtils.js */ \"(api)/./lib/tools/schedulingUtils.js\");\n/* harmony import */ var _checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./checkForConflicts.js */ \"(api)/./lib/tools/checkForConflicts.js\");\n/* harmony import */ var _timeUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./timeUtils.js */ \"(api)/./lib/tools/timeUtils.js\");\n/* harmony import */ var _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../postgresClient.js */ \"(api)/./lib/postgresClient.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__, _timeUtils_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__]);\n([luxon__WEBPACK_IMPORTED_MODULE_0__, _services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__, _schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__, _checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__, _timeUtils_js__WEBPACK_IMPORTED_MODULE_7__, _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// lib/tools/index.js\n// Purpose: Defines the tools (schema) available to the LLM and maps them\n//          to their corresponding implementation functions. Also includes\n//          helper functions for processing tool calls.\n// --- IMPORTS ---\n\n // Used for get/update event before calling specific functions\n// Import from googleCalendar.js\n\n// Import from redisClient.js\n\n// Import from cacheService.js\n\n// Import from schedulingUtils.js\n // Renamed to avoid conflict with tool name\n// Import from checkForConflicts.js\n\n// Import from timeUtils.js\n\n// Import from formatters.js - Assuming these might be used by the caller, not directly here\n// import { formatEventTime, formatCalendarEvents, formatToolResponse } from './formatters.js';\n// Import from postgresClient.js\n\n// --- Tool Schema Definitions (for OpenAI) ---\nconst tools = [\n    {\n        type: \"function\",\n        function: {\n            name: \"saveUserPreference\",\n            description: \"Save a user preference for future reference. Use this when you identify important user preferences (like preferred meeting times, locations, activity types, scheduling constraints) that should be remembered long-term.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    category: {\n                        type: \"string\",\n                        description: \"The broad category of the preference (e.g., 'scheduling', 'location', 'activity').\"\n                    },\n                    key: {\n                        type: \"string\",\n                        description: \"The specific preference key within the category (e.g., 'preferredMeetingHours', 'defaultCity', 'favoriteWorkout').\"\n                    },\n                    value: {\n                        oneOf: [\n                            {\n                                type: \"string\"\n                            },\n                            {\n                                type: \"number\"\n                            },\n                            {\n                                type: \"boolean\"\n                            },\n                            {\n                                type: \"array\",\n                                items: {}\n                            },\n                            {\n                                type: \"object\"\n                            }\n                        ],\n                        description: \"The value of the preference (e.g., '9am-12pm', 'New York', 'running'). Can be string, number, boolean, array, or object.\"\n                    },\n                    context: {\n                        type: \"string\",\n                        description: \"Optional: Additional context about when or why this preference applies (e.g., 'work meetings', 'weekends').\"\n                    }\n                },\n                required: [\n                    \"category\",\n                    \"key\",\n                    \"value\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"addCalendarEvents\",\n            description: \"Creates one or more new events directly in the user's primary Google Calendar based on their request. Extracts details like title, location, and resolves start/end times (using current time context for relative references like 'tomorrow 4pm') into absolute ISO 8601 format. Assumes a 1-hour duration if not specified. Checks for conflicts before adding.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    events: {\n                        type: \"array\",\n                        description: \"An array of one or more event objects to create.\",\n                        items: {\n                            type: \"object\",\n                            properties: {\n                                summary: {\n                                    type: \"string\",\n                                    description: \"The title/summary of the event (e.g., 'Meeting with Clyde').\"\n                                },\n                                start: {\n                                    type: \"string\",\n                                    description: \"The start date and time of the event in STRICT ISO 8601 format including timezone offset (e.g., '2025-04-01T16:00:00-07:00'). Resolve relative times (like 'tomorrow 4pm') based on current time context before calling.\"\n                                },\n                                end: {\n                                    type: \"string\",\n                                    description: \"The end date and time of the event in STRICT ISO 8601 format including timezone offset (e.g., '2025-04-01T17:00:00-07:00'). Resolve relative times; assume 1hr duration from start if end time is not specified.\"\n                                },\n                                description: {\n                                    type: \"string\",\n                                    description: \"Optional description or notes for the event.\"\n                                },\n                                location: {\n                                    type: \"string\",\n                                    description: \"Optional location for the event (e.g., 'Starbucks Main St', 'Zoom Link').\"\n                                },\n                                reminders: {\n                                    type: \"array\",\n                                    items: {\n                                        type: \"number\"\n                                    },\n                                    description: \"Optional reminder times in minutes before the event start (e.g., [10, 30]).\"\n                                },\n                                priority: {\n                                    type: \"string\",\n                                    enum: [\n                                        \"Low\",\n                                        \"Medium\",\n                                        \"High\",\n                                        \"Urgent\"\n                                    ],\n                                    description: \"Optional priority level for the event.\"\n                                },\n                                tags: {\n                                    type: \"array\",\n                                    items: {\n                                        type: \"string\"\n                                    },\n                                    description: \"Optional tags to categorize the event.\"\n                                },\n                                overrideConflicts: {\n                                    type: \"boolean\",\n                                    description: \"Optional flag to override conflicts and add the event anyway. Default is false.\"\n                                }\n                            },\n                            required: [\n                                \"summary\",\n                                \"start\",\n                                \"end\"\n                            ]\n                        }\n                    }\n                },\n                required: [\n                    \"events\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"getCalendarEvents\",\n            description: \"Retrieves events from the user's primary Google Calendar within a specified date range.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    start_date: {\n                        type: \"string\",\n                        description: \"The start date/time for the query range in ISO 8601 format (e.g., '2025-04-01T00:00:00Z' or '2025-04-01').\"\n                    },\n                    end_date: {\n                        type: \"string\",\n                        description: \"The end date/time for the query range in ISO 8601 format (e.g., '2025-04-02T00:00:00Z' or '2025-04-02').\"\n                    }\n                },\n                required: [\n                    \"start_date\",\n                    \"end_date\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"deleteCalendarEvent\",\n            description: \"Deletes a specific event from the user's primary Google Calendar using its unique event ID. Retrieves event details first to invalidate specific cache range.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    eventId: {\n                        type: \"string\",\n                        description: \"The unique ID of the event to delete (e.g., '8ut3a6eol1ov5ovv23v85osssg'). The user might provide the event title/time, use getCalendarEvents first if ID is unknown.\"\n                    }\n                },\n                required: [\n                    \"eventId\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"updateCalendarEvent\",\n            description: \"Updates details (like time, title, location, description) of an existing event in the user's primary Google Calendar using its ID.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    eventId: {\n                        type: \"string\",\n                        description: \"The unique ID of the event to update (e.g., '8ut3a6eol1ov5ovv23v85osssg'). The user might provide the event title/time, use getCalendarEvents first if ID is unknown.\"\n                    },\n                    updates: {\n                        type: \"object\",\n                        properties: {\n                            summary: {\n                                type: \"string\",\n                                description: \"New title/summary for the event.\"\n                            },\n                            description: {\n                                type: \"string\",\n                                description: \"New description for the event.\"\n                            },\n                            location: {\n                                type: \"string\",\n                                description: \"New location for the event.\"\n                            },\n                            start: {\n                                type: \"string\",\n                                description: \"New start time in ISO 8601 format (e.g., '2025-04-01T16:30:00-07:00').\"\n                            },\n                            end: {\n                                type: \"string\",\n                                description: \"New end time in ISO 8601 format (e.g., '2025-04-01T17:00:00-07:00').\"\n                            },\n                            priority: {\n                                type: \"string\",\n                                enum: [\n                                    \"Low\",\n                                    \"Medium\",\n                                    \"High\",\n                                    \"Urgent\"\n                                ],\n                                description: \"Optional priority level for the event.\"\n                            },\n                            tags: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                description: \"Optional tags to categorize the event.\"\n                            }\n                        },\n                        description: \"Object containing AT LEAST ONE field to update. Include only fields that are changing.\",\n                        minProperties: 1 // Ensure at least one update is provided\n                    }\n                },\n                required: [\n                    \"eventId\",\n                    \"updates\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"findAvailableSlots\",\n            description: \"Finds multiple available time slots in the user's calendar suitable for scheduling a new event. Considers existing events.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    duration: {\n                        type: \"number\",\n                        description: \"Required duration of the event in minutes (e.g., 30, 60).\"\n                    },\n                    startDate: {\n                        type: \"string\",\n                        description: \"The start date/time to search from, in ISO 8601 format. Defaults to the current time if not provided.\"\n                    },\n                    endDate: {\n                        type: \"string\",\n                        description: \"The end date/time to search until, in ISO 8601 format. Defaults to 7 days from startDate if not provided.\"\n                    },\n                    timePreference: {\n                        type: \"string\",\n                        enum: [\n                            \"morning\",\n                            \"afternoon\",\n                            \"evening\",\n                            \"any\"\n                        ],\n                        description: \"Optional preferred time of day (defaults to 'any'). Morning (~9am-12pm), Afternoon (~12pm-5pm), Evening (~5pm-9pm).\"\n                    },\n                    activity: {\n                        type: \"string\",\n                        description: \"Optional: The type of activity being scheduled (e.g., 'meeting', 'workout', 'call') to potentially influence suggestions or check constraints.\"\n                    }\n                },\n                required: [\n                    \"duration\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"getWeatherForecast\",\n            description: \"Gets the weather forecast for a specific location and date.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    location: {\n                        type: \"string\",\n                        description: \"The city and state, or zip code for the weather forecast (e.g., 'San Francisco, CA', '94107').\"\n                    },\n                    date: {\n                        type: \"string\",\n                        description: \"The date for the forecast in ISO 8601 format (YYYY-MM-DD). Defaults to today if not specified.\"\n                    }\n                },\n                required: [\n                    \"location\"\n                ]\n            }\n        }\n    },\n    {\n        type: \"function\",\n        function: {\n            name: \"deleteCalendarEventsByQuery\",\n            description: \"Deletes multiple calendar events within a specified date range that match a search query in their title/summary. Use with caution.\",\n            parameters: {\n                type: \"object\",\n                properties: {\n                    query: {\n                        type: \"string\",\n                        description: \"The search query to match against event summaries (e.g., 'gym', 'meeting with project X'). Case-insensitive.\"\n                    },\n                    start_date: {\n                        type: \"string\",\n                        description: \"The start date/time for the search range in ISO 8601 format (e.g., '2025-04-01'). Required.\"\n                    },\n                    end_date: {\n                        type: \"string\",\n                        description: \"The end date/time for the search range in ISO 8601 format (e.g., '2025-04-30'). Required.\"\n                    }\n                },\n                required: [\n                    \"query\",\n                    \"start_date\",\n                    \"end_date\"\n                ]\n            }\n        }\n    }\n];\n// --- Tool Function Implementations ---\n// Maps tool names (from schema) to the actual functions that execute them.\nconst toolFunctions = {\n    saveUserPreference: async (args, userId = \"default\", accessToken = null)=>{\n        if (!userId || userId === \"default\") return {\n            success: false,\n            message: \"Error: User ID is missing.\"\n        };\n        console.log(`DEBUG: saveUserPreference called with userId=${userId}, args:`, JSON.stringify(args));\n        const { category, key, value, context } = args;\n        // Basic validation\n        if (!category || !key || value === undefined) {\n            return {\n                success: false,\n                message: \"Error: Missing required fields (category, key, value) for preference.\"\n            };\n        }\n        try {\n            // First, find or create the UserPreference record\n            const [userPref, created] = await _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.UserPreference.findOrCreate({\n                where: {\n                    user_id: userId\n                },\n                defaults: {\n                    user_id: userId,\n                    preferences_data: {}\n                }\n            });\n            console.log(`DEBUG: UserPreference record ${created ? \"created\" : \"found\"} for user ${userId}`);\n            // Get the current preferences data\n            const currentPrefs = created ? {} : userPref.preferences_data || {};\n            console.log(\"DEBUG: Current preferences_data:\", JSON.stringify(currentPrefs));\n            // Create a new preferences object with the updated values\n            const updatedPrefs = {\n                ...currentPrefs\n            };\n            // Ensure category exists\n            if (!updatedPrefs[category]) updatedPrefs[category] = {};\n            // Update the value\n            updatedPrefs[category][key] = value;\n            // Handle context if provided\n            if (context !== undefined) {\n                const contextKey = `${category}_context`;\n                if (!updatedPrefs[contextKey]) updatedPrefs[contextKey] = {};\n                updatedPrefs[contextKey][key] = context;\n            }\n            console.log(\"DEBUG: Updated preferences_data to be saved:\", JSON.stringify(updatedPrefs));\n            // Use UPDATE instead of save() to ensure the JSONB field is properly updated\n            // This is the key change to fix the issue with Sequelize not detecting changes to JSONB fields\n            const [updateCount] = await _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.UserPreference.update({\n                preferences_data: updatedPrefs\n            }, {\n                where: {\n                    user_id: userId\n                }\n            });\n            console.log(`DEBUG: Update result: ${updateCount} rows affected`);\n            // Verify the update by fetching the record again\n            const verifyPref = await _postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.UserPreference.findOne({\n                where: {\n                    user_id: userId\n                }\n            });\n            console.log(\"DEBUG: Verified preferences_data after update:\", JSON.stringify(verifyPref.preferences_data));\n            return {\n                success: true,\n                message: `Preference saved: ${category}.${key} = ${JSON.stringify(value)}`,\n                updateCount: updateCount\n            };\n        } catch (error) {\n            console.error(`Error saving preference for user ${userId}:`, error);\n            return {\n                success: false,\n                message: `Failed to save preference: ${error.message}`\n            };\n        }\n    },\n    addCalendarEvents: async (args, userId = \"default\", accessToken = null)=>{\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false\n        };\n        const tokens = {\n            access_token: accessToken\n        };\n        const { events } = args;\n        if (!Array.isArray(events) || events.length === 0) return {\n            message: \"No event data provided.\",\n            success: false\n        };\n        const results = [];\n        const affectedDateRanges = [];\n        for (const event of events){\n            if (!event.summary || !event.start || !event.end) {\n                results.push({\n                    summary: event.summary || \"?\",\n                    error: \"Missing required fields (summary, start, end).\",\n                    success: false\n                });\n                continue;\n            }\n            // Get user timezone\n            const userTimezone = (0,_timeUtils_js__WEBPACK_IMPORTED_MODULE_7__.getUserTimezone)();\n            try {\n                // Convert start and end times to UTC ISO strings with proper timezone handling\n                const startUtc = (0,_timeUtils_js__WEBPACK_IMPORTED_MODULE_7__.convertToUTCISOString)(event.start, userTimezone);\n                const endUtc = (0,_timeUtils_js__WEBPACK_IMPORTED_MODULE_7__.convertToUTCISOString)(event.end, userTimezone);\n                if (!startUtc || !endUtc) {\n                    throw new Error(\"Failed to convert time strings to UTC ISO format\");\n                }\n                // Update event with properly converted times\n                event.start = startUtc;\n                event.end = endUtc;\n                const startDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(startUtc);\n                const endDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(endUtc);\n                if (!startDt.isValid || !endDt.isValid) throw new Error(\"Invalid date format\");\n                if (startDt >= endDt) throw new Error(\"Start time must be before end time\");\n            } catch (e) {\n                results.push({\n                    summary: event.summary,\n                    error: `Invalid date format or logic: ${e.message}. Use ISO 8601 format.`,\n                    success: false\n                });\n                continue;\n            }\n            try {\n                // Check for conflicts before attempting to add\n                const conflictCheckResult = await (0,_checkForConflicts_js__WEBPACK_IMPORTED_MODULE_6__.checkForConflicts)(tokens, event.start, event.end, event.overrideConflicts === true);\n                if (conflictCheckResult.conflicts) {\n                    console.warn(`Conflict detected for event: ${event.summary}`);\n                    results.push({\n                        summary: event.summary,\n                        conflict: true,\n                        suggestions: conflictCheckResult.suggestions || [],\n                        error: conflictCheckResult.error || `Event conflicts with existing schedule.`,\n                        success: false\n                    });\n                } else if (conflictCheckResult.overridden) {\n                    console.log(`Conflict detected for event: ${event.summary} but override flag is set. Proceeding with event creation.`);\n                    // Add the event despite conflict\n                    const addedEvent = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.addCalendarEvent)(tokens, event.summary, event.start, event.end, event.description, event.location, event.reminders);\n                    // Store metadata if priority or tags are provided\n                    const hasMetadata = event.priority !== undefined || event.tags && event.tags.length > 0;\n                    if (hasMetadata) {\n                        try {\n                            await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.createOrUpdateEventMetadata)(userId, addedEvent.id, {\n                                priority: event.priority,\n                                tags: event.tags // Will be null if undefined or empty\n                            });\n                            console.log(`Metadata saved for event \"${event.summary}\" (ID: ${addedEvent.id})`);\n                        } catch (metadataError) {\n                            console.error(`Error saving metadata for event \"${event.summary}\" (ID: ${addedEvent.id}):`, metadataError);\n                            // Log error but don't fail the entire event addition\n                            addedEvent.metadataError = `Failed to save metadata: ${metadataError.message}`;\n                        }\n                    }\n                    // Add a note about the conflict being overridden\n                    addedEvent.conflictOverridden = true;\n                    addedEvent.conflictCount = conflictCheckResult.conflictCount;\n                    // Assuming addGCalendarEventInternal returns the created event object on success\n                    results.push({\n                        ...addedEvent,\n                        success: true\n                    }); // Add success flag\n                    affectedDateRanges.push({\n                        start: event.start,\n                        end: event.end\n                    });\n                    console.log(`Event added despite conflicts: ${event.summary} (ID: ${addedEvent.id})`);\n                } else {\n                    // Add the event\n                    const addedEvent = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.addCalendarEvent)(tokens, event.summary, event.start, event.end, event.description, event.location, event.reminders);\n                    // Store metadata if priority or tags are provided\n                    const hasMetadata = event.priority !== undefined || event.tags && event.tags.length > 0;\n                    if (hasMetadata) {\n                        try {\n                            await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.createOrUpdateEventMetadata)(userId, addedEvent.id, {\n                                priority: event.priority,\n                                tags: event.tags // Will be null if undefined or empty\n                            });\n                            console.log(`Metadata saved for event \"${event.summary}\" (ID: ${addedEvent.id})`);\n                        } catch (metadataError) {\n                            console.error(`Error saving metadata for event \"${event.summary}\" (ID: ${addedEvent.id}):`, metadataError);\n                            // Log error but don't fail the entire event addition\n                            addedEvent.metadataError = `Failed to save metadata: ${metadataError.message}`;\n                        }\n                    }\n                    // Assuming addGCalendarEventInternal returns the created event object on success\n                    results.push({\n                        ...addedEvent,\n                        success: true\n                    }); // Add success flag\n                    affectedDateRanges.push({\n                        start: event.start,\n                        end: event.end\n                    });\n                    console.log(`Event added: ${event.summary} (ID: ${addedEvent.id})`);\n                }\n            } catch (addError) {\n                console.error(`Error adding event \"${event.summary}\" during conflict check or API call:`, addError);\n                results.push({\n                    summary: event.summary,\n                    error: `Failed to process event: ${addError.message}`,\n                    success: false\n                });\n            }\n        }\n        // Invalidate cache for all ranges where events were successfully added\n        // Use invalidateCache from cacheService\n        for (const range of affectedDateRanges){\n            try {\n                await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, range.start, range.end);\n                console.log(`Invalidated cache for range: ${range.start} - ${range.end}`);\n            } catch (cacheError) {\n                console.error(\"Error invalidating cache after add:\", cacheError);\n            }\n        }\n        return results; // Return array of result objects (with success flags/errors)\n    },\n    getCalendarEvents: async (args, userId = \"default\", accessToken = null)=>{\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false,\n            events: []\n        }; // Return structured error\n        const tokens = {\n            access_token: accessToken\n        };\n        const { start_date, end_date } = args;\n        // Validate dates\n        if (!start_date || !end_date) {\n            return {\n                error: \"Both start_date and end_date are required.\",\n                success: false,\n                events: []\n            };\n        }\n        const startDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(start_date);\n        const endDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(end_date);\n        if (!startDt.isValid || !endDt.isValid) {\n            return {\n                error: `Invalid date format. Please use ISO 8601 (e.g., YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ). Received: start=${start_date}, end=${end_date}`,\n                success: false,\n                events: []\n            };\n        }\n        if (startDt >= endDt) {\n            return {\n                error: \"Start date must be before end date.\",\n                success: false,\n                events: []\n            };\n        }\n        let finalEvents = []; // Initialize events array\n        try {\n            // Define cache keys using daily granularity for broader cache hits\n            const cacheKeyStart = startDt.startOf(\"day\").toISODate();\n            const cacheKeyEnd = endDt.endOf(\"day\").toISODate(); // Inclusive end day for key\n            const tokenHash = accessToken.substring(accessToken.length - 10); // Simple hash\n            const userIdCachePrefix = `user_${tokenHash}`; // Or use actual stable userId\n            // Attempt to fetch from cache first\n            let cachedEvents = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n            if (cachedEvents) {\n                console.log(`Cache HIT for events ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // Filter cached events based on the *exact* start/end time requested by the user\n                finalEvents = cachedEvents.filter((event)=>{\n                    const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                    const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                    // Ensure valid dates before comparison\n                    if (!eventStart.isValid || !eventEnd.isValid) return false;\n                    // Event overlaps with the requested range [startDt, endDt)\n                    return eventStart < endDt && eventEnd > startDt;\n                });\n                console.log(`Filtered ${cachedEvents.length} cached events down to ${finalEvents.length} for exact range.`);\n            } else {\n                console.log(`Cache MISS for events ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // Fetch from Google Calendar API for the *exact* requested range\n                const apiEvents = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.getCalendarEvents)(tokens, startDt.toJSDate(), endDt.toJSDate()); // Fetch exact range\n                if (apiEvents && Array.isArray(apiEvents)) {\n                    finalEvents = apiEvents; // Use the precisely fetched events\n                    console.log(`Fetched ${finalEvents.length} events from API for range ${startDt.toISO()} - ${endDt.toISO()}.`);\n                    // Cache the result using the daily range key for potential future broader queries\n                    // Cache the events fetched for the *exact* range, but use the *daily* key\n                    // This means subsequent wider queries might hit cache, but specific narrow queries within the day will still filter\n                    await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.cacheEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd, finalEvents, 300); // 5 min TTL\n                    console.log(`Stored ${finalEvents.length} events in Redis cache under key range ${cacheKeyStart} to ${cacheKeyEnd}`);\n                } else {\n                    console.warn(`No events returned or non-array from fetchGCalendarEventsInternal for ${startDt.toISO()}-${endDt.toISO()}`);\n                    finalEvents = []; // Ensure it's an empty array on failure or no results\n                }\n            }\n            // Enrich events with metadata if there are any events\n            if (finalEvents.length > 0 && userId !== \"default\") {\n                try {\n                    // Extract all Google event IDs\n                    const googleEventIds = finalEvents.map((event)=>event.id).filter((id)=>id); // Filter out potential null/undefined IDs\n                    if (googleEventIds.length > 0) {\n                        // Fetch metadata for all events in a single batch query\n                        const metadataRecords = await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.getEventMetadataBatch)(userId, googleEventIds);\n                        // Create a lookup map for efficient access\n                        const metadataMap = new Map();\n                        metadataRecords.forEach((record)=>{\n                            metadataMap.set(record.google_event_id, record);\n                        });\n                        // Enrich events with metadata\n                        finalEvents = finalEvents.map((event)=>{\n                            const metadata = metadataMap.get(event.id);\n                            if (metadata) {\n                                // Add only non-null metadata fields\n                                const enrichment = {};\n                                if (metadata.priority !== null) enrichment.priority = metadata.priority;\n                                if (metadata.tags !== null && metadata.tags.length > 0) enrichment.tags = metadata.tags;\n                                return {\n                                    ...event,\n                                    ...enrichment\n                                };\n                            }\n                            return event; // Return original event if no metadata found\n                        });\n                        console.log(`Enriched ${metadataMap.size} events with metadata.`);\n                    }\n                } catch (metadataError) {\n                    console.error(`Error fetching or merging event metadata:`, metadataError);\n                // Proceed without metadata, but log the error\n                }\n            }\n            console.log(\"DEBUG: toolFunctions.getCalendarEvents is returning:\", JSON.stringify(finalEvents, null, 2)); // Keep debug log\n            return finalEvents; // Return just the events array\n        } catch (error) {\n            console.error(`Error in getCalendarEvents tool (${start_date} to ${end_date}):`, error);\n            // Provide a user-friendly structured error message\n            throw new Error(`Failed to fetch calendar events: ${error.message}. Check connection or permissions.`);\n        }\n    },\n    deleteCalendarEvent: async (args, userId = \"default\", accessToken = null)=>{\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false,\n            eventId: args.eventId\n        };\n        const tokens = {\n            access_token: accessToken\n        };\n        const { eventId } = args;\n        if (!eventId) return {\n            error: \"Event ID is required.\",\n            success: false\n        };\n        let originalStartDate, originalEndDate, eventSummary = eventId; // Default summary to ID\n        try {\n            // 1. Get the event details first for cache invalidation and user feedback\n            const oauth2Client = (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.createOAuth2Client)(tokens);\n            const calendar = googleapis__WEBPACK_IMPORTED_MODULE_1__.google.calendar({\n                version: \"v3\",\n                auth: oauth2Client\n            });\n            try {\n                console.log(`Fetching event details for deletion: ${eventId}`);\n                const event = await calendar.events.get({\n                    calendarId: \"primary\",\n                    eventId: eventId\n                });\n                originalStartDate = event.data.start?.dateTime || event.data.start?.date;\n                originalEndDate = event.data.end?.dateTime || event.data.end?.date;\n                eventSummary = event.data.summary || eventId;\n                console.log(`Found event \"${eventSummary}\" starting ${originalStartDate} for deletion.`);\n            } catch (getError) {\n                if (getError.code === 404) {\n                    console.log(`Event ${eventId} not found for deletion (may already be deleted).`);\n                    // Consider this a \"success\" in the sense that the desired state (event gone) is achieved.\n                    return {\n                        success: true,\n                        message: `Event ${eventId} not found (already deleted?).`,\n                        eventId: eventId,\n                        summary: eventSummary\n                    };\n                }\n                // Rethrow other errors during get\n                throw new Error(`Failed to retrieve event details before delete: ${getError.message}`);\n            }\n            // 2. Delete the event via internal function\n            console.log(`Attempting to delete event: ${eventId}`);\n            await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.deleteCalendarEvent)(tokens, eventId); // Assumes this throws on API error\n            console.log(`Successfully deleted event from Google Calendar: ${eventId}`);\n            // 3. Delete associated metadata\n            if (userId !== \"default\") {\n                try {\n                    await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.deleteEventMetadata)(userId, eventId);\n                    console.log(`Successfully deleted metadata for event: ${eventId}`);\n                } catch (metadataError) {\n                    console.error(`Error deleting metadata for event ${eventId} (proceeding anyway):`, metadataError);\n                // Log error but don't fail the overall deletion if calendar delete succeeded\n                }\n            }\n            // 4. Invalidate cache for the event's date range\n            if (originalStartDate && originalEndDate) {\n                try {\n                    await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, originalStartDate, originalEndDate);\n                    console.log(`Invalidated cache for range: ${originalStartDate} - ${originalEndDate}`);\n                } catch (cacheError) {\n                    console.error(\"Error invalidating cache after delete:\", cacheError);\n                }\n            } else {\n                console.warn(`Could not determine date range for event ${eventId}, invalidating token cache.`);\n                try {\n                    await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens); // Invalidate broader cache associated with token\n                } catch (cacheError) {\n                    console.error(\"Error invalidating cache after delete (fallback):\", cacheError);\n                }\n            }\n            return {\n                success: true,\n                message: `Successfully deleted event: \"${eventSummary}\"`,\n                eventId: eventId,\n                summary: eventSummary\n            }; // Return success object\n        } catch (error) {\n            console.error(`Error deleting event ${eventId}:`, error);\n            // Don't invalidate cache on error here, as the state is uncertain\n            return {\n                success: false,\n                error: `Failed to delete event ${eventId} (${eventSummary}): ${error.message}`,\n                eventId: eventId,\n                summary: eventSummary // Include summary if retrieved\n            };\n        }\n    },\n    updateCalendarEvent: async (args, userId = \"default\", accessToken = null)=>{\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false,\n            eventId: args.eventId\n        };\n        const tokens = {\n            access_token: accessToken\n        };\n        const { eventId, updates } = args;\n        if (!eventId || !updates || typeof updates !== \"object\" || Object.keys(updates).length === 0) {\n            return {\n                error: \"Event ID and a non-empty updates object are required.\",\n                success: false,\n                eventId: eventId\n            };\n        }\n        // Validate update values (basic check for ISO dates if provided)\n        let updateStartDt, updateEndDt;\n        try {\n            if (updates.start) {\n                updateStartDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(updates.start);\n                if (!updateStartDt.isValid) throw new Error(\"Invalid start date format\");\n            }\n            if (updates.end) {\n                updateEndDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(updates.end);\n                if (!updateEndDt.isValid) throw new Error(\"Invalid end date format\");\n            }\n        // Use retrieved original times if only one end of the date is provided in updates\n        // (This requires getting the original event *first*)\n        // We will perform this check after fetching the original event.\n        } catch (validationError) {\n            return {\n                error: `Invalid update data: ${validationError.message}. Use ISO 8601 format.`,\n                success: false,\n                eventId: eventId\n            };\n        }\n        let originalStartDate, originalEndDate, originalSummary = eventId;\n        try {\n            // 1. Get original event times for cache invalidation and potential date logic\n            const oauth2Client = (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.createOAuth2Client)(tokens);\n            const calendar = googleapis__WEBPACK_IMPORTED_MODULE_1__.google.calendar({\n                version: \"v3\",\n                auth: oauth2Client\n            });\n            let originalEventData;\n            try {\n                console.log(`Fetching event details for update: ${eventId}`);\n                const eventResponse = await calendar.events.get({\n                    calendarId: \"primary\",\n                    eventId: eventId\n                });\n                originalEventData = eventResponse.data;\n                originalStartDate = originalEventData.start?.dateTime || originalEventData.start?.date;\n                originalEndDate = originalEventData.end?.dateTime || originalEventData.end?.date;\n                originalSummary = originalEventData.summary || eventId;\n                console.log(`Found event \"${originalSummary}\" starting ${originalStartDate} for update.`);\n            } catch (getError) {\n                if (getError.code === 404) {\n                    return {\n                        success: false,\n                        error: `Event ${eventId} not found for update.`,\n                        eventId: eventId\n                    };\n                }\n                throw new Error(`Failed to retrieve event details before update: ${getError.message}`);\n            }\n            // Refined Date Validation: Check start < end using original dates if needed\n            const finalStart = updates.start ? updateStartDt : luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(originalStartDate);\n            const finalEnd = updates.end ? updateEndDt : luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(originalEndDate);\n            if (finalStart.isValid && finalEnd.isValid && finalStart >= finalEnd) {\n                throw new Error(\"Start time must be before end time after updates are applied.\");\n            }\n            // 2. Update the event via internal function\n            console.log(`Attempting to update event: ${eventId} with updates:`, updates);\n            // Pass only the fields present in the 'updates' object\n            const updatePayload = {\n                ...updates\n            }; // Shallow copy\n            const updatedEvent = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.updateCalendarEvent)(tokens, eventId, updatePayload); // Assume throws on API error\n            console.log(`Successfully updated event in Google Calendar: ${eventId}`);\n            // 3. Update metadata if priority or tags are provided in the updates\n            const hasMetadataUpdate = updates.priority !== undefined || updates.tags !== undefined;\n            if (hasMetadataUpdate && userId !== \"default\") {\n                try {\n                    // We only update the fields provided in the 'updates' object.\n                    // createOrUpdateEventMetadata handles merging/overwriting correctly.\n                    await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.createOrUpdateEventMetadata)(userId, eventId, {\n                        priority: updates.priority,\n                        tags: updates.tags // Will be null if undefined, handled by DB function\n                    });\n                    console.log(`Metadata updated for event ${eventId}.`);\n                } catch (metadataError) {\n                    console.error(`Error updating metadata for event ${eventId} (proceeding anyway):`, metadataError);\n                    // Attach metadata error info to the result, but don't fail the update\n                    updatedEvent.metadataError = `Failed to update metadata: ${metadataError.message}`;\n                }\n            }\n            // 4. Invalidate cache for both original and new ranges\n            const rangesToInvalidate = [];\n            if (originalStartDate && originalEndDate) rangesToInvalidate.push({\n                start: originalStartDate,\n                end: originalEndDate\n            });\n            // Use updated event data for the new range\n            const newStartDate = updatedEvent.start?.dateTime || updatedEvent.start?.date;\n            const newEndDate = updatedEvent.end?.dateTime || updatedEvent.end?.date;\n            if (newStartDate && newEndDate) rangesToInvalidate.push({\n                start: newStartDate,\n                end: newEndDate\n            });\n            if (rangesToInvalidate.length > 0) {\n                // Deduplicate ranges before invalidating\n                const uniqueRanges = [\n                    ...new Set(rangesToInvalidate.map((r)=>`${r.start}|${r.end}`))\n                ].map((s)=>{\n                    const [start, end] = s.split(\"|\");\n                    return {\n                        start,\n                        end\n                    };\n                });\n                console.log(\"Invalidating cache ranges:\", uniqueRanges);\n                for (const range of uniqueRanges){\n                    try {\n                        await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, range.start, range.end);\n                        console.log(`Invalidated cache for range: ${range.start} - ${range.end}`);\n                    } catch (cacheError) {\n                        console.error(`Error invalidating cache range ${range.start}-${range.end}:`, cacheError);\n                    }\n                }\n            } else {\n                console.warn(`Could not determine date range(s) for event ${eventId} update, invalidating token cache.`);\n                try {\n                    await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens); // Fallback invalidate\n                } catch (cacheError) {\n                    console.error(\"Error invalidating cache after update (fallback):\", cacheError);\n                }\n            }\n            // Return the updated event object from the API, adding a success flag\n            return {\n                ...updatedEvent,\n                success: true\n            };\n        } catch (error) {\n            console.error(`Error updating event ${eventId}:`, error);\n            return {\n                success: false,\n                error: `Failed to update event ${eventId} (${originalSummary || eventId}): ${error.message}`,\n                eventId: eventId,\n                summary: originalSummary // Include original summary if retrieved\n            };\n        }\n    },\n    findAvailableSlots: async (args, userId = \"default\", accessToken = null)=>{\n        if (!accessToken) return {\n            error: \"User not authenticated.\",\n            success: false,\n            slots: []\n        };\n        const tokens = {\n            access_token: accessToken\n        };\n        const { duration, startDate: reqStartDate, endDate: reqEndDate, timePreference = \"any\", activity = \"event\" } = args;\n        if (!duration || typeof duration !== \"number\" || duration <= 0) {\n            return {\n                error: \"Valid duration (in minutes) is required.\",\n                success: false,\n                slots: []\n            };\n        }\n        // Define search range with defaults\n        const now = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        const startDate = reqStartDate ? luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(reqStartDate) : now;\n        // Default end date is 7 days from the resolved start date\n        const endDate1 = reqEndDate ? luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(reqEndDate) : startDate.plus({\n            days: 7\n        });\n        if (!startDate.isValid || !endDate1.isValid) {\n            return {\n                error: `Invalid date format. Use ISO 8601. Received start=${reqStartDate}, end=${reqEndDate}`,\n                success: false,\n                slots: []\n            };\n        }\n        if (startDate >= endDate1) {\n            return {\n                error: \"Start date must be before end date.\",\n                success: false,\n                slots: []\n            };\n        }\n        let fetchedEvents = []; // Initialize events array\n        try {\n            // Fetch events for the *entire* potential search range first (cache-aware)\n            // Use daily granularity for cache keys\n            const cacheKeyStart = startDate.startOf(\"day\").toISODate();\n            const cacheKeyEnd = endDate1.endOf(\"day\").toISODate(); // Inclusive end day for key\n            const tokenHash = accessToken.substring(accessToken.length - 10);\n            const userIdCachePrefix = `user_${tokenHash}`;\n            let cachedEvents = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n            if (cachedEvents) {\n                console.log(`Cache HIT for slot search events ${cacheKeyStart} to ${cacheKeyEnd}`);\n                fetchedEvents = cachedEvents; // Use cached events (will be filtered later)\n            } else {\n                console.log(`Cache MISS for slot search events ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // Fetch events covering the *broadest* possible range (start of start day to end of end day) for caching\n                const apiEvents = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.getCalendarEvents)(tokens, startDate.startOf(\"day\").toJSDate(), endDate1.endOf(\"day\").toJSDate());\n                if (apiEvents && Array.isArray(apiEvents)) {\n                    fetchedEvents = apiEvents;\n                    await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.cacheEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd, fetchedEvents, 300); // Cache the broad fetch\n                    console.log(`Fetched and cached ${fetchedEvents.length} events for slot search.`);\n                } else {\n                    fetchedEvents = []; // Assume no events if fetch fails\n                    console.warn(`No events returned or fetch failed for slot search range.`);\n                }\n            }\n            // Filter the fetched events (from cache or API) to the precise requested time window *before* finding slots\n            const relevantEvents = fetchedEvents.filter((event)=>{\n                const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                // Check overlap with the *precise* user-requested range [startDate, endDate)\n                return eventStart.isValid && eventEnd.isValid && eventStart < endDate1 && eventEnd > startDate;\n            });\n            console.log(`Filtered ${fetchedEvents.length} events down to ${relevantEvents.length} relevant for the precise slot search window.`);\n            // Use the imported utility function (renamed to avoid conflict)\n            const slotsResult = await (0,_schedulingUtils_js__WEBPACK_IMPORTED_MODULE_5__.findAvailableSlots)(relevantEvents, duration, startDate.toISO(), endDate1.toISO(), timePreference, activity // Pass activity directly\n            );\n            // findAvailableSlotsUtil should return an object like { slots: [...] } or { error: ..., slots: [] }\n            // Return the result directly, adding a success flag based on whether an error occurred within the util\n            // Return the slots array directly\n            if (slotsResult.error) {\n                throw new Error(slotsResult.error);\n            }\n            return slotsResult.slots || [];\n        } catch (error) {\n            console.error(`Error in findAvailableSlots tool (${duration}min, ${startDate.toISO()} to ${endDate1.toISO()}):`, error);\n            // Return a structured error object\n            throw new Error(`Failed to find available slots: ${error.message}`);\n        }\n    },\n    getWeatherForecast: async (args, userId = \"default\", accessToken = null)=>{\n        // Placeholder - requires actual weather API integration\n        const { location, date: dateString } = args;\n        if (!location) return {\n            error: \"Location is required for weather forecast.\",\n            success: false\n        };\n        // Default to today if date is missing or invalid\n        let forecastDate = dateString ? luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(dateString) : luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        if (!forecastDate.isValid) {\n            console.warn(`Invalid date provided for weather forecast: ${dateString}. Defaulting to today.`);\n            forecastDate = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.now();\n        }\n        const formattedDate = forecastDate.toISODate(); // YYYY-MM-DD\n        console.log(`Placeholder: Fetching weather for ${location} on ${formattedDate}`);\n        try {\n            // --- Replace with actual weather API call ---\n            // Example: const weatherData = await getWeatherData(location, formattedDate);\n            // return { ...weatherData, success: true };\n            // --- Placeholder response ---\n            return {\n                success: false,\n                location: location,\n                date: formattedDate,\n                forecast: `Weather data for ${location} on ${formattedDate} is currently unavailable (feature not implemented).`,\n                error: \"Weather API integration is pending.\"\n            };\n        } catch (error) {\n            console.error(`Error fetching weather for ${location}, ${formattedDate}:`, error);\n            return {\n                success: false,\n                location: location,\n                date: formattedDate,\n                error: `Failed to get weather forecast: ${error.message}`\n            };\n        }\n    },\n    deleteCalendarEventsByQuery: async (args, userId = \"default\", accessToken = null)=>{\n        if (!accessToken) {\n            return {\n                error: \"User not authenticated.\",\n                success: false,\n                deletedCount: 0\n            };\n        }\n        const tokens = {\n            access_token: accessToken\n        };\n        const { query, start_date, end_date } = args;\n        if (!query || !start_date || !end_date) {\n            return {\n                error: \"Query, start date, and end date are required.\",\n                success: false,\n                deletedCount: 0\n            };\n        }\n        const startDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(start_date);\n        const endDt = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(end_date);\n        if (!startDt.isValid || !endDt.isValid) {\n            return {\n                error: `Invalid date format. Use ISO 8601.`,\n                success: false,\n                deletedCount: 0\n            };\n        }\n        if (startDt >= endDt) {\n            return {\n                error: \"Start date must be before end date.\",\n                success: false,\n                deletedCount: 0\n            };\n        }\n        console.log(`Attempting to delete events matching \"${query}\" between ${startDt.toISO()} and ${endDt.toISO()}`);\n        let fetchedEvents = []; // Initialize events array\n        try {\n            // 1. Get all events potentially in the range (use cache)\n            const cacheKeyStart = startDt.startOf(\"day\").toISODate();\n            const cacheKeyEnd = endDt.endOf(\"day\").toISODate(); // Inclusive end day\n            const tokenHash = accessToken.substring(accessToken.length - 10);\n            const userIdCachePrefix = `user_${tokenHash}`;\n            let cachedEvents = await (0,_redisClient_js__WEBPACK_IMPORTED_MODULE_3__.getCachedEventsForDateRange)(userIdCachePrefix, cacheKeyStart, cacheKeyEnd);\n            if (cachedEvents) {\n                console.log(`Cache HIT for bulk delete search ${cacheKeyStart} to ${cacheKeyEnd}`);\n                fetchedEvents = cachedEvents;\n            } else {\n                console.log(`Cache MISS for bulk delete search ${cacheKeyStart} to ${cacheKeyEnd}`);\n                // Fetch broadly for potential caching benefit if deletion fails or is partial\n                const apiEvents = await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.getCalendarEvents)(tokens, startDt.startOf(\"day\").toJSDate(), endDate.endOf(\"day\").toJSDate());\n                fetchedEvents = Array.isArray(apiEvents) ? apiEvents : [];\n                // Don't cache here immediately, as we might delete many. Cache might get invalidated anyway.\n                console.log(`Fetched ${fetchedEvents.length} potential events for bulk delete query.`);\n            }\n            // 2. Filter fetched events precisely by requested time *and* query\n            const queryLower = query.toLowerCase();\n            const matchingEvents = fetchedEvents.filter((event)=>{\n                const eventStart = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.start?.dateTime || event.start?.date);\n                const eventEnd = luxon__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(event.end?.dateTime || event.end?.date);\n                const summaryLower = event.summary?.toLowerCase() || \"\";\n                return eventStart.isValid && eventEnd.isValid && eventStart < endDt && eventEnd > startDt && // Check time overlap with precise range\n                summaryLower.includes(queryLower); // Check summary match\n            });\n            if (matchingEvents.length === 0) {\n                console.log(`No events matching \"${query}\" found in the specified range.`);\n                return {\n                    success: true,\n                    message: `No events matching \"${query}\" found.`,\n                    deletedCount: 0\n                };\n            }\n            console.log(`Found ${matchingEvents.length} events matching query. Proceeding with deletion...`);\n            // 3. Delete each matching event and invalidate cache individually\n            const deleteResults = [];\n            const failedDeletes = [];\n            const invalidatedRanges = new Set(); // Track ranges to invalidate efficiently\n            for (const event of matchingEvents){\n                try {\n                    // Delete from Google Calendar\n                    await (0,_googleCalendar_js__WEBPACK_IMPORTED_MODULE_2__.deleteCalendarEvent)(tokens, event.id);\n                    console.log(`Successfully deleted event from Google Calendar: ${event.id} (\"${event.summary}\")`);\n                    // Delete associated metadata\n                    if (userId !== \"default\") {\n                        try {\n                            await (0,_postgresClient_js__WEBPACK_IMPORTED_MODULE_8__.deleteEventMetadata)(userId, event.id);\n                            console.log(`Successfully deleted metadata for event: ${event.id}`);\n                        } catch (metadataError) {\n                            console.error(`Error deleting metadata for event ${event.id} during bulk delete (proceeding):`, metadataError);\n                        // Log but don't count as a primary failure\n                        }\n                    }\n                    deleteResults.push({\n                        id: event.id,\n                        summary: event.summary\n                    });\n                    // Add event's range to the set for cache invalidation\n                    const eventStartIso = event.start?.dateTime || event.start?.date;\n                    const eventEndIso = event.end?.dateTime || event.end?.date;\n                    if (eventStartIso && eventEndIso) {\n                        invalidatedRanges.add(`${eventStartIso}|${eventEndIso}`);\n                    }\n                } catch (deleteError) {\n                    console.error(`Failed to delete event ${event.id} (\"${event.summary}\") during bulk operation:`, deleteError);\n                    failedDeletes.push({\n                        id: event.id,\n                        summary: event.summary,\n                        error: deleteError.message\n                    });\n                }\n            }\n            // 4. Invalidate cache for all affected ranges\n            if (invalidatedRanges.size > 0) {\n                console.log(`Invalidating cache for ${invalidatedRanges.size} unique date ranges.`);\n                for (const rangeString of invalidatedRanges){\n                    const [start, end] = rangeString.split(\"|\");\n                    try {\n                        await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens, start, end);\n                        console.log(`Invalidated cache range: ${start} - ${end}`);\n                    } catch (cacheError) {\n                        console.error(`Cache invalidation error during bulk delete for range ${start}-${end}:`, cacheError);\n                    }\n                }\n            } else if (deleteResults.length > 0) {\n                // If deletes succeeded but ranges couldn't be determined, invalidate broadly\n                console.warn(\"Could not determine specific ranges for cache invalidation during bulk delete, invalidating token cache.\");\n                try {\n                    await (0,_services_cacheService_js__WEBPACK_IMPORTED_MODULE_4__.invalidateCache)(tokens);\n                } catch (cacheError) {\n                    console.error(\"Error invalidating cache after bulk delete (fallback):\", cacheError);\n                }\n            }\n            // 5. Compile and return result\n            const successCount = deleteResults.length;\n            let message = `Successfully deleted ${successCount} event(s) matching \"${query}\".`;\n            if (failedDeletes.length > 0) {\n                message += ` Failed to delete ${failedDeletes.length} event(s). Check logs for details.`;\n                console.warn(\"Failures during bulk delete:\", failedDeletes);\n            }\n            return {\n                success: failedDeletes.length === 0,\n                message: message,\n                deletedCount: successCount,\n                deletedItems: deleteResults,\n                failedItems: failedDeletes // List failures\n            };\n        } catch (error) {\n            console.error(`Critical error during deleteCalendarEventsByQuery (${query}, ${start_date}-${end_date}):`, error);\n            return {\n                success: false,\n                error: `An unexpected error occurred during the bulk delete operation: ${error.message}`,\n                deletedCount: 0\n            };\n        }\n    }\n};\n// --- Exports ---\n// Export the schema and the implementation map\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixLQUFLLENBQUMsMERBQTBEa0M7Z0JBQWE7WUFDN0c7WUFHQSwrQkFBK0I7WUFDOUIsTUFBTTRGLGVBQWVSLGNBQWNoSCxNQUFNO1lBQ3pDLElBQUkxQixVQUFVLENBQUMscUJBQXFCLEVBQUVrSixhQUFhLG9CQUFvQixFQUFFekosTUFBTSxFQUFFLENBQUM7WUFDbEYsSUFBSWtKLGNBQWNqSCxNQUFNLEdBQUcsR0FBRztnQkFDMUIxQixXQUFXLENBQUMsa0JBQWtCLEVBQUUySSxjQUFjakgsTUFBTSxDQUFDLGtDQUFrQyxDQUFDO2dCQUN4RnpCLFFBQVF5QyxJQUFJLENBQUMsZ0NBQWdDaUc7WUFDakQ7WUFFRCxPQUFPO2dCQUNINUksU0FBUzRJLGNBQWNqSCxNQUFNLEtBQUs7Z0JBQ2xDMUIsU0FBU0E7Z0JBQ1RvSSxjQUFjYztnQkFDZEMsY0FBY1Q7Z0JBQ2RVLGFBQWFULGNBQWdCLGdCQUFnQjtZQUNqRDtRQUVKLEVBQUUsT0FBT3ZILE9BQU87WUFDWm5CLFFBQVFtQixLQUFLLENBQUMsQ0FBQyxtREFBbUQsRUFBRTNCLE1BQU0sRUFBRSxFQUFFWCxXQUFXLENBQUMsRUFBRUMsU0FBUyxFQUFFLENBQUMsRUFBRXFDO1lBQ3pHLE9BQU87Z0JBQ0hyQixTQUFTO2dCQUNUcUIsT0FBTyxDQUFDLCtEQUErRCxFQUFFQSxNQUFNcEIsT0FBTyxDQUFDLENBQUM7Z0JBQ3hGb0ksY0FBYztZQUNsQjtRQUNMO0lBQ0o7QUFDSjtBQUVBLGtCQUFrQjtBQUNsQiwrQ0FBK0M7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL2xpYi90b29scy90b29sSW5kZXguanM/MWE0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvdG9vbHMvaW5kZXguanNcbi8vIFB1cnBvc2U6IERlZmluZXMgdGhlIHRvb2xzIChzY2hlbWEpIGF2YWlsYWJsZSB0byB0aGUgTExNIGFuZCBtYXBzIHRoZW1cbi8vICAgICAgICAgIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25zLiBBbHNvIGluY2x1ZGVzXG4vLyAgICAgICAgICBoZWxwZXIgZnVuY3Rpb25zIGZvciBwcm9jZXNzaW5nIHRvb2wgY2FsbHMuXG5cbi8vIC0tLSBJTVBPUlRTIC0tLVxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgeyBnb29nbGUgfSBmcm9tICdnb29nbGVhcGlzJzsgLy8gVXNlZCBmb3IgZ2V0L3VwZGF0ZSBldmVudCBiZWZvcmUgY2FsbGluZyBzcGVjaWZpYyBmdW5jdGlvbnNcblxuLy8gSW1wb3J0IGZyb20gZ29vZ2xlQ2FsZW5kYXIuanNcbmltcG9ydCB7XG4gICAgY3JlYXRlT0F1dGgyQ2xpZW50LFxuICAgIGdldENhbGVuZGFyRXZlbnRzIGFzIGZldGNoR0NhbGVuZGFyRXZlbnRzSW50ZXJuYWwsIC8vIFJlbmFtZWQgdG8gYXZvaWQgY29uZmxpY3RcbiAgICBhZGRDYWxlbmRhckV2ZW50IGFzIGFkZEdDYWxlbmRhckV2ZW50SW50ZXJuYWwsXG4gICAgZGVsZXRlQ2FsZW5kYXJFdmVudCBhcyBkZWxldGVHQ2FsZW5kYXJFdmVudEludGVybmFsLFxuICAgIHVwZGF0ZUNhbGVuZGFyRXZlbnQgYXMgdXBkYXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbFxufSBmcm9tICcuLi8uLi9nb29nbGVDYWxlbmRhci5qcyc7XG5cbi8vIEltcG9ydCBmcm9tIHJlZGlzQ2xpZW50LmpzXG5pbXBvcnQge1xuICAgIGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSxcbiAgICBjYWNoZUV2ZW50c0ZvckRhdGVSYW5nZSxcbiAgICAvLyBpbnZhbGlkYXRlRGF0ZVJhbmdlQ2FjaGUsIC8vIFJlcGxhY2VkIGJ5IGludmFsaWRhdGVDYWNoZSBmcm9tIGNhY2hlU2VydmljZVxufSBmcm9tICcuLi9yZWRpc0NsaWVudC5qcyc7XG5cbi8vIEltcG9ydCBmcm9tIGNhY2hlU2VydmljZS5qc1xuaW1wb3J0IHtcbiAgICAvLyBnZXRDYWNoZWRFdmVudHMsIC8vIE5vdCB1c2VkIGRpcmVjdGx5LCB1c2luZyByZWRpc0NsaWVudCBzcGVjaWZpYyByYW5nZSBmdW5jdGlvbnNcbiAgICBpbnZhbGlkYXRlQ2FjaGUgLy8gVXNlZCBmb3IgaW52YWxpZGF0aW5nIGJhc2VkIG9uIHJhbmdlcyBvciB0b2tlbnNcbn0gZnJvbSAnLi4vc2VydmljZXMvY2FjaGVTZXJ2aWNlLmpzJztcblxuLy8gSW1wb3J0IGZyb20gc2NoZWR1bGluZ1V0aWxzLmpzXG5pbXBvcnQgeyBmaW5kQXZhaWxhYmxlU2xvdHMgYXMgZmluZEF2YWlsYWJsZVNsb3RzVXRpbCB9IGZyb20gJy4vc2NoZWR1bGluZ1V0aWxzLmpzJzsgLy8gUmVuYW1lZCB0byBhdm9pZCBjb25mbGljdCB3aXRoIHRvb2wgbmFtZVxuXG4vLyBJbXBvcnQgZnJvbSBjaGVja0ZvckNvbmZsaWN0cy5qc1xuaW1wb3J0IHsgY2hlY2tGb3JDb25mbGljdHMgfSBmcm9tICcuL2NoZWNrRm9yQ29uZmxpY3RzLmpzJztcblxuLy8gSW1wb3J0IGZyb20gdGltZVV0aWxzLmpzXG5pbXBvcnQgeyBnZXRVc2VyVGltZXpvbmUsIGNvbnZlcnRUb1VUQ0lTT1N0cmluZyB9IGZyb20gJy4vdGltZVV0aWxzLmpzJztcblxuLy8gSW1wb3J0IGZyb20gZm9ybWF0dGVycy5qcyAtIEFzc3VtaW5nIHRoZXNlIG1pZ2h0IGJlIHVzZWQgYnkgdGhlIGNhbGxlciwgbm90IGRpcmVjdGx5IGhlcmVcbi8vIGltcG9ydCB7IGZvcm1hdEV2ZW50VGltZSwgZm9ybWF0Q2FsZW5kYXJFdmVudHMsIGZvcm1hdFRvb2xSZXNwb25zZSB9IGZyb20gJy4vZm9ybWF0dGVycy5qcyc7XG5cbi8vIEltcG9ydCBmcm9tIHBvc3RncmVzQ2xpZW50LmpzXG5pbXBvcnQge1xuICAgIFVzZXJQcmVmZXJlbmNlLCAvLyBBc3N1bWluZyBtb2RlbHMgYXJlIGV4cG9ydGVkIGZyb20gcG9zdGdyZXNDbGllbnRcbiAgICBhZGRNZXNzYWdlVG9Db252ZXJzYXRpb24sIC8vIE5lZWRlZCBieSBwb3RlbnRpYWwgcHJvY2Vzc1Rvb2xDYWxscyAtICpUaGlzIGlkZWFsbHkgYmVsb25ncyBpbiBkYXRhYmFzZVNlcnZpY2UqXG4gICAgY3JlYXRlT3JVcGRhdGVFdmVudE1ldGFkYXRhLFxuICAgIGdldEV2ZW50TWV0YWRhdGFCYXRjaCxcbiAgICBkZWxldGVFdmVudE1ldGFkYXRhIC8vIENvcnJlY3RlZDogTWlzc2luZyBjb21tYSBhZGRlZFxufSBmcm9tICcuLi9wb3N0Z3Jlc0NsaWVudC5qcyc7XG5cblxuLy8gLS0tIFRvb2wgU2NoZW1hIERlZmluaXRpb25zIChmb3IgT3BlbkFJKSAtLS1cbmNvbnN0IHRvb2xzID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogXCJzYXZlVXNlclByZWZlcmVuY2VcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlNhdmUgYSB1c2VyIHByZWZlcmVuY2UgZm9yIGZ1dHVyZSByZWZlcmVuY2UuIFVzZSB0aGlzIHdoZW4geW91IGlkZW50aWZ5IGltcG9ydGFudCB1c2VyIHByZWZlcmVuY2VzIChsaWtlIHByZWZlcnJlZCBtZWV0aW5nIHRpbWVzLCBsb2NhdGlvbnMsIGFjdGl2aXR5IHR5cGVzLCBzY2hlZHVsaW5nIGNvbnN0cmFpbnRzKSB0aGF0IHNob3VsZCBiZSByZW1lbWJlcmVkIGxvbmctdGVybS5cIixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIGJyb2FkIGNhdGVnb3J5IG9mIHRoZSBwcmVmZXJlbmNlIChlLmcuLCAnc2NoZWR1bGluZycsICdsb2NhdGlvbicsICdhY3Rpdml0eScpLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGtleTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgc3BlY2lmaWMgcHJlZmVyZW5jZSBrZXkgd2l0aGluIHRoZSBjYXRlZ29yeSAoZS5nLiwgJ3ByZWZlcnJlZE1lZXRpbmdIb3VycycsICdkZWZhdWx0Q2l0eScsICdmYXZvcml0ZVdvcmtvdXQnKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lT2Y6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiB7fSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJvYmplY3RcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHZhbHVlIG9mIHRoZSBwcmVmZXJlbmNlIChlLmcuLCAnOWFtLTEycG0nLCAnTmV3IFlvcmsnLCAncnVubmluZycpLiBDYW4gYmUgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIGFycmF5LCBvciBvYmplY3QuXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbDogQWRkaXRpb25hbCBjb250ZXh0IGFib3V0IHdoZW4gb3Igd2h5IHRoaXMgcHJlZmVyZW5jZSBhcHBsaWVzIChlLmcuLCAnd29yayBtZWV0aW5ncycsICd3ZWVrZW5kcycpLlwiIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogW1wiY2F0ZWdvcnlcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWRkQ2FsZW5kYXJFdmVudHNcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkNyZWF0ZXMgb25lIG9yIG1vcmUgbmV3IGV2ZW50cyBkaXJlY3RseSBpbiB0aGUgdXNlcidzIHByaW1hcnkgR29vZ2xlIENhbGVuZGFyIGJhc2VkIG9uIHRoZWlyIHJlcXVlc3QuIEV4dHJhY3RzIGRldGFpbHMgbGlrZSB0aXRsZSwgbG9jYXRpb24sIGFuZCByZXNvbHZlcyBzdGFydC9lbmQgdGltZXMgKHVzaW5nIGN1cnJlbnQgdGltZSBjb250ZXh0IGZvciByZWxhdGl2ZSByZWZlcmVuY2VzIGxpa2UgJ3RvbW9ycm93IDRwbScpIGludG8gYWJzb2x1dGUgSVNPIDg2MDEgZm9ybWF0LiBBc3N1bWVzIGEgMS1ob3VyIGR1cmF0aW9uIGlmIG5vdCBzcGVjaWZpZWQuIENoZWNrcyBmb3IgY29uZmxpY3RzIGJlZm9yZSBhZGRpbmcuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgZXZlbnQgb2JqZWN0cyB0byBjcmVhdGUuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSB0aXRsZS9zdW1tYXJ5IG9mIHRoZSBldmVudCAoZS5nLiwgJ01lZXRpbmcgd2l0aCBDbHlkZScpLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBzdGFydCBkYXRlIGFuZCB0aW1lIG9mIHRoZSBldmVudCBpbiBTVFJJQ1QgSVNPIDg2MDEgZm9ybWF0IGluY2x1ZGluZyB0aW1lem9uZSBvZmZzZXQgKGUuZy4sICcyMDI1LTA0LTAxVDE2OjAwOjAwLTA3OjAwJykuIFJlc29sdmUgcmVsYXRpdmUgdGltZXMgKGxpa2UgJ3RvbW9ycm93IDRwbScpIGJhc2VkIG9uIGN1cnJlbnQgdGltZSBjb250ZXh0IGJlZm9yZSBjYWxsaW5nLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgZW5kIGRhdGUgYW5kIHRpbWUgb2YgdGhlIGV2ZW50IGluIFNUUklDVCBJU08gODYwMSBmb3JtYXQgaW5jbHVkaW5nIHRpbWV6b25lIG9mZnNldCAoZS5nLiwgJzIwMjUtMDQtMDFUMTc6MDA6MDAtMDc6MDAnKS4gUmVzb2x2ZSByZWxhdGl2ZSB0aW1lczsgYXNzdW1lIDFociBkdXJhdGlvbiBmcm9tIHN0YXJ0IGlmIGVuZCB0aW1lIGlzIG5vdCBzcGVjaWZpZWQuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiT3B0aW9uYWwgZGVzY3JpcHRpb24gb3Igbm90ZXMgZm9yIHRoZSBldmVudC5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbCBsb2NhdGlvbiBmb3IgdGhlIGV2ZW50IChlLmcuLCAnU3RhcmJ1Y2tzIE1haW4gU3QnLCAnWm9vbSBMaW5rJykuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtaW5kZXJzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJudW1iZXJcIiB9LCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbCByZW1pbmRlciB0aW1lcyBpbiBtaW51dGVzIGJlZm9yZSB0aGUgZXZlbnQgc3RhcnQgKGUuZy4sIFsxMCwgMzBdKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogeyB0eXBlOiBcInN0cmluZ1wiLCBlbnVtOiBbXCJMb3dcIiwgXCJNZWRpdW1cIiwgXCJIaWdoXCIsIFwiVXJnZW50XCJdLCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbCBwcmlvcml0eSBsZXZlbCBmb3IgdGhlIGV2ZW50LlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHsgdHlwZTogXCJhcnJheVwiLCBpdGVtczogeyB0eXBlOiBcInN0cmluZ1wiIH0sIGRlc2NyaXB0aW9uOiBcIk9wdGlvbmFsIHRhZ3MgdG8gY2F0ZWdvcml6ZSB0aGUgZXZlbnQuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVDb25mbGljdHM6IHsgdHlwZTogXCJib29sZWFuXCIsIGRlc2NyaXB0aW9uOiBcIk9wdGlvbmFsIGZsYWcgdG8gb3ZlcnJpZGUgY29uZmxpY3RzIGFuZCBhZGQgdGhlIGV2ZW50IGFueXdheS4gRGVmYXVsdCBpcyBmYWxzZS5cIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogW1wic3VtbWFyeVwiLCBcInN0YXJ0XCIsIFwiZW5kXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJldmVudHNcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiBcImdldENhbGVuZGFyRXZlbnRzXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXRyaWV2ZXMgZXZlbnRzIGZyb20gdGhlIHVzZXIncyBwcmltYXJ5IEdvb2dsZSBDYWxlbmRhciB3aXRoaW4gYSBzcGVjaWZpZWQgZGF0ZSByYW5nZS5cIixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGF0ZTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgc3RhcnQgZGF0ZS90aW1lIGZvciB0aGUgcXVlcnkgcmFuZ2UgaW4gSVNPIDg2MDEgZm9ybWF0IChlLmcuLCAnMjAyNS0wNC0wMVQwMDowMDowMFonIG9yICcyMDI1LTA0LTAxJykuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RhdGU6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIGVuZCBkYXRlL3RpbWUgZm9yIHRoZSBxdWVyeSByYW5nZSBpbiBJU08gODYwMSBmb3JtYXQgKGUuZy4sICcyMDI1LTA0LTAyVDAwOjAwOjAwWicgb3IgJzIwMjUtMDQtMDInKS5cIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFtcInN0YXJ0X2RhdGVcIiwgXCJlbmRfZGF0ZVwiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwiZGVsZXRlQ2FsZW5kYXJFdmVudFwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiRGVsZXRlcyBhIHNwZWNpZmljIGV2ZW50IGZyb20gdGhlIHVzZXIncyBwcmltYXJ5IEdvb2dsZSBDYWxlbmRhciB1c2luZyBpdHMgdW5pcXVlIGV2ZW50IElELiBSZXRyaWV2ZXMgZXZlbnQgZGV0YWlscyBmaXJzdCB0byBpbnZhbGlkYXRlIHNwZWNpZmljIGNhY2hlIHJhbmdlLlwiLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICBldmVudElkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHVuaXF1ZSBJRCBvZiB0aGUgZXZlbnQgdG8gZGVsZXRlIChlLmcuLCAnOHV0M2E2ZW9sMW92NW92djIzdjg1b3Nzc2cnKS4gVGhlIHVzZXIgbWlnaHQgcHJvdmlkZSB0aGUgZXZlbnQgdGl0bGUvdGltZSwgdXNlIGdldENhbGVuZGFyRXZlbnRzIGZpcnN0IGlmIElEIGlzIHVua25vd24uXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFtcImV2ZW50SWRcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiBcInVwZGF0ZUNhbGVuZGFyRXZlbnRcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlVwZGF0ZXMgZGV0YWlscyAobGlrZSB0aW1lLCB0aXRsZSwgbG9jYXRpb24sIGRlc2NyaXB0aW9uKSBvZiBhbiBleGlzdGluZyBldmVudCBpbiB0aGUgdXNlcidzIHByaW1hcnkgR29vZ2xlIENhbGVuZGFyIHVzaW5nIGl0cyBJRC5cIixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRJZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSB1bmlxdWUgSUQgb2YgdGhlIGV2ZW50IHRvIHVwZGF0ZSAoZS5nLiwgJzh1dDNhNmVvbDFvdjVvdnYyM3Y4NW9zc3NnJykuIFRoZSB1c2VyIG1pZ2h0IHByb3ZpZGUgdGhlIGV2ZW50IHRpdGxlL3RpbWUsIHVzZSBnZXRDYWxlbmRhckV2ZW50cyBmaXJzdCBpZiBJRCBpcyB1bmtub3duLlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJOZXcgdGl0bGUvc3VtbWFyeSBmb3IgdGhlIGV2ZW50LlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiTmV3IGRlc2NyaXB0aW9uIGZvciB0aGUgZXZlbnQuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJOZXcgbG9jYXRpb24gZm9yIHRoZSBldmVudC5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIk5ldyBzdGFydCB0aW1lIGluIElTTyA4NjAxIGZvcm1hdCAoZS5nLiwgJzIwMjUtMDQtMDFUMTY6MzA6MDAtMDc6MDAnKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJOZXcgZW5kIHRpbWUgaW4gSVNPIDg2MDEgZm9ybWF0IChlLmcuLCAnMjAyNS0wNC0wMVQxNzowMDowMC0wNzowMCcpLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogW1wiTG93XCIsIFwiTWVkaXVtXCIsIFwiSGlnaFwiLCBcIlVyZ2VudFwiXSwgZGVzY3JpcHRpb246IFwiT3B0aW9uYWwgcHJpb3JpdHkgbGV2ZWwgZm9yIHRoZSBldmVudC5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHsgdHlwZTogXCJhcnJheVwiLCBpdGVtczogeyB0eXBlOiBcInN0cmluZ1wiIH0sIGRlc2NyaXB0aW9uOiBcIk9wdGlvbmFsIHRhZ3MgdG8gY2F0ZWdvcml6ZSB0aGUgZXZlbnQuXCIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEFkZCByZW1pbmRlcnMgdXBkYXRlIGlmIG5lZWRlZC9pbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk9iamVjdCBjb250YWluaW5nIEFUIExFQVNUIE9ORSBmaWVsZCB0byB1cGRhdGUuIEluY2x1ZGUgb25seSBmaWVsZHMgdGhhdCBhcmUgY2hhbmdpbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Qcm9wZXJ0aWVzOiAxIC8vIEVuc3VyZSBhdCBsZWFzdCBvbmUgdXBkYXRlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJldmVudElkXCIsIFwidXBkYXRlc1wiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwiZmluZEF2YWlsYWJsZVNsb3RzXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJGaW5kcyBtdWx0aXBsZSBhdmFpbGFibGUgdGltZSBzbG90cyBpbiB0aGUgdXNlcidzIGNhbGVuZGFyIHN1aXRhYmxlIGZvciBzY2hlZHVsaW5nIGEgbmV3IGV2ZW50LiBDb25zaWRlcnMgZXhpc3RpbmcgZXZlbnRzLlwiLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB0eXBlOiBcIm51bWJlclwiLCBkZXNjcmlwdGlvbjogXCJSZXF1aXJlZCBkdXJhdGlvbiBvZiB0aGUgZXZlbnQgaW4gbWludXRlcyAoZS5nLiwgMzAsIDYwKS5cIiB9LFxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGU6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIHN0YXJ0IGRhdGUvdGltZSB0byBzZWFyY2ggZnJvbSwgaW4gSVNPIDg2MDEgZm9ybWF0LiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCB0aW1lIGlmIG5vdCBwcm92aWRlZC5cIiB9LFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlOiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBlbmQgZGF0ZS90aW1lIHRvIHNlYXJjaCB1bnRpbCwgaW4gSVNPIDg2MDEgZm9ybWF0LiBEZWZhdWx0cyB0byA3IGRheXMgZnJvbSBzdGFydERhdGUgaWYgbm90IHByb3ZpZGVkLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVQcmVmZXJlbmNlOiB7IHR5cGU6IFwic3RyaW5nXCIsIGVudW06IFtcIm1vcm5pbmdcIiwgXCJhZnRlcm5vb25cIiwgXCJldmVuaW5nXCIsIFwiYW55XCJdLCBkZXNjcmlwdGlvbjogXCJPcHRpb25hbCBwcmVmZXJyZWQgdGltZSBvZiBkYXkgKGRlZmF1bHRzIHRvICdhbnknKS4gTW9ybmluZyAofjlhbS0xMnBtKSwgQWZ0ZXJub29uICh+MTJwbS01cG0pLCBFdmVuaW5nICh+NXBtLTlwbSkuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHk6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiT3B0aW9uYWw6IFRoZSB0eXBlIG9mIGFjdGl2aXR5IGJlaW5nIHNjaGVkdWxlZCAoZS5nLiwgJ21lZXRpbmcnLCAnd29ya291dCcsICdjYWxsJykgdG8gcG90ZW50aWFsbHkgaW5mbHVlbmNlIHN1Z2dlc3Rpb25zIG9yIGNoZWNrIGNvbnN0cmFpbnRzLlwiIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogW1wiZHVyYXRpb25cIl0sIC8vIE9ubHkgZHVyYXRpb24gaXMgc3RyaWN0bHkgcmVxdWlyZWQsIG90aGVycyBjYW4gaGF2ZSBkZWZhdWx0cy5cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IFwiZ2V0V2VhdGhlckZvcmVjYXN0XCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJHZXRzIHRoZSB3ZWF0aGVyIGZvcmVjYXN0IGZvciBhIHNwZWNpZmljIGxvY2F0aW9uIGFuZCBkYXRlLlwiLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgY2l0eSBhbmQgc3RhdGUsIG9yIHppcCBjb2RlIGZvciB0aGUgd2VhdGhlciBmb3JlY2FzdCAoZS5nLiwgJ1NhbiBGcmFuY2lzY28sIENBJywgJzk0MTA3JykuXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZXNjcmlwdGlvbjogXCJUaGUgZGF0ZSBmb3IgdGhlIGZvcmVjYXN0IGluIElTTyA4NjAxIGZvcm1hdCAoWVlZWS1NTS1ERCkuIERlZmF1bHRzIHRvIHRvZGF5IGlmIG5vdCBzcGVjaWZpZWQuXCIgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFtcImxvY2F0aW9uXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiBcImRlbGV0ZUNhbGVuZGFyRXZlbnRzQnlRdWVyeVwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiRGVsZXRlcyBtdWx0aXBsZSBjYWxlbmRhciBldmVudHMgd2l0aGluIGEgc3BlY2lmaWVkIGRhdGUgcmFuZ2UgdGhhdCBtYXRjaCBhIHNlYXJjaCBxdWVyeSBpbiB0aGVpciB0aXRsZS9zdW1tYXJ5LiBVc2Ugd2l0aCBjYXV0aW9uLlwiLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBzZWFyY2ggcXVlcnkgdG8gbWF0Y2ggYWdhaW5zdCBldmVudCBzdW1tYXJpZXMgKGUuZy4sICdneW0nLCAnbWVldGluZyB3aXRoIHByb2plY3QgWCcpLiBDYXNlLWluc2Vuc2l0aXZlLlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RhdGU6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiVGhlIHN0YXJ0IGRhdGUvdGltZSBmb3IgdGhlIHNlYXJjaCByYW5nZSBpbiBJU08gODYwMSBmb3JtYXQgKGUuZy4sICcyMDI1LTA0LTAxJykuIFJlcXVpcmVkLlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZF9kYXRlOiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBlbmQgZGF0ZS90aW1lIGZvciB0aGUgc2VhcmNoIHJhbmdlIGluIElTTyA4NjAxIGZvcm1hdCAoZS5nLiwgJzIwMjUtMDQtMzAnKS4gUmVxdWlyZWQuXCIgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJxdWVyeVwiLCBcInN0YXJ0X2RhdGVcIiwgXCJlbmRfZGF0ZVwiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbl07XG5cblxuLy8gLS0tIFRvb2wgRnVuY3Rpb24gSW1wbGVtZW50YXRpb25zIC0tLVxuLy8gTWFwcyB0b29sIG5hbWVzIChmcm9tIHNjaGVtYSkgdG8gdGhlIGFjdHVhbCBmdW5jdGlvbnMgdGhhdCBleGVjdXRlIHRoZW0uXG5jb25zdCB0b29sRnVuY3Rpb25zID0ge1xuICAgIHNhdmVVc2VyUHJlZmVyZW5jZTogYXN5bmMgKGFyZ3MsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsKSA9PiB7XG4gICAgICAgIGlmICghdXNlcklkIHx8IHVzZXJJZCA9PT0gJ2RlZmF1bHQnKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogXCJFcnJvcjogVXNlciBJRCBpcyBtaXNzaW5nLlwiIH07XG4gICAgICAgIGNvbnNvbGUubG9nKGBERUJVRzogc2F2ZVVzZXJQcmVmZXJlbmNlIGNhbGxlZCB3aXRoIHVzZXJJZD0ke3VzZXJJZH0sIGFyZ3M6YCwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBjYXRlZ29yeSwga2V5LCB2YWx1ZSwgY29udGV4dCB9ID0gYXJncztcbiAgICAgICAgLy8gQmFzaWMgdmFsaWRhdGlvblxuICAgICAgICBpZiAoIWNhdGVnb3J5IHx8ICFrZXkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IFwiRXJyb3I6IE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzIChjYXRlZ29yeSwga2V5LCB2YWx1ZSkgZm9yIHByZWZlcmVuY2UuXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBmaW5kIG9yIGNyZWF0ZSB0aGUgVXNlclByZWZlcmVuY2UgcmVjb3JkXG4gICAgICAgICAgICBjb25zdCBbdXNlclByZWYsIGNyZWF0ZWRdID0gYXdhaXQgVXNlclByZWZlcmVuY2UuZmluZE9yQ3JlYXRlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyB1c2VyX2lkOiB1c2VySWQgfSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0czogeyB1c2VyX2lkOiB1c2VySWQsIHByZWZlcmVuY2VzX2RhdGE6IHt9IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgREVCVUc6IFVzZXJQcmVmZXJlbmNlIHJlY29yZCAke2NyZWF0ZWQgPyAnY3JlYXRlZCcgOiAnZm91bmQnfSBmb3IgdXNlciAke3VzZXJJZH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHByZWZlcmVuY2VzIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcmVmcyA9IGNyZWF0ZWQgPyB7fSA6ICh1c2VyUHJlZi5wcmVmZXJlbmNlc19kYXRhIHx8IHt9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IEN1cnJlbnQgcHJlZmVyZW5jZXNfZGF0YTpcIiwgSlNPTi5zdHJpbmdpZnkoY3VycmVudFByZWZzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwcmVmZXJlbmNlcyBvYmplY3Qgd2l0aCB0aGUgdXBkYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcmVmcyA9IHsgLi4uY3VycmVudFByZWZzIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVuc3VyZSBjYXRlZ29yeSBleGlzdHNcbiAgICAgICAgICAgIGlmICghdXBkYXRlZFByZWZzW2NhdGVnb3J5XSkgdXBkYXRlZFByZWZzW2NhdGVnb3J5XSA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlXG4gICAgICAgICAgICB1cGRhdGVkUHJlZnNbY2F0ZWdvcnldW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSGFuZGxlIGNvbnRleHQgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0S2V5ID0gYCR7Y2F0ZWdvcnl9X2NvbnRleHRgO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlZFByZWZzW2NvbnRleHRLZXldKSB1cGRhdGVkUHJlZnNbY29udGV4dEtleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkUHJlZnNbY29udGV4dEtleV1ba2V5XSA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IFVwZGF0ZWQgcHJlZmVyZW5jZXNfZGF0YSB0byBiZSBzYXZlZDpcIiwgSlNPTi5zdHJpbmdpZnkodXBkYXRlZFByZWZzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVzZSBVUERBVEUgaW5zdGVhZCBvZiBzYXZlKCkgdG8gZW5zdXJlIHRoZSBKU09OQiBmaWVsZCBpcyBwcm9wZXJseSB1cGRhdGVkXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBrZXkgY2hhbmdlIHRvIGZpeCB0aGUgaXNzdWUgd2l0aCBTZXF1ZWxpemUgbm90IGRldGVjdGluZyBjaGFuZ2VzIHRvIEpTT05CIGZpZWxkc1xuICAgICAgICAgICAgY29uc3QgW3VwZGF0ZUNvdW50XSA9IGF3YWl0IFVzZXJQcmVmZXJlbmNlLnVwZGF0ZShcbiAgICAgICAgICAgICAgICB7IHByZWZlcmVuY2VzX2RhdGE6IHVwZGF0ZWRQcmVmcyB9LFxuICAgICAgICAgICAgICAgIHsgd2hlcmU6IHsgdXNlcl9pZDogdXNlcklkIH0gfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coYERFQlVHOiBVcGRhdGUgcmVzdWx0OiAke3VwZGF0ZUNvdW50fSByb3dzIGFmZmVjdGVkYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgdXBkYXRlIGJ5IGZldGNoaW5nIHRoZSByZWNvcmQgYWdhaW5cbiAgICAgICAgICAgIGNvbnN0IHZlcmlmeVByZWYgPSBhd2FpdCBVc2VyUHJlZmVyZW5jZS5maW5kT25lKHsgd2hlcmU6IHsgdXNlcl9pZDogdXNlcklkIH0gfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRFQlVHOiBWZXJpZmllZCBwcmVmZXJlbmNlc19kYXRhIGFmdGVyIHVwZGF0ZTpcIiwgXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmVyaWZ5UHJlZi5wcmVmZXJlbmNlc19kYXRhKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsIFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBQcmVmZXJlbmNlIHNhdmVkOiAke2NhdGVnb3J5fS4ke2tleX0gPSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50OiB1cGRhdGVDb3VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyBwcmVmZXJlbmNlIGZvciB1c2VyICR7dXNlcklkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogYEZhaWxlZCB0byBzYXZlIHByZWZlcmVuY2U6ICR7ZXJyb3IubWVzc2FnZX1gIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkQ2FsZW5kYXJFdmVudHM6IGFzeW5jIChhcmdzLCB1c2VySWQgPSAnZGVmYXVsdCcsIGFjY2Vzc1Rva2VuID0gbnVsbCkgPT4ge1xuICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuKSByZXR1cm4geyBlcnJvcjogXCJVc2VyIG5vdCBhdXRoZW50aWNhdGVkLlwiLCBzdWNjZXNzOiBmYWxzZSB9O1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfTtcbiAgICAgICAgY29uc3QgeyBldmVudHMgfSA9IGFyZ3M7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShldmVudHMpIHx8IGV2ZW50cy5sZW5ndGggPT09IDApIHJldHVybiB7IG1lc3NhZ2U6IFwiTm8gZXZlbnQgZGF0YSBwcm92aWRlZC5cIiwgc3VjY2VzczogZmFsc2UgfTtcblxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IGFmZmVjdGVkRGF0ZVJhbmdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnN1bW1hcnkgfHwgIWV2ZW50LnN0YXJ0IHx8ICFldmVudC5lbmQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyBzdW1tYXJ5OiBldmVudC5zdW1tYXJ5IHx8ICc/JywgZXJyb3I6IFwiTWlzc2luZyByZXF1aXJlZCBmaWVsZHMgKHN1bW1hcnksIHN0YXJ0LCBlbmQpLlwiLCBzdWNjZXNzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IHVzZXIgdGltZXpvbmVcbiAgICAgICAgICAgIGNvbnN0IHVzZXJUaW1lem9uZSA9IGdldFVzZXJUaW1lem9uZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc3RhcnQgYW5kIGVuZCB0aW1lcyB0byBVVEMgSVNPIHN0cmluZ3Mgd2l0aCBwcm9wZXIgdGltZXpvbmUgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFV0YyA9IGNvbnZlcnRUb1VUQ0lTT1N0cmluZyhldmVudC5zdGFydCwgdXNlclRpbWV6b25lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRVdGMgPSBjb252ZXJ0VG9VVENJU09TdHJpbmcoZXZlbnQuZW5kLCB1c2VyVGltZXpvbmUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghc3RhcnRVdGMgfHwgIWVuZFV0Yykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb252ZXJ0IHRpbWUgc3RyaW5ncyB0byBVVEMgSVNPIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXZlbnQgd2l0aCBwcm9wZXJseSBjb252ZXJ0ZWQgdGltZXNcbiAgICAgICAgICAgICAgICBldmVudC5zdGFydCA9IHN0YXJ0VXRjO1xuICAgICAgICAgICAgICAgIGV2ZW50LmVuZCA9IGVuZFV0YztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydER0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzdGFydFV0Yyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kRHQgPSBEYXRlVGltZS5mcm9tSVNPKGVuZFV0Yyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydER0LmlzVmFsaWQgfHwgIWVuZER0LmlzVmFsaWQpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRlIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydER0ID49IGVuZER0KSB0aHJvdyBuZXcgRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBiZWZvcmUgZW5kIHRpbWUnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyBzdW1tYXJ5OiBldmVudC5zdW1tYXJ5LCBlcnJvcjogYEludmFsaWQgZGF0ZSBmb3JtYXQgb3IgbG9naWM6ICR7ZS5tZXNzYWdlfS4gVXNlIElTTyA4NjAxIGZvcm1hdC5gLCBzdWNjZXNzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbmZsaWN0cyBiZWZvcmUgYXR0ZW1wdGluZyB0byBhZGRcbiAgICAgICAgICAgICAgICBjb25zdCBjb25mbGljdENoZWNrUmVzdWx0ID0gYXdhaXQgY2hlY2tGb3JDb25mbGljdHModG9rZW5zLCBldmVudC5zdGFydCwgZXZlbnQuZW5kLCBldmVudC5vdmVycmlkZUNvbmZsaWN0cyA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0Q2hlY2tSZXN1bHQuY29uZmxpY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ29uZmxpY3QgZGV0ZWN0ZWQgZm9yIGV2ZW50OiAke2V2ZW50LnN1bW1hcnl9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBldmVudC5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uczogY29uZmxpY3RDaGVja1Jlc3VsdC5zdWdnZXN0aW9ucyB8fCBbXSwgLy8gUGFzcyBzdWdnZXN0aW9ucyBiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY29uZmxpY3RDaGVja1Jlc3VsdC5lcnJvciB8fCBgRXZlbnQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcgc2NoZWR1bGUuYCwgLy8gSW5jbHVkZSBlcnJvciBpZiBhbnkgZnJvbSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb25mbGljdENoZWNrUmVzdWx0Lm92ZXJyaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENvbmZsaWN0IGRldGVjdGVkIGZvciBldmVudDogJHtldmVudC5zdW1tYXJ5fSBidXQgb3ZlcnJpZGUgZmxhZyBpcyBzZXQuIFByb2NlZWRpbmcgd2l0aCBldmVudCBjcmVhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgZGVzcGl0ZSBjb25mbGljdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRlZEV2ZW50ID0gYXdhaXQgYWRkR0NhbGVuZGFyRXZlbnRJbnRlcm5hbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5yZW1pbmRlcnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIG1ldGFkYXRhIGlmIHByaW9yaXR5IG9yIHRhZ3MgYXJlIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc01ldGFkYXRhID0gZXZlbnQucHJpb3JpdHkgIT09IHVuZGVmaW5lZCB8fCAoZXZlbnQudGFncyAmJiBldmVudC50YWdzLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY3JlYXRlT3JVcGRhdGVFdmVudE1ldGFkYXRhKHVzZXJJZCwgYWRkZWRFdmVudC5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogZXZlbnQucHJpb3JpdHksIC8vIFdpbGwgYmUgbnVsbCBpZiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogZXZlbnQudGFncyAvLyBXaWxsIGJlIG51bGwgaWYgdW5kZWZpbmVkIG9yIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1ldGFkYXRhIHNhdmVkIGZvciBldmVudCBcIiR7ZXZlbnQuc3VtbWFyeX1cIiAoSUQ6ICR7YWRkZWRFdmVudC5pZH0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChtZXRhZGF0YUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nIG1ldGFkYXRhIGZvciBldmVudCBcIiR7ZXZlbnQuc3VtbWFyeX1cIiAoSUQ6ICR7YWRkZWRFdmVudC5pZH0pOmAsIG1ldGFkYXRhRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgZmFpbCB0aGUgZW50aXJlIGV2ZW50IGFkZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRFdmVudC5tZXRhZGF0YUVycm9yID0gYEZhaWxlZCB0byBzYXZlIG1ldGFkYXRhOiAke21ldGFkYXRhRXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBub3RlIGFib3V0IHRoZSBjb25mbGljdCBiZWluZyBvdmVycmlkZGVuXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkRXZlbnQuY29uZmxpY3RPdmVycmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRFdmVudC5jb25mbGljdENvdW50ID0gY29uZmxpY3RDaGVja1Jlc3VsdC5jb25mbGljdENvdW50O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1pbmcgYWRkR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCByZXR1cm5zIHRoZSBjcmVhdGVkIGV2ZW50IG9iamVjdCBvbiBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IC4uLmFkZGVkRXZlbnQsIHN1Y2Nlc3M6IHRydWUgfSk7IC8vIEFkZCBzdWNjZXNzIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWREYXRlUmFuZ2VzLnB1c2goeyBzdGFydDogZXZlbnQuc3RhcnQsIGVuZDogZXZlbnQuZW5kIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXZlbnQgYWRkZWQgZGVzcGl0ZSBjb25mbGljdHM6ICR7ZXZlbnQuc3VtbWFyeX0gKElEOiAke2FkZGVkRXZlbnQuaWR9KWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkZWRFdmVudCA9IGF3YWl0IGFkZEdDYWxlbmRhckV2ZW50SW50ZXJuYWwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVtaW5kZXJzXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgbWV0YWRhdGEgaWYgcHJpb3JpdHkgb3IgdGFncyBhcmUgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTWV0YWRhdGEgPSBldmVudC5wcmlvcml0eSAhPT0gdW5kZWZpbmVkIHx8IChldmVudC50YWdzICYmIGV2ZW50LnRhZ3MubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjcmVhdGVPclVwZGF0ZUV2ZW50TWV0YWRhdGEodXNlcklkLCBhZGRlZEV2ZW50LmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBldmVudC5wcmlvcml0eSwgLy8gV2lsbCBiZSBudWxsIGlmIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBldmVudC50YWdzIC8vIFdpbGwgYmUgbnVsbCBpZiB1bmRlZmluZWQgb3IgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWV0YWRhdGEgc2F2ZWQgZm9yIGV2ZW50IFwiJHtldmVudC5zdW1tYXJ5fVwiIChJRDogJHthZGRlZEV2ZW50LmlkfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG1ldGFkYXRhRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgbWV0YWRhdGEgZm9yIGV2ZW50IFwiJHtldmVudC5zdW1tYXJ5fVwiIChJRDogJHthZGRlZEV2ZW50LmlkfSk6YCwgbWV0YWRhdGFFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBmYWlsIHRoZSBlbnRpcmUgZXZlbnQgYWRkaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZEV2ZW50Lm1ldGFkYXRhRXJyb3IgPSBgRmFpbGVkIHRvIHNhdmUgbWV0YWRhdGE6ICR7bWV0YWRhdGFFcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWluZyBhZGRHQ2FsZW5kYXJFdmVudEludGVybmFsIHJldHVybnMgdGhlIGNyZWF0ZWQgZXZlbnQgb2JqZWN0IG9uIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgLi4uYWRkZWRFdmVudCwgc3VjY2VzczogdHJ1ZSB9KTsgLy8gQWRkIHN1Y2Nlc3MgZmxhZ1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZERhdGVSYW5nZXMucHVzaCh7IHN0YXJ0OiBldmVudC5zdGFydCwgZW5kOiBldmVudC5lbmQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFdmVudCBhZGRlZDogJHtldmVudC5zdW1tYXJ5fSAoSUQ6ICR7YWRkZWRFdmVudC5pZH0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoYWRkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgZXZlbnQgXCIke2V2ZW50LnN1bW1hcnl9XCIgZHVyaW5nIGNvbmZsaWN0IGNoZWNrIG9yIEFQSSBjYWxsOmAsIGFkZEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyBzdW1tYXJ5OiBldmVudC5zdW1tYXJ5LCBlcnJvcjogYEZhaWxlZCB0byBwcm9jZXNzIGV2ZW50OiAke2FkZEVycm9yLm1lc3NhZ2V9YCwgc3VjY2VzczogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIGZvciBhbGwgcmFuZ2VzIHdoZXJlIGV2ZW50cyB3ZXJlIHN1Y2Nlc3NmdWxseSBhZGRlZFxuICAgICAgICAvLyBVc2UgaW52YWxpZGF0ZUNhY2hlIGZyb20gY2FjaGVTZXJ2aWNlXG4gICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgYWZmZWN0ZWREYXRlUmFuZ2VzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGludmFsaWRhdGVDYWNoZSh0b2tlbnMsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnZhbGlkYXRlZCBjYWNoZSBmb3IgcmFuZ2U6ICR7cmFuZ2Uuc3RhcnR9IC0gJHtyYW5nZS5lbmR9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChjYWNoZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGludmFsaWRhdGluZyBjYWNoZSBhZnRlciBhZGQ6XCIsIGNhY2hlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7IC8vIFJldHVybiBhcnJheSBvZiByZXN1bHQgb2JqZWN0cyAod2l0aCBzdWNjZXNzIGZsYWdzL2Vycm9ycylcbiAgICB9LFxuXG4gICAgZ2V0Q2FsZW5kYXJFdmVudHM6IGFzeW5jIChhcmdzLCB1c2VySWQgPSAnZGVmYXVsdCcsIGFjY2Vzc1Rva2VuID0gbnVsbCkgPT4ge1xuICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuKSByZXR1cm4geyBlcnJvcjogXCJVc2VyIG5vdCBhdXRoZW50aWNhdGVkLlwiLCBzdWNjZXNzOiBmYWxzZSwgZXZlbnRzOiBbXSB9OyAvLyBSZXR1cm4gc3RydWN0dXJlZCBlcnJvclxuICAgICAgICBjb25zdCB0b2tlbnMgPSB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfTtcbiAgICAgICAgY29uc3QgeyBzdGFydF9kYXRlLCBlbmRfZGF0ZSB9ID0gYXJncztcblxuICAgICAgICAvLyBWYWxpZGF0ZSBkYXRlc1xuICAgICAgICBpZiAoIXN0YXJ0X2RhdGUgfHwgIWVuZF9kYXRlKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiQm90aCBzdGFydF9kYXRlIGFuZCBlbmRfZGF0ZSBhcmUgcmVxdWlyZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBldmVudHM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnREdCA9IERhdGVUaW1lLmZyb21JU08oc3RhcnRfZGF0ZSk7XG4gICAgICAgIGNvbnN0IGVuZER0ID0gRGF0ZVRpbWUuZnJvbUlTTyhlbmRfZGF0ZSk7XG4gICAgICAgIGlmICghc3RhcnREdC5pc1ZhbGlkIHx8ICFlbmREdC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGBJbnZhbGlkIGRhdGUgZm9ybWF0LiBQbGVhc2UgdXNlIElTTyA4NjAxIChlLmcuLCBZWVlZLU1NLUREIG9yIFlZWVktTU0tRERUSEg6bW06c3NaKS4gUmVjZWl2ZWQ6IHN0YXJ0PSR7c3RhcnRfZGF0ZX0sIGVuZD0ke2VuZF9kYXRlfWAsIHN1Y2Nlc3M6IGZhbHNlLCBldmVudHM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RHQgPj0gZW5kRHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBcIlN0YXJ0IGRhdGUgbXVzdCBiZSBiZWZvcmUgZW5kIGRhdGUuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBldmVudHM6IFtdIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmluYWxFdmVudHMgPSBbXTsgLy8gSW5pdGlhbGl6ZSBldmVudHMgYXJyYXlcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRGVmaW5lIGNhY2hlIGtleXMgdXNpbmcgZGFpbHkgZ3JhbnVsYXJpdHkgZm9yIGJyb2FkZXIgY2FjaGUgaGl0c1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXlTdGFydCA9IHN0YXJ0RHQuc3RhcnRPZignZGF5JykudG9JU09EYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleUVuZCA9IGVuZER0LmVuZE9mKCdkYXknKS50b0lTT0RhdGUoKTsgLy8gSW5jbHVzaXZlIGVuZCBkYXkgZm9yIGtleVxuICAgICAgICAgICAgY29uc3QgdG9rZW5IYXNoID0gYWNjZXNzVG9rZW4uc3Vic3RyaW5nKGFjY2Vzc1Rva2VuLmxlbmd0aCAtIDEwKTsgLy8gU2ltcGxlIGhhc2hcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZENhY2hlUHJlZml4ID0gYHVzZXJfJHt0b2tlbkhhc2h9YDsgLy8gT3IgdXNlIGFjdHVhbCBzdGFibGUgdXNlcklkXG5cbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZmV0Y2ggZnJvbSBjYWNoZSBmaXJzdFxuICAgICAgICAgICAgbGV0IGNhY2hlZEV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWRDYWNoZVByZWZpeCwgY2FjaGVLZXlTdGFydCwgY2FjaGVLZXlFbmQpO1xuXG4gICAgICAgICAgICBpZiAoY2FjaGVkRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENhY2hlIEhJVCBmb3IgZXZlbnRzICR7Y2FjaGVLZXlTdGFydH0gdG8gJHtjYWNoZUtleUVuZH1gKTtcbiAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGNhY2hlZCBldmVudHMgYmFzZWQgb24gdGhlICpleGFjdCogc3RhcnQvZW5kIHRpbWUgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgIGZpbmFsRXZlbnRzID0gY2FjaGVkRXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudFN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5zdGFydD8uZGF0ZVRpbWUgfHwgZXZlbnQuc3RhcnQ/LmRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRFbmQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50LmVuZD8uZGF0ZVRpbWUgfHwgZXZlbnQuZW5kPy5kYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB2YWxpZCBkYXRlcyBiZWZvcmUgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudFN0YXJ0LmlzVmFsaWQgfHwgIWV2ZW50RW5kLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW50IG92ZXJsYXBzIHdpdGggdGhlIHJlcXVlc3RlZCByYW5nZSBbc3RhcnREdCwgZW5kRHQpXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTdGFydCA8IGVuZER0ICYmIGV2ZW50RW5kID4gc3RhcnREdDtcbiAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGaWx0ZXJlZCAke2NhY2hlZEV2ZW50cy5sZW5ndGh9IGNhY2hlZCBldmVudHMgZG93biB0byAke2ZpbmFsRXZlbnRzLmxlbmd0aH0gZm9yIGV4YWN0IHJhbmdlLmApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBNSVNTIGZvciBldmVudHMgJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIGZyb20gR29vZ2xlIENhbGVuZGFyIEFQSSBmb3IgdGhlICpleGFjdCogcmVxdWVzdGVkIHJhbmdlXG4gICAgICAgICAgICAgICAgY29uc3QgYXBpRXZlbnRzID0gYXdhaXQgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCh0b2tlbnMsIHN0YXJ0RHQudG9KU0RhdGUoKSwgZW5kRHQudG9KU0RhdGUoKSk7IC8vIEZldGNoIGV4YWN0IHJhbmdlXG5cbiAgICAgICAgICAgICAgICBpZiAoYXBpRXZlbnRzICYmIEFycmF5LmlzQXJyYXkoYXBpRXZlbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbEV2ZW50cyA9IGFwaUV2ZW50czsgLy8gVXNlIHRoZSBwcmVjaXNlbHkgZmV0Y2hlZCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoZWQgJHtmaW5hbEV2ZW50cy5sZW5ndGh9IGV2ZW50cyBmcm9tIEFQSSBmb3IgcmFuZ2UgJHtzdGFydER0LnRvSVNPKCl9IC0gJHtlbmREdC50b0lTTygpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdCB1c2luZyB0aGUgZGFpbHkgcmFuZ2Uga2V5IGZvciBwb3RlbnRpYWwgZnV0dXJlIGJyb2FkZXIgcXVlcmllc1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgZXZlbnRzIGZldGNoZWQgZm9yIHRoZSAqZXhhY3QqIHJhbmdlLCBidXQgdXNlIHRoZSAqZGFpbHkqIGtleVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHN1YnNlcXVlbnQgd2lkZXIgcXVlcmllcyBtaWdodCBoaXQgY2FjaGUsIGJ1dCBzcGVjaWZpYyBuYXJyb3cgcXVlcmllcyB3aXRoaW4gdGhlIGRheSB3aWxsIHN0aWxsIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZUV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWRDYWNoZVByZWZpeCwgY2FjaGVLZXlTdGFydCwgY2FjaGVLZXlFbmQsIGZpbmFsRXZlbnRzLCAzMDApOyAvLyA1IG1pbiBUVExcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN0b3JlZCAke2ZpbmFsRXZlbnRzLmxlbmd0aH0gZXZlbnRzIGluIFJlZGlzIGNhY2hlIHVuZGVyIGtleSByYW5nZSAke2NhY2hlS2V5U3RhcnR9IHRvICR7Y2FjaGVLZXlFbmR9YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBObyBldmVudHMgcmV0dXJuZWQgb3Igbm9uLWFycmF5IGZyb20gZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCBmb3IgJHtzdGFydER0LnRvSVNPKCl9LSR7ZW5kRHQudG9JU08oKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxFdmVudHMgPSBbXTsgLy8gRW5zdXJlIGl0J3MgYW4gZW1wdHkgYXJyYXkgb24gZmFpbHVyZSBvciBubyByZXN1bHRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbnJpY2ggZXZlbnRzIHdpdGggbWV0YWRhdGEgaWYgdGhlcmUgYXJlIGFueSBldmVudHNcbiAgICAgICAgICAgIGlmIChmaW5hbEV2ZW50cy5sZW5ndGggPiAwICYmIHVzZXJJZCAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBhbGwgR29vZ2xlIGV2ZW50IElEc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnb29nbGVFdmVudElkcyA9IGZpbmFsRXZlbnRzLm1hcChldmVudCA9PiBldmVudC5pZCkuZmlsdGVyKGlkID0+IGlkKTsgLy8gRmlsdGVyIG91dCBwb3RlbnRpYWwgbnVsbC91bmRlZmluZWQgSURzXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdvb2dsZUV2ZW50SWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIG1ldGFkYXRhIGZvciBhbGwgZXZlbnRzIGluIGEgc2luZ2xlIGJhdGNoIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVJlY29yZHMgPSBhd2FpdCBnZXRFdmVudE1ldGFkYXRhQmF0Y2godXNlcklkLCBnb29nbGVFdmVudElkcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGxvb2t1cCBtYXAgZm9yIGVmZmljaWVudCBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFSZWNvcmRzLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YU1hcC5zZXQocmVjb3JkLmdvb2dsZV9ldmVudF9pZCwgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnJpY2ggZXZlbnRzIHdpdGggbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsRXZlbnRzID0gZmluYWxFdmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhTWFwLmdldChldmVudC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBvbmx5IG5vbi1udWxsIG1ldGFkYXRhIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnJpY2htZW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5wcmlvcml0eSAhPT0gbnVsbCkgZW5yaWNobWVudC5wcmlvcml0eSA9IG1ldGFkYXRhLnByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEudGFncyAhPT0gbnVsbCAmJiBtZXRhZGF0YS50YWdzLmxlbmd0aCA+IDApIGVucmljaG1lbnQudGFncyA9IG1ldGFkYXRhLnRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmV2ZW50LCAuLi5lbnJpY2htZW50IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudDsgLy8gUmV0dXJuIG9yaWdpbmFsIGV2ZW50IGlmIG5vIG1ldGFkYXRhIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRW5yaWNoZWQgJHttZXRhZGF0YU1hcC5zaXplfSBldmVudHMgd2l0aCBtZXRhZGF0YS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG1ldGFkYXRhRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgb3IgbWVyZ2luZyBldmVudCBtZXRhZGF0YTpgLCBtZXRhZGF0YUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VlZCB3aXRob3V0IG1ldGFkYXRhLCBidXQgbG9nIHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJERUJVRzogdG9vbEZ1bmN0aW9ucy5nZXRDYWxlbmRhckV2ZW50cyBpcyByZXR1cm5pbmc6XCIsIEpTT04uc3RyaW5naWZ5KGZpbmFsRXZlbnRzLCBudWxsLCAyKSk7IC8vIEtlZXAgZGVidWcgbG9nXG4gICAgICAgICAgICByZXR1cm4gZmluYWxFdmVudHM7IC8vIFJldHVybiBqdXN0IHRoZSBldmVudHMgYXJyYXlcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gZ2V0Q2FsZW5kYXJFdmVudHMgdG9vbCAoJHtzdGFydF9kYXRlfSB0byAke2VuZF9kYXRlfSk6YCwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIHVzZXItZnJpZW5kbHkgc3RydWN0dXJlZCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjYWxlbmRhciBldmVudHM6ICR7ZXJyb3IubWVzc2FnZX0uIENoZWNrIGNvbm5lY3Rpb24gb3IgcGVybWlzc2lvbnMuYCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlQ2FsZW5kYXJFdmVudDogYXN5bmMgKGFyZ3MsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsKSA9PiB7XG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBldmVudElkOiBhcmdzLmV2ZW50SWQgfTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgICAgIGNvbnN0IHsgZXZlbnRJZCB9ID0gYXJncztcbiAgICAgICAgaWYgKCFldmVudElkKSByZXR1cm4geyBlcnJvcjogXCJFdmVudCBJRCBpcyByZXF1aXJlZC5cIiwgc3VjY2VzczogZmFsc2UgfTtcblxuICAgICAgICBsZXQgb3JpZ2luYWxTdGFydERhdGUsIG9yaWdpbmFsRW5kRGF0ZSwgZXZlbnRTdW1tYXJ5ID0gZXZlbnRJZDsgLy8gRGVmYXVsdCBzdW1tYXJ5IHRvIElEXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAxLiBHZXQgdGhlIGV2ZW50IGRldGFpbHMgZmlyc3QgZm9yIGNhY2hlIGludmFsaWRhdGlvbiBhbmQgdXNlciBmZWVkYmFja1xuICAgICAgICAgICAgY29uc3Qgb2F1dGgyQ2xpZW50ID0gY3JlYXRlT0F1dGgyQ2xpZW50KHRva2Vucyk7XG4gICAgICAgICAgICBjb25zdCBjYWxlbmRhciA9IGdvb2dsZS5jYWxlbmRhcih7IHZlcnNpb246ICd2MycsIGF1dGg6IG9hdXRoMkNsaWVudCB9KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZXZlbnQgZGV0YWlscyBmb3IgZGVsZXRpb246ICR7ZXZlbnRJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGF3YWl0IGNhbGVuZGFyLmV2ZW50cy5nZXQoeyBjYWxlbmRhcklkOiAncHJpbWFyeScsIGV2ZW50SWQ6IGV2ZW50SWQgfSk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydERhdGUgPSBldmVudC5kYXRhLnN0YXJ0Py5kYXRlVGltZSB8fCBldmVudC5kYXRhLnN0YXJ0Py5kYXRlO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kRGF0ZSA9IGV2ZW50LmRhdGEuZW5kPy5kYXRlVGltZSB8fCBldmVudC5kYXRhLmVuZD8uZGF0ZTtcbiAgICAgICAgICAgICAgICBldmVudFN1bW1hcnkgPSBldmVudC5kYXRhLnN1bW1hcnkgfHwgZXZlbnRJZDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgZXZlbnQgXCIke2V2ZW50U3VtbWFyeX1cIiBzdGFydGluZyAke29yaWdpbmFsU3RhcnREYXRlfSBmb3IgZGVsZXRpb24uYCk7XG4gICAgICAgICAgICB9IGNhdGNoIChnZXRFcnJvcikge1xuICAgICAgICAgICAgICAgICBpZiAoZ2V0RXJyb3IuY29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXZlbnQgJHtldmVudElkfSBub3QgZm91bmQgZm9yIGRlbGV0aW9uIChtYXkgYWxyZWFkeSBiZSBkZWxldGVkKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoaXMgYSBcInN1Y2Nlc3NcIiBpbiB0aGUgc2Vuc2UgdGhhdCB0aGUgZGVzaXJlZCBzdGF0ZSAoZXZlbnQgZ29uZSkgaXMgYWNoaWV2ZWQuXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBgRXZlbnQgJHtldmVudElkfSBub3QgZm91bmQgKGFscmVhZHkgZGVsZXRlZD8pLmAsIGV2ZW50SWQ6IGV2ZW50SWQsIHN1bW1hcnk6IGV2ZW50U3VtbWFyeSB9O1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgb3RoZXIgZXJyb3JzIGR1cmluZyBnZXRcbiAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmV0cmlldmUgZXZlbnQgZGV0YWlscyBiZWZvcmUgZGVsZXRlOiAke2dldEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDIuIERlbGV0ZSB0aGUgZXZlbnQgdmlhIGludGVybmFsIGZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byBkZWxldGUgZXZlbnQ6ICR7ZXZlbnRJZH1gKTtcbiAgICAgICAgICAgIGF3YWl0IGRlbGV0ZUdDYWxlbmRhckV2ZW50SW50ZXJuYWwodG9rZW5zLCBldmVudElkKTsgLy8gQXNzdW1lcyB0aGlzIHRocm93cyBvbiBBUEkgZXJyb3JcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZGVsZXRlZCBldmVudCBmcm9tIEdvb2dsZSBDYWxlbmRhcjogJHtldmVudElkfWApO1xuXG4gICAgICAgICAgICAvLyAzLiBEZWxldGUgYXNzb2NpYXRlZCBtZXRhZGF0YVxuICAgICAgICAgICAgaWYgKHVzZXJJZCAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsZXRlRXZlbnRNZXRhZGF0YSh1c2VySWQsIGV2ZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgbWV0YWRhdGEgZm9yIGV2ZW50OiAke2V2ZW50SWR9YCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobWV0YWRhdGFFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZWxldGluZyBtZXRhZGF0YSBmb3IgZXZlbnQgJHtldmVudElkfSAocHJvY2VlZGluZyBhbnl3YXkpOmAsIG1ldGFkYXRhRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGZhaWwgdGhlIG92ZXJhbGwgZGVsZXRpb24gaWYgY2FsZW5kYXIgZGVsZXRlIHN1Y2NlZWRlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gNC4gSW52YWxpZGF0ZSBjYWNoZSBmb3IgdGhlIGV2ZW50J3MgZGF0ZSByYW5nZVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnREYXRlICYmIG9yaWdpbmFsRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGludmFsaWRhdGVDYWNoZSh0b2tlbnMsIG9yaWdpbmFsU3RhcnREYXRlLCBvcmlnaW5hbEVuZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZGF0ZWQgY2FjaGUgZm9yIHJhbmdlOiAke29yaWdpbmFsU3RhcnREYXRlfSAtICR7b3JpZ2luYWxFbmREYXRlfWApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGNhY2hlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGludmFsaWRhdGluZyBjYWNoZSBhZnRlciBkZWxldGU6XCIsIGNhY2hlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZGV0ZXJtaW5lIGRhdGUgcmFuZ2UgZm9yIGV2ZW50ICR7ZXZlbnRJZH0sIGludmFsaWRhdGluZyB0b2tlbiBjYWNoZS5gKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpbnZhbGlkYXRlQ2FjaGUodG9rZW5zKTsgLy8gSW52YWxpZGF0ZSBicm9hZGVyIGNhY2hlIGFzc29jaWF0ZWQgd2l0aCB0b2tlblxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGNhY2hlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGludmFsaWRhdGluZyBjYWNoZSBhZnRlciBkZWxldGUgKGZhbGxiYWNrKTpcIiwgY2FjaGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBgU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgZXZlbnQ6IFwiJHtldmVudFN1bW1hcnl9XCJgLCBldmVudElkOiBldmVudElkLCBzdW1tYXJ5OiBldmVudFN1bW1hcnkgfTsgLy8gUmV0dXJuIHN1Y2Nlc3Mgb2JqZWN0XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGV2ZW50ICR7ZXZlbnRJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gRG9uJ3QgaW52YWxpZGF0ZSBjYWNoZSBvbiBlcnJvciBoZXJlLCBhcyB0aGUgc3RhdGUgaXMgdW5jZXJ0YWluXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIGRlbGV0ZSBldmVudCAke2V2ZW50SWR9ICgke2V2ZW50U3VtbWFyeX0pOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICBldmVudElkOiBldmVudElkLFxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IGV2ZW50U3VtbWFyeSAvLyBJbmNsdWRlIHN1bW1hcnkgaWYgcmV0cmlldmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUNhbGVuZGFyRXZlbnQ6IGFzeW5jIChhcmdzLCB1c2VySWQgPSAnZGVmYXVsdCcsIGFjY2Vzc1Rva2VuID0gbnVsbCkgPT4ge1xuICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBldmVudElkOiBhcmdzLmV2ZW50SWQgfTtcbiAgICAgICBjb25zdCB0b2tlbnMgPSB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfTtcbiAgICAgICBjb25zdCB7IGV2ZW50SWQsIHVwZGF0ZXMgfSA9IGFyZ3M7XG5cbiAgICAgICBpZiAoIWV2ZW50SWQgfHwgIXVwZGF0ZXMgfHwgdHlwZW9mIHVwZGF0ZXMgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICByZXR1cm4geyBlcnJvcjogXCJFdmVudCBJRCBhbmQgYSBub24tZW1wdHkgdXBkYXRlcyBvYmplY3QgYXJlIHJlcXVpcmVkLlwiLCBzdWNjZXNzOiBmYWxzZSwgZXZlbnRJZDogZXZlbnRJZCB9O1xuICAgICAgIH1cblxuICAgICAgIC8vIFZhbGlkYXRlIHVwZGF0ZSB2YWx1ZXMgKGJhc2ljIGNoZWNrIGZvciBJU08gZGF0ZXMgaWYgcHJvdmlkZWQpXG4gICAgICAgbGV0IHVwZGF0ZVN0YXJ0RHQsIHVwZGF0ZUVuZER0O1xuICAgICAgIHRyeSB7XG4gICAgICAgICAgIGlmICh1cGRhdGVzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICB1cGRhdGVTdGFydER0ID0gRGF0ZVRpbWUuZnJvbUlTTyh1cGRhdGVzLnN0YXJ0KTtcbiAgICAgICAgICAgICAgIGlmICghdXBkYXRlU3RhcnREdC5pc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXJ0IGRhdGUgZm9ybWF0XCIpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmICh1cGRhdGVzLmVuZCkge1xuICAgICAgICAgICAgICAgdXBkYXRlRW5kRHQgPSBEYXRlVGltZS5mcm9tSVNPKHVwZGF0ZXMuZW5kKTtcbiAgICAgICAgICAgICAgIGlmICghdXBkYXRlRW5kRHQuaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbmQgZGF0ZSBmb3JtYXRcIik7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gVXNlIHJldHJpZXZlZCBvcmlnaW5hbCB0aW1lcyBpZiBvbmx5IG9uZSBlbmQgb2YgdGhlIGRhdGUgaXMgcHJvdmlkZWQgaW4gdXBkYXRlc1xuICAgICAgICAgICAvLyAoVGhpcyByZXF1aXJlcyBnZXR0aW5nIHRoZSBvcmlnaW5hbCBldmVudCAqZmlyc3QqKVxuICAgICAgICAgICAvLyBXZSB3aWxsIHBlcmZvcm0gdGhpcyBjaGVjayBhZnRlciBmZXRjaGluZyB0aGUgb3JpZ2luYWwgZXZlbnQuXG5cbiAgICAgICB9IGNhdGNoICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBgSW52YWxpZCB1cGRhdGUgZGF0YTogJHt2YWxpZGF0aW9uRXJyb3IubWVzc2FnZX0uIFVzZSBJU08gODYwMSBmb3JtYXQuYCwgc3VjY2VzczogZmFsc2UsIGV2ZW50SWQ6IGV2ZW50SWQgfTtcbiAgICAgICB9XG5cblxuICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0RGF0ZSwgb3JpZ2luYWxFbmREYXRlLCBvcmlnaW5hbFN1bW1hcnkgPSBldmVudElkO1xuICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAxLiBHZXQgb3JpZ2luYWwgZXZlbnQgdGltZXMgZm9yIGNhY2hlIGludmFsaWRhdGlvbiBhbmQgcG90ZW50aWFsIGRhdGUgbG9naWNcbiAgICAgICAgICAgIGNvbnN0IG9hdXRoMkNsaWVudCA9IGNyZWF0ZU9BdXRoMkNsaWVudCh0b2tlbnMpO1xuICAgICAgICAgICAgY29uc3QgY2FsZW5kYXIgPSBnb29nbGUuY2FsZW5kYXIoeyB2ZXJzaW9uOiAndjMnLCBhdXRoOiBvYXV0aDJDbGllbnQgfSk7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxFdmVudERhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBldmVudCBkZXRhaWxzIGZvciB1cGRhdGU6ICR7ZXZlbnRJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudFJlc3BvbnNlID0gYXdhaXQgY2FsZW5kYXIuZXZlbnRzLmdldCh7IGNhbGVuZGFySWQ6ICdwcmltYXJ5JywgZXZlbnRJZDogZXZlbnRJZCB9KTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50RGF0YSA9IGV2ZW50UmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0RGF0ZSA9IG9yaWdpbmFsRXZlbnREYXRhLnN0YXJ0Py5kYXRlVGltZSB8fCBvcmlnaW5hbEV2ZW50RGF0YS5zdGFydD8uZGF0ZTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZERhdGUgPSBvcmlnaW5hbEV2ZW50RGF0YS5lbmQ/LmRhdGVUaW1lIHx8IG9yaWdpbmFsRXZlbnREYXRhLmVuZD8uZGF0ZTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN1bW1hcnkgPSBvcmlnaW5hbEV2ZW50RGF0YS5zdW1tYXJ5IHx8IGV2ZW50SWQ7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGV2ZW50IFwiJHtvcmlnaW5hbFN1bW1hcnl9XCIgc3RhcnRpbmcgJHtvcmlnaW5hbFN0YXJ0RGF0ZX0gZm9yIHVwZGF0ZS5gKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGdldEVycm9yKSB7XG4gICAgICAgICAgICAgICBpZiAoZ2V0RXJyb3IuY29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYEV2ZW50ICR7ZXZlbnRJZH0gbm90IGZvdW5kIGZvciB1cGRhdGUuYCwgZXZlbnRJZDogZXZlbnRJZCB9O1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmV0cmlldmUgZXZlbnQgZGV0YWlscyBiZWZvcmUgdXBkYXRlOiAke2dldEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlZmluZWQgRGF0ZSBWYWxpZGF0aW9uOiBDaGVjayBzdGFydCA8IGVuZCB1c2luZyBvcmlnaW5hbCBkYXRlcyBpZiBuZWVkZWRcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsU3RhcnQgPSB1cGRhdGVzLnN0YXJ0ID8gdXBkYXRlU3RhcnREdCA6IERhdGVUaW1lLmZyb21JU08ob3JpZ2luYWxTdGFydERhdGUpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxFbmQgPSB1cGRhdGVzLmVuZCA/IHVwZGF0ZUVuZER0IDogRGF0ZVRpbWUuZnJvbUlTTyhvcmlnaW5hbEVuZERhdGUpO1xuXG4gICAgICAgICAgICBpZiAoZmluYWxTdGFydC5pc1ZhbGlkICYmIGZpbmFsRW5kLmlzVmFsaWQgJiYgZmluYWxTdGFydCA+PSBmaW5hbEVuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJ0IHRpbWUgbXVzdCBiZSBiZWZvcmUgZW5kIHRpbWUgYWZ0ZXIgdXBkYXRlcyBhcmUgYXBwbGllZC5cIik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gMi4gVXBkYXRlIHRoZSBldmVudCB2aWEgaW50ZXJuYWwgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHVwZGF0ZSBldmVudDogJHtldmVudElkfSB3aXRoIHVwZGF0ZXM6YCwgdXBkYXRlcyk7XG4gICAgICAgICAgICAvLyBQYXNzIG9ubHkgdGhlIGZpZWxkcyBwcmVzZW50IGluIHRoZSAndXBkYXRlcycgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0geyAuLi51cGRhdGVzIH07IC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEV2ZW50ID0gYXdhaXQgdXBkYXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCh0b2tlbnMsIGV2ZW50SWQsIHVwZGF0ZVBheWxvYWQpOyAvLyBBc3N1bWUgdGhyb3dzIG9uIEFQSSBlcnJvclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSB1cGRhdGVkIGV2ZW50IGluIEdvb2dsZSBDYWxlbmRhcjogJHtldmVudElkfWApO1xuXG5cbiAgICAgICAgICAgIC8vIDMuIFVwZGF0ZSBtZXRhZGF0YSBpZiBwcmlvcml0eSBvciB0YWdzIGFyZSBwcm92aWRlZCBpbiB0aGUgdXBkYXRlc1xuICAgICAgICAgICAgY29uc3QgaGFzTWV0YWRhdGFVcGRhdGUgPSB1cGRhdGVzLnByaW9yaXR5ICE9PSB1bmRlZmluZWQgfHwgdXBkYXRlcy50YWdzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaGFzTWV0YWRhdGFVcGRhdGUgJiYgdXNlcklkICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHVwZGF0ZSB0aGUgZmllbGRzIHByb3ZpZGVkIGluIHRoZSAndXBkYXRlcycgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVPclVwZGF0ZUV2ZW50TWV0YWRhdGEgaGFuZGxlcyBtZXJnaW5nL292ZXJ3cml0aW5nIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY3JlYXRlT3JVcGRhdGVFdmVudE1ldGFkYXRhKHVzZXJJZCwgZXZlbnRJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHVwZGF0ZXMucHJpb3JpdHksIC8vIFdpbGwgYmUgbnVsbCBpZiB1bmRlZmluZWQsIGhhbmRsZWQgYnkgREIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHVwZGF0ZXMudGFncyAvLyBXaWxsIGJlIG51bGwgaWYgdW5kZWZpbmVkLCBoYW5kbGVkIGJ5IERCIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWV0YWRhdGEgdXBkYXRlZCBmb3IgZXZlbnQgJHtldmVudElkfS5gKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChtZXRhZGF0YUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIG1ldGFkYXRhIGZvciBldmVudCAke2V2ZW50SWR9IChwcm9jZWVkaW5nIGFueXdheSk6YCwgbWV0YWRhdGFFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCBtZXRhZGF0YSBlcnJvciBpbmZvIHRvIHRoZSByZXN1bHQsIGJ1dCBkb24ndCBmYWlsIHRoZSB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEV2ZW50Lm1ldGFkYXRhRXJyb3IgPSBgRmFpbGVkIHRvIHVwZGF0ZSBtZXRhZGF0YTogJHttZXRhZGF0YUVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDQuIEludmFsaWRhdGUgY2FjaGUgZm9yIGJvdGggb3JpZ2luYWwgYW5kIG5ldyByYW5nZXNcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlc1RvSW52YWxpZGF0ZSA9IFtdO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnREYXRlICYmIG9yaWdpbmFsRW5kRGF0ZSkgcmFuZ2VzVG9JbnZhbGlkYXRlLnB1c2goe3N0YXJ0OiBvcmlnaW5hbFN0YXJ0RGF0ZSwgZW5kOiBvcmlnaW5hbEVuZERhdGV9KTtcbiAgICAgICAgICAgIC8vIFVzZSB1cGRhdGVkIGV2ZW50IGRhdGEgZm9yIHRoZSBuZXcgcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0RGF0ZSA9IHVwZGF0ZWRFdmVudC5zdGFydD8uZGF0ZVRpbWUgfHwgdXBkYXRlZEV2ZW50LnN0YXJ0Py5kYXRlO1xuICAgICAgICAgICAgY29uc3QgbmV3RW5kRGF0ZSA9IHVwZGF0ZWRFdmVudC5lbmQ/LmRhdGVUaW1lIHx8IHVwZGF0ZWRFdmVudC5lbmQ/LmRhdGU7XG4gICAgICAgICAgICBpZiAobmV3U3RhcnREYXRlICYmIG5ld0VuZERhdGUpIHJhbmdlc1RvSW52YWxpZGF0ZS5wdXNoKHtzdGFydDogbmV3U3RhcnREYXRlLCBlbmQ6IG5ld0VuZERhdGV9KTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlc1RvSW52YWxpZGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgIC8vIERlZHVwbGljYXRlIHJhbmdlcyBiZWZvcmUgaW52YWxpZGF0aW5nXG4gICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVJhbmdlcyA9IFsuLi5uZXcgU2V0KHJhbmdlc1RvSW52YWxpZGF0ZS5tYXAociA9PiBgJHtyLnN0YXJ0fXwke3IuZW5kfWApKV0ubWFwKHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcy5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbnZhbGlkYXRpbmcgY2FjaGUgcmFuZ2VzOlwiLCB1bmlxdWVSYW5nZXMpO1xuICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHVuaXF1ZVJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaW52YWxpZGF0ZUNhY2hlKHRva2VucywgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZGF0ZWQgY2FjaGUgZm9yIHJhbmdlOiAke3JhbmdlLnN0YXJ0fSAtICR7cmFuZ2UuZW5kfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChjYWNoZUVycm9yKSB7IGNvbnNvbGUuZXJyb3IoYEVycm9yIGludmFsaWRhdGluZyBjYWNoZSByYW5nZSAke3JhbmdlLnN0YXJ0fS0ke3JhbmdlLmVuZH06YCwgY2FjaGVFcnJvcik7IH1cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGRldGVybWluZSBkYXRlIHJhbmdlKHMpIGZvciBldmVudCAke2V2ZW50SWR9IHVwZGF0ZSwgaW52YWxpZGF0aW5nIHRva2VuIGNhY2hlLmApO1xuICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaW52YWxpZGF0ZUNhY2hlKHRva2Vucyk7IC8vIEZhbGxiYWNrIGludmFsaWRhdGVcbiAgICAgICAgICAgICAgICAgfSBjYXRjaCAoY2FjaGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGludmFsaWRhdGluZyBjYWNoZSBhZnRlciB1cGRhdGUgKGZhbGxiYWNrKTpcIiwgY2FjaGVFcnJvcik7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8gUmV0dXJuIHRoZSB1cGRhdGVkIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBBUEksIGFkZGluZyBhIHN1Y2Nlc3MgZmxhZ1xuICAgICAgICAgICByZXR1cm4geyAuLi51cGRhdGVkRXZlbnQsIHN1Y2Nlc3M6IHRydWUgfTtcblxuICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGV2ZW50ICR7ZXZlbnRJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHVwZGF0ZSBldmVudCAke2V2ZW50SWR9ICgke29yaWdpbmFsU3VtbWFyeSB8fCBldmVudElkfSk6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIGV2ZW50SWQ6IGV2ZW50SWQsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogb3JpZ2luYWxTdW1tYXJ5IC8vIEluY2x1ZGUgb3JpZ2luYWwgc3VtbWFyeSBpZiByZXRyaWV2ZWRcbiAgICAgICAgICAgfTtcbiAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRBdmFpbGFibGVTbG90czogYXN5bmMgKGFyZ3MsIHVzZXJJZCA9ICdkZWZhdWx0JywgYWNjZXNzVG9rZW4gPSBudWxsKSA9PiB7XG4gICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHJldHVybiB7IGVycm9yOiBcIlVzZXIgbm90IGF1dGhlbnRpY2F0ZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBzbG90czogW10gfTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0geyBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuIH07XG4gICAgICAgIGNvbnN0IHsgZHVyYXRpb24sIHN0YXJ0RGF0ZTogcmVxU3RhcnREYXRlLCBlbmREYXRlOiByZXFFbmREYXRlLCB0aW1lUHJlZmVyZW5jZSA9ICdhbnknLCBhY3Rpdml0eSA9ICdldmVudCcgfSA9IGFyZ3M7XG5cbiAgICAgICAgaWYgKCFkdXJhdGlvbiB8fCB0eXBlb2YgZHVyYXRpb24gIT09ICdudW1iZXInIHx8IGR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBcIlZhbGlkIGR1cmF0aW9uIChpbiBtaW51dGVzKSBpcyByZXF1aXJlZC5cIiwgc3VjY2VzczogZmFsc2UsIHNsb3RzOiBbXSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIHNlYXJjaCByYW5nZSB3aXRoIGRlZmF1bHRzXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGVUaW1lLm5vdygpO1xuICAgICAgICBjb25zdCBzdGFydERhdGUgPSByZXFTdGFydERhdGUgPyBEYXRlVGltZS5mcm9tSVNPKHJlcVN0YXJ0RGF0ZSkgOiBub3c7XG4gICAgICAgIC8vIERlZmF1bHQgZW5kIGRhdGUgaXMgNyBkYXlzIGZyb20gdGhlIHJlc29sdmVkIHN0YXJ0IGRhdGVcbiAgICAgICAgY29uc3QgZW5kRGF0ZSA9IHJlcUVuZERhdGUgPyBEYXRlVGltZS5mcm9tSVNPKHJlcUVuZERhdGUpIDogc3RhcnREYXRlLnBsdXMoeyBkYXlzOiA3IH0pO1xuXG4gICAgICAgIGlmICghc3RhcnREYXRlLmlzVmFsaWQgfHwgIWVuZERhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBgSW52YWxpZCBkYXRlIGZvcm1hdC4gVXNlIElTTyA4NjAxLiBSZWNlaXZlZCBzdGFydD0ke3JlcVN0YXJ0RGF0ZX0sIGVuZD0ke3JlcUVuZERhdGV9YCwgc3VjY2VzczogZmFsc2UsIHNsb3RzOiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydERhdGUgPj0gZW5kRGF0ZSkge1xuICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBcIlN0YXJ0IGRhdGUgbXVzdCBiZSBiZWZvcmUgZW5kIGRhdGUuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBzbG90czogW10gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmZXRjaGVkRXZlbnRzID0gW107IC8vIEluaXRpYWxpemUgZXZlbnRzIGFycmF5XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZldGNoIGV2ZW50cyBmb3IgdGhlICplbnRpcmUqIHBvdGVudGlhbCBzZWFyY2ggcmFuZ2UgZmlyc3QgKGNhY2hlLWF3YXJlKVxuICAgICAgICAgICAgLy8gVXNlIGRhaWx5IGdyYW51bGFyaXR5IGZvciBjYWNoZSBrZXlzXG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleVN0YXJ0ID0gc3RhcnREYXRlLnN0YXJ0T2YoJ2RheScpLnRvSVNPRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXlFbmQgPSBlbmREYXRlLmVuZE9mKCdkYXknKS50b0lTT0RhdGUoKTsgLy8gSW5jbHVzaXZlIGVuZCBkYXkgZm9yIGtleVxuICAgICAgICAgICAgY29uc3QgdG9rZW5IYXNoID0gYWNjZXNzVG9rZW4uc3Vic3RyaW5nKGFjY2Vzc1Rva2VuLmxlbmd0aCAtIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZENhY2hlUHJlZml4ID0gYHVzZXJfJHt0b2tlbkhhc2h9YDtcblxuICAgICAgICAgICAgbGV0IGNhY2hlZEV2ZW50cyA9IGF3YWl0IGdldENhY2hlZEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWRDYWNoZVByZWZpeCwgY2FjaGVLZXlTdGFydCwgY2FjaGVLZXlFbmQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FjaGUgSElUIGZvciBzbG90IHNlYXJjaCBldmVudHMgJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgICAgICBmZXRjaGVkRXZlbnRzID0gY2FjaGVkRXZlbnRzOyAvLyBVc2UgY2FjaGVkIGV2ZW50cyAod2lsbCBiZSBmaWx0ZXJlZCBsYXRlcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBNSVNTIGZvciBzbG90IHNlYXJjaCBldmVudHMgJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgICAgICAvLyBGZXRjaCBldmVudHMgY292ZXJpbmcgdGhlICpicm9hZGVzdCogcG9zc2libGUgcmFuZ2UgKHN0YXJ0IG9mIHN0YXJ0IGRheSB0byBlbmQgb2YgZW5kIGRheSkgZm9yIGNhY2hpbmdcbiAgICAgICAgICAgICAgICAgY29uc3QgYXBpRXZlbnRzID0gYXdhaXQgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCh0b2tlbnMsIHN0YXJ0RGF0ZS5zdGFydE9mKCdkYXknKS50b0pTRGF0ZSgpLCBlbmREYXRlLmVuZE9mKCdkYXknKS50b0pTRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgaWYgKGFwaUV2ZW50cyAmJiBBcnJheS5pc0FycmF5KGFwaUV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlZEV2ZW50cyA9IGFwaUV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UodXNlcklkQ2FjaGVQcmVmaXgsIGNhY2hlS2V5U3RhcnQsIGNhY2hlS2V5RW5kLCBmZXRjaGVkRXZlbnRzLCAzMDApOyAvLyBDYWNoZSB0aGUgYnJvYWQgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoZWQgYW5kIGNhY2hlZCAke2ZldGNoZWRFdmVudHMubGVuZ3RofSBldmVudHMgZm9yIHNsb3Qgc2VhcmNoLmApO1xuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGVkRXZlbnRzID0gW107IC8vIEFzc3VtZSBubyBldmVudHMgaWYgZmV0Y2ggZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBObyBldmVudHMgcmV0dXJuZWQgb3IgZmV0Y2ggZmFpbGVkIGZvciBzbG90IHNlYXJjaCByYW5nZS5gKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGZldGNoZWQgZXZlbnRzIChmcm9tIGNhY2hlIG9yIEFQSSkgdG8gdGhlIHByZWNpc2UgcmVxdWVzdGVkIHRpbWUgd2luZG93ICpiZWZvcmUqIGZpbmRpbmcgc2xvdHNcbiAgICAgICAgICAgICBjb25zdCByZWxldmFudEV2ZW50cyA9IGZldGNoZWRFdmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRTdGFydCA9IERhdGVUaW1lLmZyb21JU08oZXZlbnQuc3RhcnQ/LmRhdGVUaW1lIHx8IGV2ZW50LnN0YXJ0Py5kYXRlKTtcbiAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRFbmQgPSBEYXRlVGltZS5mcm9tSVNPKGV2ZW50LmVuZD8uZGF0ZVRpbWUgfHwgZXZlbnQuZW5kPy5kYXRlKTtcbiAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgb3ZlcmxhcCB3aXRoIHRoZSAqcHJlY2lzZSogdXNlci1yZXF1ZXN0ZWQgcmFuZ2UgW3N0YXJ0RGF0ZSwgZW5kRGF0ZSlcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RhcnQuaXNWYWxpZCAmJiBldmVudEVuZC5pc1ZhbGlkICYmIGV2ZW50U3RhcnQgPCBlbmREYXRlICYmIGV2ZW50RW5kID4gc3RhcnREYXRlO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGaWx0ZXJlZCAke2ZldGNoZWRFdmVudHMubGVuZ3RofSBldmVudHMgZG93biB0byAke3JlbGV2YW50RXZlbnRzLmxlbmd0aH0gcmVsZXZhbnQgZm9yIHRoZSBwcmVjaXNlIHNsb3Qgc2VhcmNoIHdpbmRvdy5gKTtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBpbXBvcnRlZCB1dGlsaXR5IGZ1bmN0aW9uIChyZW5hbWVkIHRvIGF2b2lkIGNvbmZsaWN0KVxuICAgICAgICAgICAgY29uc3Qgc2xvdHNSZXN1bHQgPSBhd2FpdCBmaW5kQXZhaWxhYmxlU2xvdHNVdGlsKFxuICAgICAgICAgICAgICAgIHJlbGV2YW50RXZlbnRzLCAvLyBQYXNzIHByZWNpc2VseSBmaWx0ZXJlZCBldmVudHNcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBzdGFydERhdGUudG9JU08oKSwgLy8gUGFzcyBwcmVjaXNlIElTTyBzdHJpbmdzIHRvIHV0aWxcbiAgICAgICAgICAgICAgICBlbmREYXRlLnRvSVNPKCksXG4gICAgICAgICAgICAgICAgdGltZVByZWZlcmVuY2UsIC8vIFBhc3MgcHJlZmVyZW5jZSBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGFjdGl2aXR5IC8vIFBhc3MgYWN0aXZpdHkgZGlyZWN0bHlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGZpbmRBdmFpbGFibGVTbG90c1V0aWwgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSB7IHNsb3RzOiBbLi4uXSB9IG9yIHsgZXJyb3I6IC4uLiwgc2xvdHM6IFtdIH1cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IGRpcmVjdGx5LCBhZGRpbmcgYSBzdWNjZXNzIGZsYWcgYmFzZWQgb24gd2hldGhlciBhbiBlcnJvciBvY2N1cnJlZCB3aXRoaW4gdGhlIHV0aWxcbiAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzbG90cyBhcnJheSBkaXJlY3RseVxuICAgICAgICAgICBpZiAoc2xvdHNSZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzbG90c1Jlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2xvdHNSZXN1bHQuc2xvdHMgfHwgW107XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGZpbmRBdmFpbGFibGVTbG90cyB0b29sICgke2R1cmF0aW9ufW1pbiwgJHtzdGFydERhdGUudG9JU08oKX0gdG8gJHtlbmREYXRlLnRvSVNPKCl9KTpgLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdHJ1Y3R1cmVkIGVycm9yIG9iamVjdFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhdmFpbGFibGUgc2xvdHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRXZWF0aGVyRm9yZWNhc3Q6IGFzeW5jIChhcmdzLCB1c2VySWQgPSAnZGVmYXVsdCcsIGFjY2Vzc1Rva2VuID0gbnVsbCkgPT4ge1xuICAgICAgICAvLyBQbGFjZWhvbGRlciAtIHJlcXVpcmVzIGFjdHVhbCB3ZWF0aGVyIEFQSSBpbnRlZ3JhdGlvblxuICAgICAgICBjb25zdCB7IGxvY2F0aW9uLCBkYXRlOiBkYXRlU3RyaW5nIH0gPSBhcmdzO1xuICAgICAgICBpZiAoIWxvY2F0aW9uKSByZXR1cm4geyBlcnJvcjogXCJMb2NhdGlvbiBpcyByZXF1aXJlZCBmb3Igd2VhdGhlciBmb3JlY2FzdC5cIiwgc3VjY2VzczogZmFsc2UgfTtcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIHRvZGF5IGlmIGRhdGUgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gICAgICAgIGxldCBmb3JlY2FzdERhdGUgPSBkYXRlU3RyaW5nID8gRGF0ZVRpbWUuZnJvbUlTTyhkYXRlU3RyaW5nKSA6IERhdGVUaW1lLm5vdygpO1xuICAgICAgICBpZiAoIWZvcmVjYXN0RGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgZGF0ZSBwcm92aWRlZCBmb3Igd2VhdGhlciBmb3JlY2FzdDogJHtkYXRlU3RyaW5nfS4gRGVmYXVsdGluZyB0byB0b2RheS5gKTtcbiAgICAgICAgICAgIGZvcmVjYXN0RGF0ZSA9IERhdGVUaW1lLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBmb3JlY2FzdERhdGUudG9JU09EYXRlKCk7IC8vIFlZWVktTU0tRERcblxuICAgICAgICBjb25zb2xlLmxvZyhgUGxhY2Vob2xkZXI6IEZldGNoaW5nIHdlYXRoZXIgZm9yICR7bG9jYXRpb259IG9uICR7Zm9ybWF0dGVkRGF0ZX1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIC0tLSBSZXBsYWNlIHdpdGggYWN0dWFsIHdlYXRoZXIgQVBJIGNhbGwgLS0tXG4gICAgICAgICAgICAvLyBFeGFtcGxlOiBjb25zdCB3ZWF0aGVyRGF0YSA9IGF3YWl0IGdldFdlYXRoZXJEYXRhKGxvY2F0aW9uLCBmb3JtYXR0ZWREYXRlKTtcbiAgICAgICAgICAgIC8vIHJldHVybiB7IC4uLndlYXRoZXJEYXRhLCBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgICAvLyAtLS0gUGxhY2Vob2xkZXIgcmVzcG9uc2UgLS0tXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCAvLyBJbmRpY2F0ZSBkYXRhIGlzIG5vdCBhY3R1YWwgLyBBUEkgbm90IGltcGxlbWVudGVkXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGRhdGU6IGZvcm1hdHRlZERhdGUsXG4gICAgICAgICAgICAgICAgZm9yZWNhc3Q6IGBXZWF0aGVyIGRhdGEgZm9yICR7bG9jYXRpb259IG9uICR7Zm9ybWF0dGVkRGF0ZX0gaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlIChmZWF0dXJlIG5vdCBpbXBsZW1lbnRlZCkuYCwgLy8gUGxhY2Vob2xkZXIgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGVycm9yOiBcIldlYXRoZXIgQVBJIGludGVncmF0aW9uIGlzIHBlbmRpbmcuXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB3ZWF0aGVyIGZvciAke2xvY2F0aW9ufSwgJHtmb3JtYXR0ZWREYXRlfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgZGF0ZTogZm9ybWF0dGVkRGF0ZSxcbiAgICAgICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gZ2V0IHdlYXRoZXIgZm9yZWNhc3Q6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlQ2FsZW5kYXJFdmVudHNCeVF1ZXJ5OiBhc3luYyAoYXJncywgdXNlcklkID0gJ2RlZmF1bHQnLCBhY2Nlc3NUb2tlbiA9IG51bGwpID0+IHtcbiAgICAgICAgaWYgKCFhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiVXNlciBub3QgYXV0aGVudGljYXRlZC5cIiwgc3VjY2VzczogZmFsc2UsIGRlbGV0ZWRDb3VudDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHsgYWNjZXNzX3Rva2VuOiBhY2Nlc3NUb2tlbiB9O1xuICAgICAgICBjb25zdCB7IHF1ZXJ5LCBzdGFydF9kYXRlLCBlbmRfZGF0ZSB9ID0gYXJncztcblxuICAgICAgICBpZiAoIXF1ZXJ5IHx8ICFzdGFydF9kYXRlIHx8ICFlbmRfZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IFwiUXVlcnksIHN0YXJ0IGRhdGUsIGFuZCBlbmQgZGF0ZSBhcmUgcmVxdWlyZWQuXCIsIHN1Y2Nlc3M6IGZhbHNlLCBkZWxldGVkQ291bnQ6IDAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0RHQgPSBEYXRlVGltZS5mcm9tSVNPKHN0YXJ0X2RhdGUpO1xuICAgICAgICBjb25zdCBlbmREdCA9IERhdGVUaW1lLmZyb21JU08oZW5kX2RhdGUpO1xuICAgICAgICAgaWYgKCFzdGFydER0LmlzVmFsaWQgfHwgIWVuZER0LmlzVmFsaWQpIHtcbiAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogYEludmFsaWQgZGF0ZSBmb3JtYXQuIFVzZSBJU08gODYwMS5gLCBzdWNjZXNzOiBmYWxzZSwgZGVsZXRlZENvdW50OiAwIH07XG4gICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydER0ID49IGVuZER0KSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogXCJTdGFydCBkYXRlIG11c3QgYmUgYmVmb3JlIGVuZCBkYXRlLlwiLCBzdWNjZXNzOiBmYWxzZSwgZGVsZXRlZENvdW50OiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byBkZWxldGUgZXZlbnRzIG1hdGNoaW5nIFwiJHtxdWVyeX1cIiBiZXR3ZWVuICR7c3RhcnREdC50b0lTTygpfSBhbmQgJHtlbmREdC50b0lTTygpfWApO1xuICAgICAgICBsZXQgZmV0Y2hlZEV2ZW50cyA9IFtdOyAvLyBJbml0aWFsaXplIGV2ZW50cyBhcnJheVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAxLiBHZXQgYWxsIGV2ZW50cyBwb3RlbnRpYWxseSBpbiB0aGUgcmFuZ2UgKHVzZSBjYWNoZSlcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5U3RhcnQgPSBzdGFydER0LnN0YXJ0T2YoJ2RheScpLnRvSVNPRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXlFbmQgPSBlbmREdC5lbmRPZignZGF5JykudG9JU09EYXRlKCk7IC8vIEluY2x1c2l2ZSBlbmQgZGF5XG4gICAgICAgICAgICBjb25zdCB0b2tlbkhhc2ggPSBhY2Nlc3NUb2tlbi5zdWJzdHJpbmcoYWNjZXNzVG9rZW4ubGVuZ3RoIC0gMTApO1xuICAgICAgICAgICAgY29uc3QgdXNlcklkQ2FjaGVQcmVmaXggPSBgdXNlcl8ke3Rva2VuSGFzaH1gO1xuXG4gICAgICAgICAgICBsZXQgY2FjaGVkRXZlbnRzID0gYXdhaXQgZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlKHVzZXJJZENhY2hlUHJlZml4LCBjYWNoZUtleVN0YXJ0LCBjYWNoZUtleUVuZCk7XG4gICAgICAgICAgICAgaWYgKGNhY2hlZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FjaGUgSElUIGZvciBidWxrIGRlbGV0ZSBzZWFyY2ggJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgICAgICBmZXRjaGVkRXZlbnRzID0gY2FjaGVkRXZlbnRzO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBNSVNTIGZvciBidWxrIGRlbGV0ZSBzZWFyY2ggJHtjYWNoZUtleVN0YXJ0fSB0byAke2NhY2hlS2V5RW5kfWApO1xuICAgICAgICAgICAgICAgICAvLyBGZXRjaCBicm9hZGx5IGZvciBwb3RlbnRpYWwgY2FjaGluZyBiZW5lZml0IGlmIGRlbGV0aW9uIGZhaWxzIG9yIGlzIHBhcnRpYWxcbiAgICAgICAgICAgICAgICAgY29uc3QgYXBpRXZlbnRzID0gYXdhaXQgZmV0Y2hHQ2FsZW5kYXJFdmVudHNJbnRlcm5hbCh0b2tlbnMsIHN0YXJ0RHQuc3RhcnRPZignZGF5JykudG9KU0RhdGUoKSwgZW5kRGF0ZS5lbmRPZignZGF5JykudG9KU0RhdGUoKSk7XG4gICAgICAgICAgICAgICAgIGZldGNoZWRFdmVudHMgPSAoQXJyYXkuaXNBcnJheShhcGlFdmVudHMpKSA/IGFwaUV2ZW50cyA6IFtdO1xuICAgICAgICAgICAgICAgICAvLyBEb24ndCBjYWNoZSBoZXJlIGltbWVkaWF0ZWx5LCBhcyB3ZSBtaWdodCBkZWxldGUgbWFueS4gQ2FjaGUgbWlnaHQgZ2V0IGludmFsaWRhdGVkIGFueXdheS5cbiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoZWQgJHtmZXRjaGVkRXZlbnRzLmxlbmd0aH0gcG90ZW50aWFsIGV2ZW50cyBmb3IgYnVsayBkZWxldGUgcXVlcnkuYCk7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgLy8gMi4gRmlsdGVyIGZldGNoZWQgZXZlbnRzIHByZWNpc2VseSBieSByZXF1ZXN0ZWQgdGltZSAqYW5kKiBxdWVyeVxuICAgICAgICAgICAgY29uc3QgcXVlcnlMb3dlciA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ0V2ZW50cyA9IGZldGNoZWRFdmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudFN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5zdGFydD8uZGF0ZVRpbWUgfHwgZXZlbnQuc3RhcnQ/LmRhdGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50RW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhldmVudC5lbmQ/LmRhdGVUaW1lIHx8IGV2ZW50LmVuZD8uZGF0ZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VtbWFyeUxvd2VyID0gZXZlbnQuc3VtbWFyeT8udG9Mb3dlckNhc2UoKSB8fCAnJztcblxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFN0YXJ0LmlzVmFsaWQgJiYgZXZlbnRFbmQuaXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0YXJ0IDwgZW5kRHQgJiYgZXZlbnRFbmQgPiBzdGFydER0ICYmIC8vIENoZWNrIHRpbWUgb3ZlcmxhcCB3aXRoIHByZWNpc2UgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeUxvd2VyLmluY2x1ZGVzKHF1ZXJ5TG93ZXIpOyAvLyBDaGVjayBzdW1tYXJ5IG1hdGNoXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBldmVudHMgbWF0Y2hpbmcgXCIke3F1ZXJ5fVwiIGZvdW5kIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogYE5vIGV2ZW50cyBtYXRjaGluZyBcIiR7cXVlcnl9XCIgZm91bmQuYCwgZGVsZXRlZENvdW50OiAwIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke21hdGNoaW5nRXZlbnRzLmxlbmd0aH0gZXZlbnRzIG1hdGNoaW5nIHF1ZXJ5LiBQcm9jZWVkaW5nIHdpdGggZGVsZXRpb24uLi5gKTtcblxuICAgICAgICAgICAgLy8gMy4gRGVsZXRlIGVhY2ggbWF0Y2hpbmcgZXZlbnQgYW5kIGludmFsaWRhdGUgY2FjaGUgaW5kaXZpZHVhbGx5XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXN1bHRzID0gW107XG4gICAgICAgICAgICBjb25zdCBmYWlsZWREZWxldGVzID0gW107XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkYXRlZFJhbmdlcyA9IG5ldyBTZXQoKTsgLy8gVHJhY2sgcmFuZ2VzIHRvIGludmFsaWRhdGUgZWZmaWNpZW50bHlcblxuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBtYXRjaGluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBmcm9tIEdvb2dsZSBDYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxldGVHQ2FsZW5kYXJFdmVudEludGVybmFsKHRva2VucywgZXZlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBkZWxldGVkIGV2ZW50IGZyb20gR29vZ2xlIENhbGVuZGFyOiAke2V2ZW50LmlkfSAoXCIke2V2ZW50LnN1bW1hcnl9XCIpYCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGFzc29jaWF0ZWQgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJJZCAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGV0ZUV2ZW50TWV0YWRhdGEodXNlcklkLCBldmVudC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBkZWxldGVkIG1ldGFkYXRhIGZvciBldmVudDogJHtldmVudC5pZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG1ldGFkYXRhRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZWxldGluZyBtZXRhZGF0YSBmb3IgZXZlbnQgJHtldmVudC5pZH0gZHVyaW5nIGJ1bGsgZGVsZXRlIChwcm9jZWVkaW5nKTpgLCBtZXRhZGF0YUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2cgYnV0IGRvbid0IGNvdW50IGFzIGEgcHJpbWFyeSBmYWlsdXJlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZXN1bHRzLnB1c2goeyBpZDogZXZlbnQuaWQsIHN1bW1hcnk6IGV2ZW50LnN1bW1hcnkgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGV2ZW50J3MgcmFuZ2UgdG8gdGhlIHNldCBmb3IgY2FjaGUgaW52YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50U3RhcnRJc28gPSBldmVudC5zdGFydD8uZGF0ZVRpbWUgfHwgZXZlbnQuc3RhcnQ/LmRhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50RW5kSXNvID0gZXZlbnQuZW5kPy5kYXRlVGltZSB8fCBldmVudC5lbmQ/LmRhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudFN0YXJ0SXNvICYmIGV2ZW50RW5kSXNvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlZFJhbmdlcy5hZGQoYCR7ZXZlbnRTdGFydElzb318JHtldmVudEVuZElzb31gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZGVsZXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBldmVudCAke2V2ZW50LmlkfSAoXCIke2V2ZW50LnN1bW1hcnl9XCIpIGR1cmluZyBidWxrIG9wZXJhdGlvbjpgLCBkZWxldGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZERlbGV0ZXMucHVzaCh7IGlkOiBldmVudC5pZCwgc3VtbWFyeTogZXZlbnQuc3VtbWFyeSwgZXJyb3I6IGRlbGV0ZUVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA0LiBJbnZhbGlkYXRlIGNhY2hlIGZvciBhbGwgYWZmZWN0ZWQgcmFuZ2VzXG4gICAgICAgICAgICBpZiAoaW52YWxpZGF0ZWRSYW5nZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZGF0aW5nIGNhY2hlIGZvciAke2ludmFsaWRhdGVkUmFuZ2VzLnNpemV9IHVuaXF1ZSBkYXRlIHJhbmdlcy5gKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJhbmdlU3RyaW5nIG9mIGludmFsaWRhdGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHJhbmdlU3RyaW5nLnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBpbnZhbGlkYXRlQ2FjaGUodG9rZW5zLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZGF0ZWQgY2FjaGUgcmFuZ2U6ICR7c3RhcnR9IC0gJHtlbmR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goY2FjaGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ2FjaGUgaW52YWxpZGF0aW9uIGVycm9yIGR1cmluZyBidWxrIGRlbGV0ZSBmb3IgcmFuZ2UgJHtzdGFydH0tJHtlbmR9OmAsIGNhY2hlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWxldGVSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBkZWxldGVzIHN1Y2NlZWRlZCBidXQgcmFuZ2VzIGNvdWxkbid0IGJlIGRldGVybWluZWQsIGludmFsaWRhdGUgYnJvYWRseVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgc3BlY2lmaWMgcmFuZ2VzIGZvciBjYWNoZSBpbnZhbGlkYXRpb24gZHVyaW5nIGJ1bGsgZGVsZXRlLCBpbnZhbGlkYXRpbmcgdG9rZW4gY2FjaGUuXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7IGF3YWl0IGludmFsaWRhdGVDYWNoZSh0b2tlbnMpOyB9XG4gICAgICAgICAgICAgICAgY2F0Y2goY2FjaGVFcnJvcikgeyBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW52YWxpZGF0aW5nIGNhY2hlIGFmdGVyIGJ1bGsgZGVsZXRlIChmYWxsYmFjayk6XCIsIGNhY2hlRXJyb3IpOyB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gNS4gQ29tcGlsZSBhbmQgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NDb3VudCA9IGRlbGV0ZVJlc3VsdHMubGVuZ3RoO1xuICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYFN1Y2Nlc3NmdWxseSBkZWxldGVkICR7c3VjY2Vzc0NvdW50fSBldmVudChzKSBtYXRjaGluZyBcIiR7cXVlcnl9XCIuYDtcbiAgICAgICAgICAgICBpZiAoZmFpbGVkRGVsZXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCBGYWlsZWQgdG8gZGVsZXRlICR7ZmFpbGVkRGVsZXRlcy5sZW5ndGh9IGV2ZW50KHMpLiBDaGVjayBsb2dzIGZvciBkZXRhaWxzLmA7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWx1cmVzIGR1cmluZyBidWxrIGRlbGV0ZTpcIiwgZmFpbGVkRGVsZXRlcyk7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhaWxlZERlbGV0ZXMubGVuZ3RoID09PSAwLCAvLyBPdmVyYWxsIHN1Y2Nlc3Mgb25seSBpZiBubyBmYWlsdXJlc1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZGVsZXRlZENvdW50OiBzdWNjZXNzQ291bnQsXG4gICAgICAgICAgICAgICAgZGVsZXRlZEl0ZW1zOiBkZWxldGVSZXN1bHRzLCAvLyBMaXN0IHN1Y2Nlc3NmdWwgb25lc1xuICAgICAgICAgICAgICAgIGZhaWxlZEl0ZW1zOiBmYWlsZWREZWxldGVzICAgLy8gTGlzdCBmYWlsdXJlc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ3JpdGljYWwgZXJyb3IgZHVyaW5nIGRlbGV0ZUNhbGVuZGFyRXZlbnRzQnlRdWVyeSAoJHtxdWVyeX0sICR7c3RhcnRfZGF0ZX0tJHtlbmRfZGF0ZX0pOmAsIGVycm9yKTtcbiAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgZXJyb3I6IGBBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgYnVsayBkZWxldGUgb3BlcmF0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgZGVsZXRlZENvdW50OiAwXG4gICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIC0tLSBFeHBvcnRzIC0tLVxuLy8gRXhwb3J0IHRoZSBzY2hlbWEgYW5kIHRoZSBpbXBsZW1lbnRhdGlvbiBtYXBcbmV4cG9ydCB7IHRvb2xzLCB0b29sRnVuY3Rpb25zIH07Il0sIm5hbWVzIjpbIkRhdGVUaW1lIiwiZ29vZ2xlIiwiY3JlYXRlT0F1dGgyQ2xpZW50IiwiZ2V0Q2FsZW5kYXJFdmVudHMiLCJmZXRjaEdDYWxlbmRhckV2ZW50c0ludGVybmFsIiwiYWRkQ2FsZW5kYXJFdmVudCIsImFkZEdDYWxlbmRhckV2ZW50SW50ZXJuYWwiLCJkZWxldGVDYWxlbmRhckV2ZW50IiwiZGVsZXRlR0NhbGVuZGFyRXZlbnRJbnRlcm5hbCIsInVwZGF0ZUNhbGVuZGFyRXZlbnQiLCJ1cGRhdGVHQ2FsZW5kYXJFdmVudEludGVybmFsIiwiZ2V0Q2FjaGVkRXZlbnRzRm9yRGF0ZVJhbmdlIiwiY2FjaGVFdmVudHNGb3JEYXRlUmFuZ2UiLCJpbnZhbGlkYXRlQ2FjaGUiLCJmaW5kQXZhaWxhYmxlU2xvdHMiLCJmaW5kQXZhaWxhYmxlU2xvdHNVdGlsIiwiY2hlY2tGb3JDb25mbGljdHMiLCJnZXRVc2VyVGltZXpvbmUiLCJjb252ZXJ0VG9VVENJU09TdHJpbmciLCJVc2VyUHJlZmVyZW5jZSIsImFkZE1lc3NhZ2VUb0NvbnZlcnNhdGlvbiIsImNyZWF0ZU9yVXBkYXRlRXZlbnRNZXRhZGF0YSIsImdldEV2ZW50TWV0YWRhdGFCYXRjaCIsImRlbGV0ZUV2ZW50TWV0YWRhdGEiLCJ0b29scyIsInR5cGUiLCJmdW5jdGlvbiIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInBhcmFtZXRlcnMiLCJwcm9wZXJ0aWVzIiwiY2F0ZWdvcnkiLCJrZXkiLCJ2YWx1ZSIsIm9uZU9mIiwiaXRlbXMiLCJjb250ZXh0IiwicmVxdWlyZWQiLCJldmVudHMiLCJzdW1tYXJ5Iiwic3RhcnQiLCJlbmQiLCJsb2NhdGlvbiIsInJlbWluZGVycyIsInByaW9yaXR5IiwiZW51bSIsInRhZ3MiLCJvdmVycmlkZUNvbmZsaWN0cyIsInN0YXJ0X2RhdGUiLCJlbmRfZGF0ZSIsImV2ZW50SWQiLCJ1cGRhdGVzIiwibWluUHJvcGVydGllcyIsImR1cmF0aW9uIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInRpbWVQcmVmZXJlbmNlIiwiYWN0aXZpdHkiLCJkYXRlIiwicXVlcnkiLCJ0b29sRnVuY3Rpb25zIiwic2F2ZVVzZXJQcmVmZXJlbmNlIiwiYXJncyIsInVzZXJJZCIsImFjY2Vzc1Rva2VuIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsInVzZXJQcmVmIiwiY3JlYXRlZCIsImZpbmRPckNyZWF0ZSIsIndoZXJlIiwidXNlcl9pZCIsImRlZmF1bHRzIiwicHJlZmVyZW5jZXNfZGF0YSIsImN1cnJlbnRQcmVmcyIsInVwZGF0ZWRQcmVmcyIsImNvbnRleHRLZXkiLCJ1cGRhdGVDb3VudCIsInVwZGF0ZSIsInZlcmlmeVByZWYiLCJmaW5kT25lIiwiZXJyb3IiLCJhZGRDYWxlbmRhckV2ZW50cyIsInRva2VucyIsImFjY2Vzc190b2tlbiIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInJlc3VsdHMiLCJhZmZlY3RlZERhdGVSYW5nZXMiLCJldmVudCIsInB1c2giLCJ1c2VyVGltZXpvbmUiLCJzdGFydFV0YyIsImVuZFV0YyIsIkVycm9yIiwic3RhcnREdCIsImZyb21JU08iLCJlbmREdCIsImlzVmFsaWQiLCJlIiwiY29uZmxpY3RDaGVja1Jlc3VsdCIsImNvbmZsaWN0cyIsIndhcm4iLCJjb25mbGljdCIsInN1Z2dlc3Rpb25zIiwib3ZlcnJpZGRlbiIsImFkZGVkRXZlbnQiLCJoYXNNZXRhZGF0YSIsImlkIiwibWV0YWRhdGFFcnJvciIsImNvbmZsaWN0T3ZlcnJpZGRlbiIsImNvbmZsaWN0Q291bnQiLCJhZGRFcnJvciIsInJhbmdlIiwiY2FjaGVFcnJvciIsImZpbmFsRXZlbnRzIiwiY2FjaGVLZXlTdGFydCIsInN0YXJ0T2YiLCJ0b0lTT0RhdGUiLCJjYWNoZUtleUVuZCIsImVuZE9mIiwidG9rZW5IYXNoIiwic3Vic3RyaW5nIiwidXNlcklkQ2FjaGVQcmVmaXgiLCJjYWNoZWRFdmVudHMiLCJmaWx0ZXIiLCJldmVudFN0YXJ0IiwiZGF0ZVRpbWUiLCJldmVudEVuZCIsImFwaUV2ZW50cyIsInRvSlNEYXRlIiwidG9JU08iLCJnb29nbGVFdmVudElkcyIsIm1hcCIsIm1ldGFkYXRhUmVjb3JkcyIsIm1ldGFkYXRhTWFwIiwiTWFwIiwiZm9yRWFjaCIsInJlY29yZCIsInNldCIsImdvb2dsZV9ldmVudF9pZCIsIm1ldGFkYXRhIiwiZ2V0IiwiZW5yaWNobWVudCIsInNpemUiLCJvcmlnaW5hbFN0YXJ0RGF0ZSIsIm9yaWdpbmFsRW5kRGF0ZSIsImV2ZW50U3VtbWFyeSIsIm9hdXRoMkNsaWVudCIsImNhbGVuZGFyIiwidmVyc2lvbiIsImF1dGgiLCJjYWxlbmRhcklkIiwiZGF0YSIsImdldEVycm9yIiwiY29kZSIsIk9iamVjdCIsImtleXMiLCJ1cGRhdGVTdGFydER0IiwidXBkYXRlRW5kRHQiLCJ2YWxpZGF0aW9uRXJyb3IiLCJvcmlnaW5hbFN1bW1hcnkiLCJvcmlnaW5hbEV2ZW50RGF0YSIsImV2ZW50UmVzcG9uc2UiLCJmaW5hbFN0YXJ0IiwiZmluYWxFbmQiLCJ1cGRhdGVQYXlsb2FkIiwidXBkYXRlZEV2ZW50IiwiaGFzTWV0YWRhdGFVcGRhdGUiLCJyYW5nZXNUb0ludmFsaWRhdGUiLCJuZXdTdGFydERhdGUiLCJuZXdFbmREYXRlIiwidW5pcXVlUmFuZ2VzIiwiU2V0IiwiciIsInMiLCJzcGxpdCIsInNsb3RzIiwicmVxU3RhcnREYXRlIiwicmVxRW5kRGF0ZSIsIm5vdyIsInBsdXMiLCJkYXlzIiwiZmV0Y2hlZEV2ZW50cyIsInJlbGV2YW50RXZlbnRzIiwic2xvdHNSZXN1bHQiLCJnZXRXZWF0aGVyRm9yZWNhc3QiLCJkYXRlU3RyaW5nIiwiZm9yZWNhc3REYXRlIiwiZm9ybWF0dGVkRGF0ZSIsImZvcmVjYXN0IiwiZGVsZXRlQ2FsZW5kYXJFdmVudHNCeVF1ZXJ5IiwiZGVsZXRlZENvdW50IiwicXVlcnlMb3dlciIsInRvTG93ZXJDYXNlIiwibWF0Y2hpbmdFdmVudHMiLCJzdW1tYXJ5TG93ZXIiLCJpbmNsdWRlcyIsImRlbGV0ZVJlc3VsdHMiLCJmYWlsZWREZWxldGVzIiwiaW52YWxpZGF0ZWRSYW5nZXMiLCJldmVudFN0YXJ0SXNvIiwiZXZlbnRFbmRJc28iLCJhZGQiLCJkZWxldGVFcnJvciIsInJhbmdlU3RyaW5nIiwic3VjY2Vzc0NvdW50IiwiZGVsZXRlZEl0ZW1zIiwiZmFpbGVkSXRlbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/tools/toolIndex.js\n");

/***/ }),

/***/ "(api)/./pages/api/auth/[...nextauth].js":
/*!*****************************************!*\
  !*** ./pages/api/auth/[...nextauth].js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authOptions: () => (/* binding */ authOptions),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-auth */ \"next-auth\");\n/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_auth__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/providers/google */ \"next-auth/providers/google\");\n/* harmony import */ var next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst authOptions = {\n    providers: [\n        next_auth_providers_google__WEBPACK_IMPORTED_MODULE_1___default()({\n            clientId: process.env.GOOGLE_CLIENT_ID,\n            clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n            authorization: {\n                params: {\n                    scope: \"https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/calendar\",\n                    access_type: \"offline\",\n                    prompt: \"consent\"\n                }\n            }\n        })\n    ],\n    callbacks: {\n        async jwt ({ token, account, user }) {\n            // Initial sign in\n            if (account && user) {\n                return {\n                    accessToken: account.access_token,\n                    refreshToken: account.refresh_token,\n                    accessTokenExpires: account.expires_at * 1000,\n                    user\n                };\n            }\n            // Return previous token if the access token has not expired yet\n            if (Date.now() < token.accessTokenExpires) {\n                return token;\n            }\n            // Access token has expired, try to refresh it\n            try {\n                const response = await fetch(\"https://oauth2.googleapis.com/token\", {\n                    headers: {\n                        \"Content-Type\": \"application/x-www-form-urlencoded\"\n                    },\n                    body: new URLSearchParams({\n                        client_id: process.env.GOOGLE_CLIENT_ID,\n                        client_secret: process.env.GOOGLE_CLIENT_SECRET,\n                        grant_type: \"refresh_token\",\n                        refresh_token: token.refreshToken\n                    }),\n                    method: \"POST\"\n                });\n                const refreshedTokens = await response.json();\n                if (!response.ok) {\n                    throw refreshedTokens;\n                }\n                return {\n                    ...token,\n                    accessToken: refreshedTokens.access_token,\n                    accessTokenExpires: Date.now() + refreshedTokens.expires_in * 1000,\n                    // Fall back to old refresh token, but note that\n                    // many providers may only allow using a refresh token once\n                    refreshToken: refreshedTokens.refresh_token ?? token.refreshToken\n                };\n            } catch (error) {\n                console.error(\"Error refreshing access token\", error);\n                // The error property will be used client-side to handle the refresh token error\n                return {\n                    ...token,\n                    error: \"RefreshAccessTokenError\"\n                };\n            }\n        },\n        async session ({ session, token }) {\n            session.user = token.user;\n            session.accessToken = token.accessToken;\n            session.error = token.error;\n            return session;\n        }\n    },\n    // Enable debug messages in the console if you are having problems\n    debug: \"development\" === \"development\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (next_auth__WEBPACK_IMPORTED_MODULE_0___default()(authOptions));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvYXV0aC9bLi4ubmV4dGF1dGhdLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpQztBQUN1QjtBQUVqRCxNQUFNRSxjQUFjO0lBQ3pCQyxXQUFXO1FBQ1RGLGlFQUFjQSxDQUFDO1lBQ2JHLFVBQVVDLFFBQVFDLEdBQUcsQ0FBQ0MsZ0JBQWdCO1lBQ3RDQyxjQUFjSCxRQUFRQyxHQUFHLENBQUNHLG9CQUFvQjtZQUM5Q0MsZUFBZTtnQkFDYkMsUUFBUTtvQkFDTkMsT0FBTztvQkFDUEMsYUFBYTtvQkFDYkMsUUFBUTtnQkFDVjtZQUNGO1FBQ0Y7S0FDRDtJQUNEQyxXQUFXO1FBQ1QsTUFBTUMsS0FBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFO1lBQ2hDLGtCQUFrQjtZQUNsQixJQUFJRCxXQUFXQyxNQUFNO2dCQUNuQixPQUFPO29CQUNMQyxhQUFhRixRQUFRRyxZQUFZO29CQUNqQ0MsY0FBY0osUUFBUUssYUFBYTtvQkFDbkNDLG9CQUFvQk4sUUFBUU8sVUFBVSxHQUFHO29CQUN6Q047Z0JBQ0Y7WUFDRjtZQUVBLGdFQUFnRTtZQUNoRSxJQUFJTyxLQUFLQyxHQUFHLEtBQUtWLE1BQU1PLGtCQUFrQixFQUFFO2dCQUN6QyxPQUFPUDtZQUNUO1lBRUEsOENBQThDO1lBQzlDLElBQUk7Z0JBQ0YsTUFBTVcsV0FBVyxNQUFNQyxNQUFNLHVDQUF1QztvQkFDbEVDLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFvQztvQkFDL0RDLE1BQU0sSUFBSUMsZ0JBQWdCO3dCQUN4QkMsV0FBVzVCLFFBQVFDLEdBQUcsQ0FBQ0MsZ0JBQWdCO3dCQUN2QzJCLGVBQWU3QixRQUFRQyxHQUFHLENBQUNHLG9CQUFvQjt3QkFDL0MwQixZQUFZO3dCQUNaWixlQUFlTixNQUFNSyxZQUFZO29CQUNuQztvQkFDQWMsUUFBUTtnQkFDVjtnQkFFQSxNQUFNQyxrQkFBa0IsTUFBTVQsU0FBU1UsSUFBSTtnQkFFM0MsSUFBSSxDQUFDVixTQUFTVyxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1GO2dCQUNSO2dCQUVBLE9BQU87b0JBQ0wsR0FBR3BCLEtBQUs7b0JBQ1JHLGFBQWFpQixnQkFBZ0JoQixZQUFZO29CQUN6Q0csb0JBQW9CRSxLQUFLQyxHQUFHLEtBQUtVLGdCQUFnQkcsVUFBVSxHQUFHO29CQUM5RCxnREFBZ0Q7b0JBQ2hELDJEQUEyRDtvQkFDM0RsQixjQUFjZSxnQkFBZ0JkLGFBQWEsSUFBSU4sTUFBTUssWUFBWTtnQkFDbkU7WUFDRixFQUFFLE9BQU9tQixPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtnQkFDL0MsZ0ZBQWdGO2dCQUNoRixPQUFPO29CQUFFLEdBQUd4QixLQUFLO29CQUFFd0IsT0FBTztnQkFBMEI7WUFDdEQ7UUFDRjtRQUNBLE1BQU1FLFNBQVEsRUFBRUEsT0FBTyxFQUFFMUIsS0FBSyxFQUFFO1lBQzlCMEIsUUFBUXhCLElBQUksR0FBR0YsTUFBTUUsSUFBSTtZQUN6QndCLFFBQVF2QixXQUFXLEdBQUdILE1BQU1HLFdBQVc7WUFDdkN1QixRQUFRRixLQUFLLEdBQUd4QixNQUFNd0IsS0FBSztZQUMzQixPQUFPRTtRQUNUO0lBQ0Y7SUFDQSxrRUFBa0U7SUFDbEVDLE9BQU92QyxrQkFBeUI7QUFDbEMsRUFBRTtBQUVGLGlFQUFlTCxnREFBUUEsQ0FBQ0UsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL3BhZ2VzL2FwaS9hdXRoL1suLi5uZXh0YXV0aF0uanM/NTI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTmV4dEF1dGggZnJvbSAnbmV4dC1hdXRoJztcbmltcG9ydCBHb29nbGVQcm92aWRlciBmcm9tICduZXh0LWF1dGgvcHJvdmlkZXJzL2dvb2dsZSc7XG5cbmV4cG9ydCBjb25zdCBhdXRoT3B0aW9ucyA9IHtcbiAgcHJvdmlkZXJzOiBbXG4gICAgR29vZ2xlUHJvdmlkZXIoe1xuICAgICAgY2xpZW50SWQ6IHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfSUQsXG4gICAgICBjbGllbnRTZWNyZXQ6IHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfU0VDUkVULFxuICAgICAgYXV0aG9yaXphdGlvbjoge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBzY29wZTogJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvdXNlcmluZm8ucHJvZmlsZSBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3VzZXJpbmZvLmVtYWlsIGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2FsZW5kYXInLFxuICAgICAgICAgIGFjY2Vzc190eXBlOiAnb2ZmbGluZScsXG4gICAgICAgICAgcHJvbXB0OiAnY29uc2VudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICBdLFxuICBjYWxsYmFja3M6IHtcbiAgICBhc3luYyBqd3QoeyB0b2tlbiwgYWNjb3VudCwgdXNlciB9KSB7XG4gICAgICAvLyBJbml0aWFsIHNpZ24gaW5cbiAgICAgIGlmIChhY2NvdW50ICYmIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY2Nlc3NUb2tlbjogYWNjb3VudC5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgcmVmcmVzaFRva2VuOiBhY2NvdW50LnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgYWNjZXNzVG9rZW5FeHBpcmVzOiBhY2NvdW50LmV4cGlyZXNfYXQgKiAxMDAwLCAvLyBDb252ZXJ0IHRvIG1pbGxpc2Vjb25kc1xuICAgICAgICAgIHVzZXJcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHByZXZpb3VzIHRva2VuIGlmIHRoZSBhY2Nlc3MgdG9rZW4gaGFzIG5vdCBleHBpcmVkIHlldFxuICAgICAgaWYgKERhdGUubm93KCkgPCB0b2tlbi5hY2Nlc3NUb2tlbkV4cGlyZXMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuXG4gICAgICAvLyBBY2Nlc3MgdG9rZW4gaGFzIGV4cGlyZWQsIHRyeSB0byByZWZyZXNoIGl0XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbicsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxuICAgICAgICAgIGJvZHk6IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgY2xpZW50X2lkOiBwcm9jZXNzLmVudi5HT09HTEVfQ0xJRU5UX0lELFxuICAgICAgICAgICAgY2xpZW50X3NlY3JldDogcHJvY2Vzcy5lbnYuR09PR0xFX0NMSUVOVF9TRUNSRVQsXG4gICAgICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiB0b2tlbi5yZWZyZXNoVG9rZW4sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlZnJlc2hlZFRva2VucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgcmVmcmVzaGVkVG9rZW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICBhY2Nlc3NUb2tlbjogcmVmcmVzaGVkVG9rZW5zLmFjY2Vzc190b2tlbixcbiAgICAgICAgICBhY2Nlc3NUb2tlbkV4cGlyZXM6IERhdGUubm93KCkgKyByZWZyZXNoZWRUb2tlbnMuZXhwaXJlc19pbiAqIDEwMDAsXG4gICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG9sZCByZWZyZXNoIHRva2VuLCBidXQgbm90ZSB0aGF0XG4gICAgICAgICAgLy8gbWFueSBwcm92aWRlcnMgbWF5IG9ubHkgYWxsb3cgdXNpbmcgYSByZWZyZXNoIHRva2VuIG9uY2VcbiAgICAgICAgICByZWZyZXNoVG9rZW46IHJlZnJlc2hlZFRva2Vucy5yZWZyZXNoX3Rva2VuID8/IHRva2VuLnJlZnJlc2hUb2tlbixcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlZnJlc2hpbmcgYWNjZXNzIHRva2VuJywgZXJyb3IpO1xuICAgICAgICAvLyBUaGUgZXJyb3IgcHJvcGVydHkgd2lsbCBiZSB1c2VkIGNsaWVudC1zaWRlIHRvIGhhbmRsZSB0aGUgcmVmcmVzaCB0b2tlbiBlcnJvclxuICAgICAgICByZXR1cm4geyAuLi50b2tlbiwgZXJyb3I6ICdSZWZyZXNoQWNjZXNzVG9rZW5FcnJvcicgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHNlc3Npb24oeyBzZXNzaW9uLCB0b2tlbiB9KSB7XG4gICAgICBzZXNzaW9uLnVzZXIgPSB0b2tlbi51c2VyO1xuICAgICAgc2Vzc2lvbi5hY2Nlc3NUb2tlbiA9IHRva2VuLmFjY2Vzc1Rva2VuO1xuICAgICAgc2Vzc2lvbi5lcnJvciA9IHRva2VuLmVycm9yO1xuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICB9LFxuICAvLyBFbmFibGUgZGVidWcgbWVzc2FnZXMgaW4gdGhlIGNvbnNvbGUgaWYgeW91IGFyZSBoYXZpbmcgcHJvYmxlbXNcbiAgZGVidWc6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTmV4dEF1dGgoYXV0aE9wdGlvbnMpOyJdLCJuYW1lcyI6WyJOZXh0QXV0aCIsIkdvb2dsZVByb3ZpZGVyIiwiYXV0aE9wdGlvbnMiLCJwcm92aWRlcnMiLCJjbGllbnRJZCIsInByb2Nlc3MiLCJlbnYiLCJHT09HTEVfQ0xJRU5UX0lEIiwiY2xpZW50U2VjcmV0IiwiR09PR0xFX0NMSUVOVF9TRUNSRVQiLCJhdXRob3JpemF0aW9uIiwicGFyYW1zIiwic2NvcGUiLCJhY2Nlc3NfdHlwZSIsInByb21wdCIsImNhbGxiYWNrcyIsImp3dCIsInRva2VuIiwiYWNjb3VudCIsInVzZXIiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJhY2Nlc3NUb2tlbkV4cGlyZXMiLCJleHBpcmVzX2F0IiwiRGF0ZSIsIm5vdyIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwiYm9keSIsIlVSTFNlYXJjaFBhcmFtcyIsImNsaWVudF9pZCIsImNsaWVudF9zZWNyZXQiLCJncmFudF90eXBlIiwibWV0aG9kIiwicmVmcmVzaGVkVG9rZW5zIiwianNvbiIsIm9rIiwiZXhwaXJlc19pbiIsImVycm9yIiwiY29uc29sZSIsInNlc3Npb24iLCJkZWJ1ZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/auth/[...nextauth].js\n");

/***/ }),

/***/ "(api)/./pages/api/chat-stream.js":
/*!**********************************!*\
  !*** ./pages/api/chat-stream.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_chatbot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/chatbot */ \"(api)/./lib/chatbot.js\");\n/* harmony import */ var next_auth_next__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/next */ \"next-auth/next\");\n/* harmony import */ var next_auth_next__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_next__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _api_auth_nextauth___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/auth/[...nextauth] */ \"(api)/./pages/api/auth/[...nextauth].js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_chatbot__WEBPACK_IMPORTED_MODULE_0__]);\n_lib_chatbot__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst config = {\n    api: {\n        responseLimit: false\n    }\n};\nasync function handler(req, res) {\n    // This endpoint only accepts GET requests for SSE\n    if (req.method !== \"GET\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    try {\n        const session = await (0,next_auth_next__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(req, res, _api_auth_nextauth___WEBPACK_IMPORTED_MODULE_2__.authOptions);\n        const { message, startNew } = req.query; // Read startNew query param\n        const startNewConversation = startNew === \"true\"; // Convert to boolean\n        if (!message) {\n            return res.status(400).json({\n                error: \"Message is required\"\n            });\n        }\n        // Check if user is authenticated\n        if (!session) {\n            return res.status(401).json({\n                error: \"Authentication required\"\n            });\n        }\n        // Check if token has an error (failed refresh)\n        if (session.error === \"RefreshAccessTokenError\") {\n            return res.status(401).json({\n                error: \"Your session has expired. Please sign in again.\"\n            });\n        }\n        // Get user ID from session\n        const userId = session.user?.email || \"default\";\n        // Get access token from session\n        const accessToken = session.accessToken;\n        // Set up Server-Sent Events\n        res.writeHead(200, {\n            \"Content-Type\": \"text/event-stream\",\n            \"Cache-Control\": \"no-cache, no-transform, no-store\",\n            \"Connection\": \"keep-alive\",\n            \"X-Accel-Buffering\": \"no\" // Disable buffering in Nginx\n        });\n        // Send initial message\n        res.write(`data: ${JSON.stringify({\n            type: \"start\"\n        })}\\n\\n`);\n        // Force flush the initial messages\n        if (res.flush) {\n            try {\n                res.flush();\n            } catch (flushError) {\n                console.warn(\"Error flushing start message:\", flushError);\n            }\n        }\n        // Create a callback function to handle streaming chunks\n        const streamCallback = (chunk)=>{\n            try {\n                const chunkData = JSON.stringify(chunk);\n                res.write(`data: ${chunkData}\\n\\n`);\n            } catch (writeError) {\n                console.error(\"Error writing chunk to response:\", writeError);\n            }\n            // Flush the response to ensure chunks are sent immediately\n            if (res.flush) {\n                try {\n                    res.flush();\n                } catch (flushError) {\n                    console.warn(\"Error flushing response:\", flushError);\n                }\n            }\n        };\n        try {\n            // Call the chatbot with streaming enabled\n            await (0,_lib_chatbot__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(message, userId, accessToken, streamCallback, startNewConversation);\n            // Add a small delay before sending the end message to ensure all processing steps are visible\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n            // Send completion message\n            const endMessage = JSON.stringify({\n                type: \"end\"\n            });\n            res.write(`data: ${endMessage}\\n\\n`);\n            // Final flush before ending\n            if (res.flush) {\n                try {\n                    res.flush();\n                } catch (flushError) {\n                    console.warn(\"Error flushing final response:\", flushError);\n                }\n            }\n            // Add another small delay before ending the response\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            res.end();\n        } catch (error) {\n            // Send error message\n            console.error(\"Error in chat-stream processing:\", error);\n            res.write(`data: ${JSON.stringify({\n                type: \"error\",\n                content: error.message\n            })}\\n\\n`);\n            // Flush error message\n            if (res.flush) {\n                try {\n                    res.flush();\n                } catch (flushError) {\n                    console.warn(\"Error flushing error response:\", flushError);\n                }\n            }\n            res.end();\n        }\n    } catch (error) {\n        console.error(\"Error in chat-stream API:\", error);\n        return res.status(500).json({\n            error: \"An error occurred while processing your request\"\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7WUFFbkMsNEJBQTRCO1lBQzVCLElBQUk5QixJQUFJbUIsS0FBSyxFQUFFO2dCQUNiLElBQUk7b0JBQ0ZuQixJQUFJbUIsS0FBSztnQkFDWCxFQUFFLE9BQU9DLFlBQVk7b0JBQ25CQyxRQUFRQyxJQUFJLENBQUMsa0NBQWtDRjtnQkFDakQ7WUFDRjtZQUVBLHFEQUFxRDtZQUNyRCxNQUFNLElBQUlPLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFFakQ1QixJQUFJK0IsR0FBRztRQUNULEVBQUUsT0FBTzNCLE9BQU87WUFDZCxxQkFBcUI7WUFDckJpQixRQUFRakIsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbERKLElBQUllLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFQyxNQUFNO2dCQUFTYyxTQUFTNUIsTUFBTUUsT0FBTztZQUFDLEdBQUcsSUFBSSxDQUFDO1lBQ2xGLHNCQUFzQjtZQUN0QixJQUFJTixJQUFJbUIsS0FBSyxFQUFFO2dCQUNiLElBQUk7b0JBQ0ZuQixJQUFJbUIsS0FBSztnQkFDWCxFQUFFLE9BQU9DLFlBQVk7b0JBQ25CQyxRQUFRQyxJQUFJLENBQUMsa0NBQWtDRjtnQkFDakQ7WUFDRjtZQUNBcEIsSUFBSStCLEdBQUc7UUFDVDtJQUNGLEVBQUUsT0FBTzNCLE9BQU87UUFDZGlCLFFBQVFqQixLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxPQUFPSixJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQUVDLE9BQU87UUFBa0Q7SUFDekY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2djYWxlbmRhcmFwcC8uL3BhZ2VzL2FwaS9jaGF0LXN0cmVhbS5qcz81ZmNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaGF0Ym90IGZyb20gJy4uLy4uL2xpYi9jaGF0Ym90JztcbmltcG9ydCB7IGdldFNlcnZlclNlc3Npb24gfSBmcm9tICduZXh0LWF1dGgvbmV4dCc7XG5pbXBvcnQgeyBhdXRoT3B0aW9ucyB9IGZyb20gJy4uL2FwaS9hdXRoL1suLi5uZXh0YXV0aF0nO1xuXG5leHBvcnQgY29uc3QgY29uZmlnID0ge1xuICBhcGk6IHtcbiAgICByZXNwb25zZUxpbWl0OiBmYWxzZSxcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMpIHtcbiAgLy8gVGhpcyBlbmRwb2ludCBvbmx5IGFjY2VwdHMgR0VUIHJlcXVlc3RzIGZvciBTU0VcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0U2VydmVyU2Vzc2lvbihyZXEsIHJlcywgYXV0aE9wdGlvbnMpO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgc3RhcnROZXcgfSA9IHJlcS5xdWVyeTsgLy8gUmVhZCBzdGFydE5ldyBxdWVyeSBwYXJhbVxuICAgIGNvbnN0IHN0YXJ0TmV3Q29udmVyc2F0aW9uID0gc3RhcnROZXcgPT09ICd0cnVlJzsgLy8gQ29udmVydCB0byBib29sZWFuXG4gICAgXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ01lc3NhZ2UgaXMgcmVxdWlyZWQnIH0pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAxKS5qc29uKHsgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaGFzIGFuIGVycm9yIChmYWlsZWQgcmVmcmVzaClcbiAgICBpZiAoc2Vzc2lvbi5lcnJvciA9PT0gJ1JlZnJlc2hBY2Nlc3NUb2tlbkVycm9yJykge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAxKS5qc29uKHsgZXJyb3I6ICdZb3VyIHNlc3Npb24gaGFzIGV4cGlyZWQuIFBsZWFzZSBzaWduIGluIGFnYWluLicgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHVzZXIgSUQgZnJvbSBzZXNzaW9uXG4gICAgY29uc3QgdXNlcklkID0gc2Vzc2lvbi51c2VyPy5lbWFpbCB8fCAnZGVmYXVsdCc7XG4gICAgXG4gICAgLy8gR2V0IGFjY2VzcyB0b2tlbiBmcm9tIHNlc3Npb25cbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHNlc3Npb24uYWNjZXNzVG9rZW47XG4gICAgXG4gICAgLy8gU2V0IHVwIFNlcnZlci1TZW50IEV2ZW50c1xuICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvZXZlbnQtc3RyZWFtJyxcbiAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby10cmFuc2Zvcm0sIG5vLXN0b3JlJyxcbiAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxuICAgICAgJ1gtQWNjZWwtQnVmZmVyaW5nJzogJ25vJyAvLyBEaXNhYmxlIGJ1ZmZlcmluZyBpbiBOZ2lueFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNlbmQgaW5pdGlhbCBtZXNzYWdlXG4gICAgcmVzLndyaXRlKGBkYXRhOiAke0pTT04uc3RyaW5naWZ5KHsgdHlwZTogJ3N0YXJ0JyB9KX1cXG5cXG5gKTtcbiAgICBcbiAgICAvLyBGb3JjZSBmbHVzaCB0aGUgaW5pdGlhbCBtZXNzYWdlc1xuICAgIGlmIChyZXMuZmx1c2gpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcy5mbHVzaCgpO1xuICAgICAgfSBjYXRjaCAoZmx1c2hFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBmbHVzaGluZyBzdGFydCBtZXNzYWdlOlwiLCBmbHVzaEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaGFuZGxlIHN0cmVhbWluZyBjaHVua3NcbiAgICBjb25zdCBzdHJlYW1DYWxsYmFjayA9IChjaHVuaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2h1bmtEYXRhID0gSlNPTi5zdHJpbmdpZnkoY2h1bmspO1xuICAgICAgICByZXMud3JpdGUoYGRhdGE6ICR7Y2h1bmtEYXRhfVxcblxcbmApO1xuICAgICAgfSBjYXRjaCAod3JpdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd3JpdGluZyBjaHVuayB0byByZXNwb25zZTpcIiwgd3JpdGVFcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZsdXNoIHRoZSByZXNwb25zZSB0byBlbnN1cmUgY2h1bmtzIGFyZSBzZW50IGltbWVkaWF0ZWx5XG4gICAgICBpZiAocmVzLmZsdXNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzLmZsdXNoKCk7XG4gICAgICAgIH0gY2F0Y2ggKGZsdXNoRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBmbHVzaGluZyByZXNwb25zZTpcIiwgZmx1c2hFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDYWxsIHRoZSBjaGF0Ym90IHdpdGggc3RyZWFtaW5nIGVuYWJsZWRcbiAgICAgIGF3YWl0IGNoYXRib3QobWVzc2FnZSwgdXNlcklkLCBhY2Nlc3NUb2tlbiwgc3RyZWFtQ2FsbGJhY2ssIHN0YXJ0TmV3Q29udmVyc2F0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgYmVmb3JlIHNlbmRpbmcgdGhlIGVuZCBtZXNzYWdlIHRvIGVuc3VyZSBhbGwgcHJvY2Vzc2luZyBzdGVwcyBhcmUgdmlzaWJsZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgXG4gICAgICAvLyBTZW5kIGNvbXBsZXRpb24gbWVzc2FnZVxuICAgICAgY29uc3QgZW5kTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHsgdHlwZTogJ2VuZCcgfSk7XG4gICAgICByZXMud3JpdGUoYGRhdGE6ICR7ZW5kTWVzc2FnZX1cXG5cXG5gKTtcbiAgICAgIFxuICAgICAgLy8gRmluYWwgZmx1c2ggYmVmb3JlIGVuZGluZ1xuICAgICAgaWYgKHJlcy5mbHVzaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcy5mbHVzaCgpO1xuICAgICAgICB9IGNhdGNoIChmbHVzaEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZmx1c2hpbmcgZmluYWwgcmVzcG9uc2U6XCIsIGZsdXNoRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBhbm90aGVyIHNtYWxsIGRlbGF5IGJlZm9yZSBlbmRpbmcgdGhlIHJlc3BvbnNlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICBcbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU2VuZCBlcnJvciBtZXNzYWdlXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2hhdC1zdHJlYW0gcHJvY2Vzc2luZzpcIiwgZXJyb3IpO1xuICAgICAgcmVzLndyaXRlKGBkYXRhOiAke0pTT04uc3RyaW5naWZ5KHsgdHlwZTogJ2Vycm9yJywgY29udGVudDogZXJyb3IubWVzc2FnZSB9KX1cXG5cXG5gKTtcbiAgICAgIC8vIEZsdXNoIGVycm9yIG1lc3NhZ2VcbiAgICAgIGlmIChyZXMuZmx1c2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMuZmx1c2goKTtcbiAgICAgICAgfSBjYXRjaCAoZmx1c2hFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZsdXNoaW5nIGVycm9yIHJlc3BvbnNlOlwiLCBmbHVzaEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzLmVuZCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBjaGF0LXN0cmVhbSBBUEk6JywgZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcHJvY2Vzc2luZyB5b3VyIHJlcXVlc3QnIH0pO1xuICB9XG59Il0sIm5hbWVzIjpbImNoYXRib3QiLCJnZXRTZXJ2ZXJTZXNzaW9uIiwiYXV0aE9wdGlvbnMiLCJjb25maWciLCJhcGkiLCJyZXNwb25zZUxpbWl0IiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsInN0YXR1cyIsImpzb24iLCJlcnJvciIsInNlc3Npb24iLCJtZXNzYWdlIiwic3RhcnROZXciLCJxdWVyeSIsInN0YXJ0TmV3Q29udmVyc2F0aW9uIiwidXNlcklkIiwidXNlciIsImVtYWlsIiwiYWNjZXNzVG9rZW4iLCJ3cml0ZUhlYWQiLCJ3cml0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0eXBlIiwiZmx1c2giLCJmbHVzaEVycm9yIiwiY29uc29sZSIsIndhcm4iLCJzdHJlYW1DYWxsYmFjayIsImNodW5rIiwiY2h1bmtEYXRhIiwid3JpdGVFcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImVuZE1lc3NhZ2UiLCJlbmQiLCJjb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/chat-stream.js\n");

/***/ }),

/***/ "(api)/./credentials.json":
/*!**************************!*\
  !*** ./credentials.json ***!
  \**************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"web":{"client_id":"1067969091630-i858c64u30bsfafv6803adcbropoiqpl.apps.googleusercontent.com","project_id":"gcalendarmate","auth_uri":"https://accounts.google.com/o/oauth2/auth","token_uri":"https://oauth2.googleapis.com/token","auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs","client_secret":"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","redirect_uris":["http://localhost:3000/auth/google/callback","https://gcalendarapp.vercel.app/auth/google","https://gcalendarapp.vercel.app/auth/google/callback","http://localhost:3000/api/auth/callback/google"],"javascript_origins":["http://localhost:3000","https://gcalendarapp.vercel.app"]}}');

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fchat-stream&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fchat-stream.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();